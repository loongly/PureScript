<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.Decompiler</name>
    </assembly>
    <members>
        <member name="T:ICSharpCode.Decompiler.CSharp.LdTokenAnnotation">
            <summary>
            Currently unused; we'll probably use the LdToken ILInstruction as annotation instead when LdToken
            support gets reimplemented.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.GetSymbol(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Retrieves the <see cref="T:ICSharpCode.Decompiler.TypeSystem.ISymbol"/> associated with this AstNode, or null if no symbol
            is associated with the node.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.GetResolveResult(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Retrieves the <see cref="T:ICSharpCode.Decompiler.Semantics.ResolveResult"/> associated with this <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.AstNode"/>,
            or <see cref="F:ICSharpCode.Decompiler.Semantics.ErrorResolveResult.UnknownError"/> if no resolve result is associated with the node.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.GetILVariable(ICSharpCode.Decompiler.CSharp.Syntax.IdentifierExpression)">
            <summary>
            Retrieves the <see cref="T:ICSharpCode.Decompiler.IL.ILVariable"/> associated with this <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.IdentifierExpression"/>,
            or <c>null</c> if no variable is associated with this identifier.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.GetILVariable(ICSharpCode.Decompiler.CSharp.Syntax.VariableInitializer)">
            <summary>
            Retrieves the <see cref="T:ICSharpCode.Decompiler.IL.ILVariable"/> associated with this <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.VariableInitializer"/>,
            or <c>null</c> if no variable is associated with this initializer.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.GetILVariable(ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement)">
            <summary>
            Retrieves the <see cref="T:ICSharpCode.Decompiler.IL.ILVariable"/> associated with this <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement"/>,
            or <c>null</c> if no variable is associated with this foreach statement.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.WithILVariable(ICSharpCode.Decompiler.CSharp.Syntax.VariableInitializer,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Adds an <see cref="T:ICSharpCode.Decompiler.IL.ILVariable"/> to this initializer.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.WithILVariable(ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Adds an <see cref="T:ICSharpCode.Decompiler.IL.ILVariable"/> to this foreach statement.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.CopyAnnotationsFrom``1(``0,ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Copies all annotations from <paramref name="other"/> to <paramref name="node"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.AnnotationExtensions.CopyInstructionsFrom``1(``0,ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Copies all <see cref="T:ICSharpCode.Decompiler.IL.ILInstruction"/> annotations from <paramref name="other"/>
            to <paramref name="node"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ILVariableResolveResult">
            <summary>
            Represents a reference to a local variable.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ForeachAnnotation">
            <summary>
            Annotates a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement"/> with the instructions for the GetEnumerator, MoveNext
            and get_Current calls.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ImplicitReturnAnnotation">
            <summary>
            Annotates the top-level block statement of a function
            with the implicitly executed return/yield break.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ImplicitConversionAnnotation">
            <summary>
            Annotates an expression when an implicit user-defined conversion was omitted.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.QueryGroupClauseAnnotation">
            <summary>
            Annotates a QueryGroupClause with the ILFunctions of each (implicit lambda) expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.QueryJoinClauseAnnotation">
            <summary>
            Annotates a QueryJoinClause with the ILFunctions of each (implicit lambda) expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.UseImplicitlyTypedOutAnnotation">
            <summary>
            Annotates an out DirectionExpression if the out variable can be declared implicitly typed.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CallBuilder.BuildCollectionInitializerExpression(ICSharpCode.Decompiler.IL.OpCode,ICSharpCode.Decompiler.TypeSystem.IMethod,ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.IL.ILInstruction})">
            <summary>
            Converts a call to an Add method to a collection initializer expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectFileWriter">
            <summary>
            An interface for a service that creates and writes a project file structure
            for a specific module being decompiled.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectFileWriter.Write(System.IO.TextWriter,ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider,System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.String}},ICSharpCode.Decompiler.Metadata.PEFile)">
            <summary>
            Writes the content of a new project file for the specified <paramref name="module"/> being decompiled.
            </summary>
            <param name="target">The target to write to.</param>
            <param name="project">The information about the project being created.</param>
            <param name="files">A collection of source files to be included into the project, each item is a pair
            of the project entry type and the file path.</param>
            <param name="module">The module being decompiled.</param>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider">
            <summary>
            An interface that provides common information for a project being decompiled to.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider.AssemblyResolver">
            <summary>
            Gets the assembly resolver active for the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider.LanguageVersion">
            <summary>
            Gets the C# language version of the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider.ProjectGuid">
            <summary>
            Gets the unique ID of the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider.StrongNameKeyFile">
            <summary>
            Gets the name of the key file being used for strong name signing. Can be null if no file is available.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle">
            <summary>
            A <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectFileWriter"/> implementation that creates the projects in the SDK style format.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle.Create">
            <summary>
            Creates a new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle"/> class.
            </summary>
            <returns>A new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle"/> class.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle.Write(System.IO.TextWriter,ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider,System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.String}},ICSharpCode.Decompiler.Metadata.PEFile)">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault">
            <summary>
            A <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectFileWriter"/> implementation that creates the projects in the default format.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault.Create">
            <summary>
            Creates a new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault"/> class.
            </summary>
            <returns>A new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault"/> class.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault.Write(System.IO.TextWriter,ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider,System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.String}},ICSharpCode.Decompiler.Metadata.PEFile)">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework">
            <summary>
            A class describing the target framework of a module.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework"/> class.
            </summary>
            <param name="identifier">The framework identifier string. Can be null.</param>
            <param name="version">The framework version string. Must be greater than 100 (where 100 corresponds to v1.0).</param>
            <param name="profile">The framework profile. Can be null.</param>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.Identifier">
            <summary>
            Gets the target framework identifier. Can be null if not defined.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.Moniker">
            <summary>
            Gets the target framework moniker. Can be null if not supported.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.VersionString">
            <summary>
            Gets the target framework version, e.g. "v4.5".
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.VersionNumber">
            <summary>
            Gets the target framework version as integer (multiplied by 100), e.g. 450.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.Profile">
            <summary>
            Gets the target framework profile. Can be null if not set or not available.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework.IsPortableClassLibrary">
            <summary>
            Gets a value indicating whether the target is a portable class library (PCL).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetServices">
            <summary>
            Helper services for determining the target framework and platform of a module.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetServices.DetectTargetFramework(ICSharpCode.Decompiler.Metadata.PEFile)">
            <summary>
            Gets the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework"/> for the specified <paramref name="module"/>.
            </summary>
            <param name="module">The module to get the target framework description for. Cannot be null.</param>
            <returns>A new instance of the <see cref="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework"/> class that describes the specified <paramref name="module"/>.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetServices.GetPlatformName(ICSharpCode.Decompiler.Metadata.PEFile)">
            <summary>
            Gets the string representation (name) of the target platform of the specified <paramref name="module"/>.
            </summary>
            <param name="module">The module to get the target framework description for. Cannot be null.</param>
            <returns>The platform name, e.g. "AnyCPU" or "x86".</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler">
            <summary>
            Decompiles an assembly into a visual studio project file.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler.Settings">
            <summary>
            Gets the setting this instance uses for decompiling.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler.ProjectGuid">
            <summary>
            The MSBuild ProjectGuid to use for the new project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler.StrongNameKeyFile">
            <summary>
            Path to the snk file to use for signing.
            <c>null</c> to not sign.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler.targetDirectory">
            <summary>
            The target directory that the decompiled files are written to.
            </summary>
            <remarks>
            This field is set by DecompileProject() and protected so that overridden protected members
            can access it.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler.CleanUpFileName(System.String)">
            <summary>
            Cleans up a node name for use as a file name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.GenericGrammarAmbiguityVisitor">
            <summary>
            Used to test for the "F(G&lt;A,B&gt;(7));" grammar ambiguity.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.GenericGrammarAmbiguityVisitor.ResolveAmbiguities(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Resolves ambiguities in the specified syntax tree.
            This method must be called after the InsertParenthesesVisitor, because the ambiguity depends on whether the
            final `>` in the possible-type-argument is followed by an opening parenthesis.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpAmbience">
            <summary>
            C# ambience. Used to convert type system symbols to text (usually for displaying the symbol to the user; e.g. in editor tooltips)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor">
            <summary>
            Outputs the AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.Comma(ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Boolean)">
            <summary>
            Writes a comma.
            </summary>
            <param name="nextNode">The next node after the comma.</param>
            <param name="noSpaceAfterComma">When set prevents printing a space after comma.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.OptionalComma(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Writes an optional comma, e.g. at the end of an enum declaration or in an array initializer
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.OptionalSemicolon(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Writes an optional semicolon, e.g. at the end of a type or namespace declaration.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.WriteKeyword(ICSharpCode.Decompiler.CSharp.Syntax.TokenRole)">
            <summary>
            Writes a keyword, and all specials up to
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.Semicolon">
            <summary>
            Marks the end of a statement
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.Space(System.Boolean)">
            <summary>
            Writes a space depending on policy.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.IsKeyword(System.String,ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Determines whether the specified identifier is a keyword in the given context.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.WriteEmbeddedStatement(ICSharpCode.Decompiler.CSharp.Syntax.Statement,ICSharpCode.Decompiler.CSharp.OutputVisitor.NewLinePlacement)">
            <summary>
            Writes an embedded statement.
            </summary>
            <param name="embeddedStatement">The statement to write.</param>
            <param name="nlp">Determines whether a trailing newline should be written following a block.
            Non-blocks always write a trailing newline.</param>
            <remarks>
            Blocks may or may not write a leading newline depending on StatementBraceStyle.
            Non-blocks always write a leading newline.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.WriteBlock(ICSharpCode.Decompiler.CSharp.Syntax.BlockStatement,ICSharpCode.Decompiler.CSharp.OutputVisitor.BraceStyle)">
            <summary>
            Writes a block statement.
            Similar to VisitBlockStatement() except that:
            1) it allows customizing the BraceStyle
            2) it does not write a trailing newline after the '}' (this job is left to the caller)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor.ConvertString(System.String)">
            <summary>
            Converts special characters to escape sequences within the given string.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory">
            <summary>
            The formatting options factory creates pre defined formatting option styles.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateEmpty">
            <summary>
            Creates empty CSharpFormatting options.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateMono">
            <summary>
            Creates mono indent style CSharpFormatting options.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateSharpDevelop">
            <summary>
            Creates sharp develop indent style CSharpFormatting options.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateKRStyle">
            <summary>
            The K&amp;R style, so named because it was used in Kernighan and Ritchie's book The C Programming Language,
            is commonly used in C. It is less common for C++, C#, and others.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateAllman">
            <summary>
            Creates allman indent style CSharpFormatting options used in Visual Studio.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateWhitesmiths">
            <summary>
            The Whitesmiths style, also called Wishart style to a lesser extent, is less common today than the previous three. It was originally used in the documentation for the first commercial C compiler, the Whitesmiths Compiler.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory.CreateGNU">
            <summary>
            Like the Allman and Whitesmiths styles, GNU style puts braces on a line by themselves, indented by 2 spaces,
            except when opening a function definition, where they are not indented.
            In either case, the contained code is indented by 2 spaces from the braces.
            Popularised by Richard Stallman, the layout may be influenced by his background of writing Lisp code.
            In Lisp the equivalent to a block (a progn) 
            is a first class data entity and giving it its own indent level helps to emphasize that,
            whereas in C a block is just syntax.
            Although not directly related to indentation, GNU coding style also includes a space before the bracketed 
            list of arguments to a function.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor">
            <summary>
            Inserts the parentheses into the AST that are needed to ensure the AST can be printed correctly.
            For example, if the AST contains
            BinaryOperatorExpresson(2, Mul, BinaryOperatorExpression(1, Add, 1))); printing that AST
            would incorrectly result in "2 * 1 + 1". By running InsertParenthesesVisitor, the necessary
            parentheses are inserted: "2 * (1 + 1)".
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor.InsertParenthesesForReadability">
            <summary>
            Gets/Sets whether the visitor should insert parentheses to make the code better looking.
            If this property is false, it will insert parentheses only where strictly required by the language spec.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor.GetPrecedence(ICSharpCode.Decompiler.CSharp.Syntax.Expression)">
            <summary>
            Gets the row number in the C# 4.0 spec operator precedence table.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor.ParenthesizeIfRequired(ICSharpCode.Decompiler.CSharp.Syntax.Expression,ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor.PrecedenceLevel)">
            <summary>
            Parenthesizes the expression if it does not have the minimum required precedence.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertRequiredSpacesDecorator.lastWritten">
            <summary>
            Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertSpecialsDecorator.WriteSpecials(ICSharpCode.Decompiler.CSharp.Syntax.AstNode,ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Writes all specials from start to end (exclusive). Does not touch the positionStack.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertSpecialsDecorator.WriteSpecialsUpToRole(ICSharpCode.Decompiler.CSharp.Syntax.Role)">
            <summary>
            Writes all specials between the current position (in the positionStack) and the next
            node with the specified role. Advances the current position.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertSpecialsDecorator.WriteSpecialsUpToNode(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Writes all specials between the current position (in the positionStack) and the specified node.
            Advances the current position.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter.WriteIdentifier(ICSharpCode.Decompiler.CSharp.Syntax.Identifier)">
            <summary>
            Writes an identifier.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter.WriteKeyword(ICSharpCode.Decompiler.CSharp.Syntax.Role,System.String)">
            <summary>
            Writes a keyword to the output.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter.WriteToken(ICSharpCode.Decompiler.CSharp.Syntax.Role,System.String)">
            <summary>
            Writes a token to the output.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter.WritePrimitiveValue(System.Object,ICSharpCode.Decompiler.CSharp.Syntax.LiteralFormat)">
            <summary>
            Writes a primitive/literal value
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter.WriteInterpolatedText(System.String)">
            <summary>
            Write a piece of text in an interpolated string literal.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.OutputVisitor.TextWriterTokenWriter">
            <summary>
            Writes C# code into a TextWriter.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TextWriterTokenWriter.ConvertCharLiteral(System.Char)">
            <summary>
            Gets the escape sequence for the specified character within a char literal.
            Does not include the single quotes surrounding the char literal.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TextWriterTokenWriter.ConvertChar(System.Char)">
            <summary>
            Gets the escape sequence for the specified character.
            </summary>
            <remarks>This method does not convert ' or ".</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.OutputVisitor.TextWriterTokenWriter.ConvertString(System.String)">
            <summary>
            Converts special characters to escape sequences within the given string.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.SequencePointBuilder">
            <summary>
            Given a SyntaxTree that was output from the decompiler, constructs the list of sequence points.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.StatePerSequencePoint.PrimaryNode">
            <summary>
            Main AST node associated with this sequence point.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.StatePerSequencePoint.Intervals">
            <summary>
            List of IL intervals that are associated with this sequence point.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.StatePerSequencePoint.Function">
            <summary>
            The function containing this sequence point.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.StartSequencePoint(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Start a new C# statement = new sequence point.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.AddToSequencePoint(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Add the ILAst instruction associated with the AstNode to the sequence point.
            Also add all its ILAst sub-instructions (unless they were already added to another sequence point).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.SequencePointBuilder.GetSequencePoints">
            <summary>
            Called after the visitor is done to return the results.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DeclarationExpression">
            <summary>
            TypeName VariableDesignation
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SwitchExpression">
            <summary>
            Expression switch { SwitchSections }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SwitchExpressionSection">
            <summary>
            Pattern => Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SingleVariableDesignation">
            <summary>
            Identifier
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedVariableDesignation">
            <summary>
            ( VariableDesignation (, VariableDesignation)* )
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Ancestors">
            <summary>
            Gets the ancestors of this node (excluding this node itself)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.AncestorsAndSelf">
            <summary>
            Gets the ancestors of this node (including this node itself)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Descendants">
            <summary>
            Gets all descendants of this node (excluding this node itself) in pre-order.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.DescendantsAndSelf">
            <summary>
            Gets all descendants of this node (including this node itself) in pre-order.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetChildByRole``1(ICSharpCode.Decompiler.CSharp.Syntax.Role{``0})">
            <summary>
            Gets the first child with the specified role.
            Returns the role's null object if the child is not found.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.AddChildUnsafe(ICSharpCode.Decompiler.CSharp.Syntax.AstNode,ICSharpCode.Decompiler.CSharp.Syntax.Role)">
            <summary>
            Adds a child without performing any safety checks.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Remove">
            <summary>
            Removes this node from its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.ReplaceWith(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Replaces this node with the new node.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Clone">
            <summary>
            Clones the whole subtree starting at this AST node.
            </summary>
            <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNextNode(System.Func{ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Boolean})">
            <summary>
            Gets the next node which fullfills a given predicate
            </summary>
            <returns>The next node.</returns>
            <param name="pred">The predicate.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetPrevNode(System.Func{ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Boolean})">
            <summary>
            Gets the previous node which fullfills a given predicate
            </summary>
            <returns>The next node.</returns>
            <param name="pred">The predicate.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNextSibling(System.Func{ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Boolean})">
            <summary>
            Gets the next sibling which fullfills a given predicate
            </summary>
            <returns>The next node.</returns>
            <param name="pred">The predicate.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetPrevSibling(System.Func{ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Boolean})">
            <summary>
            Gets the next sibling which fullfills a given predicate
            </summary>
            <returns>The next node.</returns>
            <param name="pred">The predicate.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodeAt(System.Int32,System.Int32,System.Predicate{ICSharpCode.Decompiler.CSharp.Syntax.AstNode})">
            <summary>
            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End exclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodeAt(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,System.Predicate{ICSharpCode.Decompiler.CSharp.Syntax.AstNode})">
            <summary>
            Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End exclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodeAt``1(System.Int32,System.Int32)">
            <summary>
            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End exclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodeAt``1(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End exclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetAdjacentNodeAt(System.Int32,System.Int32,System.Predicate{ICSharpCode.Decompiler.CSharp.Syntax.AstNode})">
            <summary>
            Gets the node specified by pred at the location line, column. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End inclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetAdjacentNodeAt(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,System.Predicate{ICSharpCode.Decompiler.CSharp.Syntax.AstNode})">
            <summary>
            Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End inclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetAdjacentNodeAt``1(System.Int32,System.Int32)">
            <summary>
            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End inclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetAdjacentNodeAt``1(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
            the current method declaration.
            (End inclusive)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodeContaining(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Gets the node that fully contains the range from startLocation to endLocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodesBetween(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the root nodes of all subtrees that are fully contained in the specified region.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.GetNodesBetween(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Returns the root nodes of all subtrees that are fully contained between <paramref name="start"/> and <paramref name="end"/> (inclusive).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.ToString(ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpFormattingOptions)">
            <summary>
            Gets the node as formatted C# output.
            </summary>
            <param name='formattingOptions'>
            Formatting options.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true, if the given coordinates (line, column) are in the node.
            </summary>
            <returns>
            True, if the given coordinates are between StartLocation and EndLocation (exclusive); otherwise, false.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.Contains(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Returns true, if the given coordinates are in the node.
            </summary>
            <returns>
            True, if location is between StartLocation and EndLocation (exclusive); otherwise, false.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.IsInside(System.Int32,System.Int32)">
            <summary>
            Returns true, if the given coordinates (line, column) are in the node.
            </summary>
            <returns>
            True, if the given coordinates are between StartLocation and EndLocation (inclusive); otherwise, false.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNode.IsInside(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Returns true, if the given coordinates are in the node.
            </summary>
            <returns>
            True, if location is between StartLocation and EndLocation (inclusive); otherwise, false.
            </returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1">
            <summary>
            Represents the children of an AstNode that have a specific role.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1.FirstOrNullObject(System.Func{`0,System.Boolean})">
            <summary>
            Returns the first element for which the predicate returns true,
            or the null node (AstNode with IsNull=true) if no such object is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1.LastOrNullObject(System.Func{`0,System.Boolean})">
            <summary>
            Returns the last element for which the predicate returns true,
            or the null node (AstNode with IsNull=true) if no such object is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1.AcceptVisitor(ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor)">
            <summary>
            Applies the <paramref name="visitor"/> to all nodes in this collection.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AstType">
            <summary>
            A type reference in the C# AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.IsVar">
            <summary>
            Gets whether this type is a SimpleType "var".
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.ToTypeReference(ICSharpCode.Decompiler.TypeSystem.InterningProvider)">
            <summary>
            Create an ITypeReference for this AstType.
            Uses the context (ancestors of this node) to determine the correct <see cref="T:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode"/>.
            </summary>
            <remarks>
            The resulting type reference will read the context information from the
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext"/>:
            For resolving type parameters, the CurrentTypeDefinition/CurrentMember is used.
            For resolving simple names, the current namespace and usings from the CurrentUsingScope
            (on CSharpTypeResolveContext only) is used.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.ToTypeReference(ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode,ICSharpCode.Decompiler.TypeSystem.InterningProvider)">
            <summary>
            Create an ITypeReference for this AstType.
            </summary>
            <remarks>
            The resulting type reference will read the context information from the
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext"/>:
            For resolving type parameters, the CurrentTypeDefinition/CurrentMember is used.
            For resolving simple names, the current namespace and usings from the CurrentUsingScope
            (on CSharpTypeResolveContext only) is used.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.GetNameLookupMode">
            <summary>
            Gets the name lookup mode from the context (looking at the ancestors of this <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.AstType"/>).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MakePointerType">
            <summary>
            Creates a pointer type from this type by nesting it in a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType"/>.
            If this type already is a pointer type, this method just increases the PointerRank of the existing pointer type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MakeArrayType(System.Int32)">
            <summary>
            Creates an array type from this type by nesting it in a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType"/>.
            If this type already is an array type, the additional rank is prepended to the existing array specifier list.
            Thus, <c>new SimpleType("T").MakeArrayType(1).MakeArrayType(2)</c> will result in "T[,][]".
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MakeNullableType">
            <summary>
            Creates a nullable type from this type by nesting it in a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MakeRefType">
            <summary>
            Creates a C# 7 ref type from this type by nesting it in a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MemberType(System.String,ICSharpCode.Decompiler.CSharp.Syntax.AstType[])">
            <summary>
            Builds an expression that can be used to access a static member on this type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.MemberType(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.CSharp.Syntax.AstType})">
            <summary>
            Builds an expression that can be used to access a static member on this type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AstType.Create(System.String)">
            <summary>
            Creates a simple AstType from a dotted name.
            Does not support generics, arrays, etc. - just simple dotted names,
            e.g. namespace names.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType.HasRefSpecifier">
            <summary>
            Gets/sets whether this type has a 'ref' specifier.
            This is used for C# 7 ref locals/ref return.
            Parameters use ParameterDeclaration.ParameterModifier instead.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.ComposedType.HasReadOnlySpecifier">
            <summary>
            Gets/sets whether this type has a 'readonly' specifier.
            This is used for C# 7.2 'ref readonly' locals/ref return.
            Parameters use ParameterDeclaration.ParameterModifier instead.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ArraySpecifier">
            <summary>
            [,,,]
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.CSharpTokenNode">
            <summary>
            Represents a token in C#. Note that the type of the token is defined through the TokenRole.
            </summary>
            <remarks>
            In all non null c# token nodes the Role of a CSharpToken must be a TokenRole.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.CSharpUtil.InvertCondition(ICSharpCode.Decompiler.CSharp.Syntax.Expression)">
            <summary>
            Inverts a boolean condition. Note: The condition object can be frozen (from AST) it's cloned internally.
            </summary>
            <param name="condition">The condition to invert.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.CSharpUtil.AddParensForUnaryExpressionIfRequired(ICSharpCode.Decompiler.CSharp.Syntax.Expression)">
            <summary>
            When negating an expression this is required, otherwise you would end up with
            a or b -> !a or b
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.CSharpUtil.NegateRelationalOperator(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType)">
            <summary>
            Get negation of the specified relational operator
            </summary>
            <returns>
            negation of the specified relational operator, or BinaryOperatorType.Any if it's not a relational operator
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.CSharpUtil.IsRelationalOperator(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType)">
            <summary>
            Returns true, if the specified operator is a relational operator
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.CSharpUtil.NegateConditionOperator(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType)">
            <summary>
            Get negation of the condition operator
            </summary>
            <returns>
            negation of the specified condition operator, or BinaryOperatorType.Any if it's not a condition operator
            </returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor">
            <summary>
            AST visitor with a default implementation that visits all node depth-first.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor`1">
            <summary>
            AST visitor with a default implementation that visits all node depth-first.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor`2">
            <summary>
            AST visitor with a default implementation that visits all node depth-first.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference">
            <summary>
            Represents a 'cref' reference in XML documentation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.SymbolKind">
            <summary>
            Gets/Sets the entity type.
            Possible values are:
              <c>SymbolKind.Operator</c> for operators,
              <c>SymbolKind.Indexer</c> for indexers,
              <c>SymbolKind.TypeDefinition</c> for references to primitive types,
              and <c>SymbolKind.None</c> for everything else.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.OperatorType">
            <summary>
            Gets/Sets the operator type.
            This property is only used when SymbolKind==Operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.HasParameterList">
            <summary>
            Gets/Sets whether a parameter list was provided.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.DeclaringType">
            <summary>
            Gets/Sets the declaring type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.MemberName">
            <summary>
            Gets/sets the member name.
            This property is only used when SymbolKind==None.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference.ConversionOperatorReturnType">
            <summary>
            Gets/Sets the return type of conversion operators.
            This property is only used when SymbolKind==Operator and OperatorType is explicit or implicit.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AnonymousMethodExpression">
            <summary>
            [async] delegate(Parameters) {Body}
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AnonymousTypeCreateExpression">
            <summary>
            new { [ExpressionList] }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ArrayCreateExpression">
            <summary>
            new Type[Dimensions]
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.ArrayCreateExpression.AdditionalArraySpecifiers">
            <summary>
            Gets additional array ranks (those without size info).
            Empty for "new int[5,1]"; will contain a single element for "new int[5][]".
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ArrayInitializerExpression">
            <summary>
            { Elements }
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.ArrayInitializerExpression.IsSingleElement">
            <summary>
            For ease of use purposes in the resolver the ast representation
            of { a, b, c }  is { {a}, {b}, {c} }.
            If IsSingleElement is true then this array initializer expression is a generated one.
            That has no meaning in the source code (and contains no brace tokens).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ArrayInitializerExpression.SingleArrayInitializerExpression">
            <summary>
            Single elements in array initializers are represented with this special class.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AsExpression">
            <summary>
            Expression as TypeReference
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentExpression">
            <summary>
            Left Operator= Right
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentExpression.GetCorrespondingBinaryOperator(ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType)">
            <summary>
            Gets the binary operator for the specified compound assignment operator.
            Returns null if 'op' is not a compound assignment.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Assign">
            <summary>left = right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Add">
            <summary>left += right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Subtract">
            <summary>left -= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Multiply">
            <summary>left *= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Divide">
            <summary>left /= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Modulus">
            <summary>left %= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.ShiftLeft">
            <summary>left &lt;&lt;= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.ShiftRight">
            <summary>left >>= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.BitwiseAnd">
            <summary>left &amp;= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.BitwiseOr">
            <summary>left |= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.ExclusiveOr">
            <summary>left ^= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType.Any">
            <summary>Any operator (for pattern matching)</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.BaseReferenceExpression">
            <summary>
            base
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorExpression">
            <summary>
            Left Operator Right
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Any">
            <summary>
            Any binary operator (used in pattern matching)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.BitwiseAnd">
            <summary>left &amp; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.BitwiseOr">
            <summary>left | right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.ConditionalAnd">
            <summary>left &amp;&amp; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.ConditionalOr">
            <summary>left || right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.ExclusiveOr">
            <summary>left ^ right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.GreaterThan">
            <summary>left &gt; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.GreaterThanOrEqual">
            <summary>left &gt;= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Equality">
            <summary>left == right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.InEquality">
            <summary>left != right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.LessThan">
            <summary>left &lt; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.LessThanOrEqual">
            <summary>left &lt;= right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Add">
            <summary>left + right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Subtract">
            <summary>left - right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Multiply">
            <summary>left * right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Divide">
            <summary>left / right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Modulus">
            <summary>left % right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.ShiftLeft">
            <summary>left &lt;&lt; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.ShiftRight">
            <summary>left &gt;&gt; right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.NullCoalescing">
            <summary>left ?? right</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType.Range">
            <summary>left .. right</summary>
            <remarks>left and right are optional = may be Expression.Null</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.CastExpression">
            <summary>
            (CastTo)Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.CheckedExpression">
            <summary>
            checked(Expression)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ConditionalExpression">
            <summary>
            Condition ? TrueExpression : FalseExpression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DefaultValueExpression">
            <summary>
            default(Type)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DirectionExpression">
            <summary>
            ref Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Expression">
            <summary>
            Base class for expressions.
            </summary>
            <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be an expression"
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IndexerExpression">
            <summary>
            Target[Arguments]
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Interpolation">
            <summary>
            { Expression }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.InvocationExpression">
            <summary>
            Target(Arguments)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IsExpression">
            <summary>
            Expression is Type
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.LambdaExpression">
            <summary>
            [async] Parameters => Body
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.MemberReferenceExpression">
            <summary>
            Target.MemberName
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.NamedArgumentExpression">
            <summary>
            Represents a named argument passed to a method or attribute.
            name: expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.NamedExpression">
            <summary>
            name = expression
            This isn't the same as 'assign' even though it has the same syntax.
            This expression is used in object initializers and for named attribute arguments [Attr(FieldName = value)].
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.NullReferenceExpression">
            <summary>
            null
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ObjectCreateExpression">
            <summary>
            new Type(Arguments) { Initializer }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.OutVarDeclarationExpression">
            <summary>
            out type expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedExpression">
            <summary>
            ( Expression )
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedExpression.ActsAsParenthesizedExpression(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Gets whether the expression acts like a parenthesized expression,
            i.e. whether information about the expected type (for lambda type inference) flows
            into the inner expression.
            </summary>
            <returns>Returns true for ParenthesizedExpression, CheckedExpression or UncheckedExpression; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedExpression.UnpackParenthesizedExpression(ICSharpCode.Decompiler.CSharp.Syntax.Expression)">
            <summary>
            Unpacks the given expression if it is a ParenthesizedExpression, CheckedExpression or UncheckedExpression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PointerReferenceExpression">
            <summary>
            Target->MemberName
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.LiteralFormat">
            <summary>
            Form of a C# literal.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PrimitiveExpression">
            <summary>
            Represents a literal value.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.QueryContinuationClause">
            <summary>
            Represents a query continuation.
            "(from .. select ..) into Identifier" or "(from .. group .. by ..) into Identifier"
            Note that "join .. into .." is not a query continuation!
            
            This is always the first(!!) clause in a query expression.
            The tree for "from a in b select c into d select e" looks like this:
            new QueryExpression {
            	new QueryContinuationClause {
            		PrecedingQuery = new QueryExpression {
            			new QueryFromClause(a in b),
            			new QuerySelectClause(c)
            		},
            		Identifier = d
            	},
            	new QuerySelectClause(e)
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.QueryJoinClause">
            <summary>
            Represents a join or group join clause.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SizeOfExpression">
            <summary>
            sizeof(Type)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.StackAllocExpression">
            <summary>
            stackalloc Type[Count]
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ThisReferenceExpression">
            <summary>
            this
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ThrowExpression">
            <summary>
            throw Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeOfExpression">
            <summary>
            typeof(Type)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeReferenceExpression">
            <summary>
            Represents an AstType as an expression.
            This is used when calling a method on a primitive type: "int.Parse()"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorExpression">
            <summary>
            Operator Expression
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Any">
            <summary>
            Any unary operator (used in pattern matching)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Not">
            <summary>Logical not (!a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.BitNot">
            <summary>Bitwise not (~a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Minus">
            <summary>Unary minus (-a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Plus">
            <summary>Unary plus (+a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Increment">
            <summary>Pre increment (++a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Decrement">
            <summary>Pre decrement (--a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.PostIncrement">
            <summary>Post increment (a++)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.PostDecrement">
            <summary>Post decrement (a--)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Dereference">
            <summary>Dereferencing (*a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.AddressOf">
            <summary>Get address (&amp;a)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.Await">
            <summary>C# 5.0 await</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.NullConditional">
            <summary>C# 6 null-conditional operator.
            Occurs as target of member reference or indexer expressions
            to indicate <c>?.</c> or <c>?[]</c>.
            Corresponds to <c>nullable.unwrap</c> in ILAst.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.NullConditionalRewrap">
            <summary>
            Wrapper around a primary expression containing a null conditional operator.
            Corresponds to <c>nullable.rewrap</c> in ILAst.
            This has no syntax in C#, but the node is used to ensure parentheses are inserted where necessary.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.IsTrue">
            <summary>
            Implicit call of "operator true".
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.SuppressNullableWarning">
            <summary>
            C# 8 postfix ! operator (dammit operator)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType.IndexFromEnd">
            <summary>
            C# 8 prefix ^ operator
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UncheckedExpression">
            <summary>
            unchecked(Expression)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UndocumentedExpression">
            <summary>
            Represents undocumented expressions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Attribute">
            <summary>
            Attribute(Arguments)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AttributeSection">
            <summary>
            [AttributeTarget: Attributes]
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.CommentType.SingleLine">
            <summary>
            "//" comment
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.CommentType.MultiLine">
            <summary>
            "/* */" comment
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.CommentType.Documentation">
            <summary>
            "///" comment
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.CommentType.InactiveCode">
            <summary>
            Inactive code (code in non-taken "#if")
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.CommentType.MultiLineDocumentation">
            <summary>
            "/** */" comment
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.Comment.IsDocumentation">
            <summary>
            Returns true if the <see cref="P:ICSharpCode.Decompiler.CSharp.Syntax.Comment.CommentType"/> is Documentation or MultiLineDocumentation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Constraint">
            <summary>
            where TypeParameter : BaseTypes
            </summary>
            <remarks>
            new(), struct and class constraints are represented using a PrimitiveType "new", "struct" or "class"
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DelegateDeclaration">
            <summary>
            delegate ReturnType Name&lt;TypeParameters&gt;(Parameters) where Constraints;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ExternAliasDeclaration">
            <summary>
            extern alias IDENTIFIER;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.NamespaceDeclaration">
            <summary>
            namespace Name { Members }
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.NamespaceDeclaration.FullName">
            <summary>
            Gets the full namespace name (including any parent namespaces)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.PreProcessorDirective.Take">
            <summary>
            For an '#if' directive, specifies whether the condition evaluated to true.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeDeclaration">
            <summary>
            class Name&lt;TypeParameters&gt; : BaseTypes where Constraints;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeParameterDeclaration">
            <summary>
            [in|out] Name
            
            Represents a type parameter.
            Note: mirroring the C# syntax, constraints are not part of the type parameter declaration, but belong
            to the parent type or method.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UsingAliasDeclaration">
            <summary>
            using Alias = Import;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UsingDeclaration">
            <summary>
            using Import;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor">
            <summary>
            AST visitor.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor`1">
            <summary>
            AST visitor.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor`2">
            <summary>
            AST visitor.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IdentifierExpressionBackreference">
            <summary>
            Matches identifier expressions that have the same identifier as the referenced variable/type definition/method definition.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.Modifiers.Any">
            <summary>
            Special value used to match any modifiers during pattern matching.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.NodeType.TypeReference">
            <summary>
            AstType
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.NodeType.TypeDeclaration">
            <summary>
            Type or delegate declaration
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.NodeType.Whitespace">
            <summary>
            Comment or whitespace or pre-processor directive 
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.NodeType.Pattern">
            <summary>
            Placeholder for a pattern
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.AnyNode">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.AnyNodeOrNull">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Backreference">
            <summary>
            Matches the last entry in the specified named group.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.BacktrackingInfo">
            <summary>
            Container for the backtracking info.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Choice">
            <summary>
            Matches one of several alternatives.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode">
            <summary>
            AST node that supports pattern matching.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.PatternExtensions.Match(ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode,ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode)">
            <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other"/> is the AST that is being matched.
            </summary>
            <returns>
            A match object. Check <see cref="P:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Match.Success"/> to see whether the match was successful.
            </returns>
            <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Match">
            <summary>
            Represents the result of a pattern matching operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.NamedNode">
            <summary>
            Represents a named node within a pattern.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Pattern">
            <summary>
            Base class for all patterns.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Pattern.AnyString">
            <summary>
            Gets the string that matches any string.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Repeat">
            <summary>
            Represents an optional node.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Role">
            <summary>
            Represents the role a node plays within its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.Role.IsValid(System.Object)">
            <summary>
            Gets whether the specified node is valid in this role.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.Role.GetByIndex(System.UInt32)">
            <summary>
            Gets the role with the specified index.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Role`1">
            <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.Role`1.NullObject">
            <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
            <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, if a role used for collections only, it may leave out the null object.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.BlockStatement">
            <summary>
            { Statements }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.BreakStatement">
            <summary>
            break;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.CheckedStatement">
            <summary>
            checked BodyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ContinueStatement">
            <summary>
            continue;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.DoWhileStatement">
            <summary>
            "do EmbeddedStatement while(Condition);"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.EmptyStatement">
            <summary>
            ;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ExpressionStatement">
            <summary>
            Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.FixedStatement">
            <summary>
            fixed (Type Variables) EmbeddedStatement
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement">
            <summary>
            foreach (Type VariableName in InExpression) EmbeddedStatement
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ForStatement">
            <summary>
            for (Initializers; Condition; Iterators) EmbeddedStatement
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.ForStatement.Initializers">
            <summary>
            Gets the list of initializer statements.
            Note: this contains multiple statements for "for (a = 2, b = 1; a > b; a--)", but contains
            only a single statement for "for (int a = 2, b = 1; a > b; a--)" (a single VariableDeclarationStatement with two variables)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.GotoStatement">
            <summary>
            "goto Label;"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.GotoCaseStatement">
            <summary>
            or "goto case LabelExpression;"
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.GotoCaseStatement.LabelExpression">
            <summary>
            Used for "goto case LabelExpression;"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.GotoDefaultStatement">
            <summary>
            or "goto default;"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IfElseStatement">
            <summary>
            if (Condition) TrueStatement else FalseStatement
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.LabelStatement">
            <summary>
            Label:
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.LockStatement">
            <summary>
            lock (Expression) EmbeddedStatement;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ReturnStatement">
            <summary>
            return Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Statement">
            <summary>
            Base class for statements.
            </summary>
            <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be a statement"
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SwitchStatement">
            <summary>
            switch (Expression) { SwitchSections }
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.CaseLabel.Expression">
            <summary>
            Gets or sets the expression. The expression can be null - if the expression is null, it's the default switch section.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.ThrowStatement">
            <summary>
            throw Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TryCatchStatement">
            <summary>
            try TryBlock CatchClauses finally FinallyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.CatchClause">
            <summary>
            catch (Type VariableName) { Body }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UncheckedStatement">
            <summary>
            unchecked BodyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UnsafeStatement">
            <summary>
            unsafe { Body }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.UsingStatement">
            <summary>
            [ await ] using (ResourceAcquisition) EmbeddedStatement
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.UsingStatement.ResourceAcquisition">
            <summary>
            Either a VariableDeclarationStatement, or an Expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.WhileStatement">
            <summary>
            "while (Condition) EmbeddedStatement"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.YieldBreakStatement">
            <summary>
            yield break;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.YieldReturnStatement">
            <summary>
            yield return Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxExtensions">
            <summary>
            Extension methods for the syntax tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxExtensions.IsBitwise(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType)">
            <summary>
            Returns true if <paramref name="operatorType"/> is bitwise and, bitwise or, or exclusive or.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree.FileName">
            <summary>
            Gets/Sets the file name of this syntax tree.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree.ConditionalSymbols">
            <summary>
            Gets the conditional symbols used to parse the source file. Note that this list contains
            the conditional symbols at the start of the first token in the file - including the ones defined
            in the source file.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree.TopExpression">
            <summary>
            Gets the expression that was on top of the parse stack.
            This is the only way to get an expression that isn't part of a statment.
            (eg. when an error follows an expression).
            
            This is used for code completion to 'get the expression before a token - like ., &lt;, ('.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree.GetTypes(System.Boolean)">
            <summary>
            Gets all defined types in this syntax tree.
            </summary>
            <returns>
            A list containing <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeDeclaration"/> or <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.DelegateDeclaration"/> nodes.
            </returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation">
            <summary>
            A line/column position.
            Text editor lines/columns are counted started from one.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.Empty">
            <summary>
            Represents no text location (0, 0).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.MinLine">
            <summary>
            Constant of the minimum line.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.MinColumn">
            <summary>
            Constant of the minimum column.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextLocation instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.Line">
            <summary>
            Gets the line number.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.Column">
            <summary>
            Gets the column number.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.IsEmpty">
            <summary>
            Gets whether the TextLocation instance is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.ToString">
            <summary>
            Gets a string representation for debugging purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.GetHashCode">
            <summary>
            Gets a hash code.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.Equals(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_Equality(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_Inequality(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Inequality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_LessThan(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_GreaterThan(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_LessThanOrEqual(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.op_GreaterThanOrEqual(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation,ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TextLocation.CompareTo(ICSharpCode.Decompiler.CSharp.Syntax.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TokenRole">
            <summary>
            A specific role only used for C# tokens
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TokenRole.Token">
            <summary>
            Gets the token as string. Note that the token Name and Token value may differ.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TokenRole.Length">
            <summary>
            Gets the char length of the token.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.Accessor">
            <summary>
            get/set/add/remove
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.Accessor.Keyword">
            <summary>
            Gets the 'get'/'set'/'init'/'add'/'remove' keyword
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.CustomEventDeclaration.PrivateImplementationType">
            <summary>
            Gets/Sets the type reference of the interface that is explicitly implemented.
            Null node if this member is not an explicit interface implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.FixedVariableInitializer">
            <summary>
            Name [ CountExpression ]
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.IndexerDeclaration.PrivateImplementationType">
            <summary>
            Gets/Sets the type reference of the interface that is explicitly implemented.
            Null node if this member is not an explicit interface implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.MethodDeclaration.PrivateImplementationType">
            <summary>
            Gets/Sets the type reference of the interface that is explicitly implemented.
            Null node if this member is not an explicit interface implementation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.OperatorDeclaration.GetOperatorType(System.String)">
            <summary>
            Gets the operator type from the method name, or null, if the method does not represent one of the known operator types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.OperatorDeclaration.GetName(System.Nullable{ICSharpCode.Decompiler.CSharp.Syntax.OperatorType})">
            <summary>
            Gets the method name for the operator type. ("op_Addition", "op_Implicit", etc.)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.OperatorDeclaration.GetToken(ICSharpCode.Decompiler.CSharp.Syntax.OperatorType)">
            <summary>
            Gets the token for the operator type ("+", "implicit", etc.)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.PropertyDeclaration.PrivateImplementationType">
            <summary>
            Gets/Sets the type reference of the interface that is explicitly implemented.
            Null node if this member is not an explicit interface implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder">
            <summary>
            Converts from type system to the C# AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.#ctor(ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver)">
            <summary>
            Creates a new TypeSystemAstBuilder.
            </summary>
            <param name="resolver">
            A resolver initialized for the position where the type will be inserted.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.#ctor">
            <summary>
            Creates a new TypeSystemAstBuilder.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.AddTypeReferenceAnnotations">
            <summary>
            Specifies whether the ast builder should add annotations to type references.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.AddResolveResultAnnotations">
            <summary>
            Specifies whether the ast builder should add ResolveResult annotations to AST nodes.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowAccessibility">
            <summary>
            Controls the accessibility modifiers are shown.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowModifiers">
            <summary>
            Controls the non-accessibility modifiers are shown.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowBaseTypes">
            <summary>
            Controls whether base type references are shown.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowTypeParameters">
            <summary>
            Controls whether type parameter declarations are shown.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowTypeParametersForUnboundTypes">
            <summary>
            Controls whether type parameter names are shown for unbound types.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowTypeParameterConstraints">
            <summary>
            Controls whether constraints on type parameter declarations are shown.
            Has no effect if ShowTypeParameters is false.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowParameterNames">
            <summary>
            Controls whether the names of parameters are shown.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowConstantValues">
            <summary>
            Controls whether to show default values of optional parameters, and the values of constant fields.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ShowAttributes">
            <summary>
            Controls whether to show attributes.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.AlwaysUseShortTypeNames">
            <summary>
            Controls whether to use fully-qualified type names or short type names.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.UseKeywordsForBuiltinTypes">
            <summary>
            Controls whether to use keywords for builtin types.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.UseNullableSpecifierForValueTypes">
            <summary>
            Controls whether to use <c>T?</c> or <c>Nullable&lt;T&gt;</c> for nullable value types.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.NameLookupMode">
            <summary>
            Determines the name lookup mode for converting a type name.
            
            The default value is <c>NameLookupMode.Expression</c>, which means the name is disambiguated
            for use in expression context.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.GenerateBody">
            <summary>
            Controls whether to generate a body that throws a <c>System.NotImplementedException</c>.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.UseCustomEvents">
            <summary>
            Controls whether to generate custom events.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ConvertUnboundTypeArguments">
            <summary>
            Controls whether unbound type argument names are inserted in the ast or not.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.UseAliases">
            <summary>
            Controls whether aliases should be used inside the type name or not.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.UseSpecialConstants">
            <summary>
            Controls whether constants like <c>int.MaxValue</c> are converted to a <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.MemberReferenceExpression"/> or <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.PrimitiveExpression" />.
            The default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.PrintIntegralValuesAsHex">
            <summary>
            Controls whether integral constants should be printed in hexadecimal format.
            The default value is <see langword="false" />.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.SupportInitAccessors">
            <summary>
            Controls whether C# 9 "init;" accessors are supported.
            If disabled, emits "set /*init*/;" instead.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.TypeMatches(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.ITypeDefinition,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Gets whether 'type' is the same as 'typeDef' parameterized with the given type arguments.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.AddTypeArguments(ICSharpCode.Decompiler.CSharp.Syntax.AstType,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.ITypeParameter},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Int32,System.Int32)">
            <summary>
            Adds type arguments to the result type.
            </summary>
            <param name="result">The result AST node (a SimpleType or MemberType)</param>
            <param name="typeParameters">The type parameters</param>
            <param name="typeArguments">The list of type arguments</param>
            <param name="startIndex">Index of first type argument to add</param>
            <param name="endIndex">Index after last type argument to add</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ConvertConstantValue(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Creates an Expression for the given constant value.
            
            Note: the returned expression is not necessarily of the desired type.
            However, the returned expression will always be implicitly convertible to <c>rr.Type</c>,
            and will have the correct value when being converted in this way.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ConvertConstantValue(ICSharpCode.Decompiler.TypeSystem.IType,System.Object)">
            <summary>
            Creates an Expression for the given constant value.
            
            Note: the returned expression is not necessarily of the specified <paramref name="type"/>:
            For example, <c>ConvertConstantValue(typeof(string), null)</c> results in a <c>null</c> literal,
            without a cast to <c>string</c>.
            Similarly, <c>ConvertConstantValue(typeof(short), 1)</c> results in the literal <c>1</c>,
            which is of type <c>int</c>.
            However, the returned expression will always be implicitly convertible to <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder.ConvertConstantValue(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType,System.Object)">
            <summary>
            Creates an Expression for the given constant value.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable">
            <summary>
            Provides an interface to handle annotations in an object.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this IAnnotatable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.Annotation``1">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <typeparam name='T'>
            The type of the annotation.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.Annotation(System.Type)">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <param name='type'>
            The type of the annotation.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.AddAnnotation(System.Object)">
            <summary>
            Adds an annotation to this instance.
            </summary>
            <param name='annotation'>
            The annotation to add.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.RemoveAnnotations``1">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <typeparam name='T'>
            The type of the annotations to remove.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable.RemoveAnnotations(System.Type)">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <param name='type'>
            The type of the annotations to remove.
            </param>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Syntax.AbstractAnnotatable">
            <summary>
            Base class used to implement the IAnnotatable interface.
            This implementation is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Syntax.AbstractAnnotatable.CloneAnnotations">
            <summary>
            Clones all annotations.
            This method is intended to be called by Clone() implementations in derived classes.
            <code>
            AstNode copy = (AstNode)MemberwiseClone();
            copy.CloneAnnotations();
            </code>
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Syntax.AbstractAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this AstNode.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.AliasNamespaceResolveResult">
            <summary>
            Represents a namespace resolve result that's resolved using an alias.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.AliasNamespaceResolveResult.Alias">
            <summary>
            The alias used.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.AliasTypeResolveResult">
            <summary>
            Represents a type resolve result that's resolved using an alias.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.AliasTypeResolveResult.Alias">
            <summary>
            The alias used.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult">
            <summary>
            Represents the result of an await expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult.GetAwaiterInvocation">
            <summary>
            The method representing the GetAwaiter() call. Can be an <see cref="T:ICSharpCode.Decompiler.Semantics.InvocationResolveResult"/> or a <see cref="T:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult.AwaiterType">
            <summary>
            Awaiter type. Will not be null (but can be UnknownType).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult.IsCompletedProperty">
            <summary>
            Property representing the IsCompleted property on the awaiter type. Can be null if the awaiter type or the property was not found, or when awaiting a dynamic expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult.OnCompletedMethod">
            <summary>
            Method representing the OnCompleted method on the awaiter type. Can be null if the awaiter type or the method was not found, or when awaiting a dynamic expression.
            This can also refer to an UnsafeOnCompleted method, if the awaiter type implements <c>System.Runtime.CompilerServices.ICriticalNotifyCompletion</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult.GetResultMethod">
            <summary>
            Method representing the GetResult method on the awaiter type. Can be null if the awaiter type or the method was not found, or when awaiting a dynamic expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.CastResolveResult">
            <summary>
            Represents an explicitly applied conversion (CastExpression or AsExpression)
            (a result belonging to an AST node; not implicitly inserted 'between' nodes).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions">
            <summary>
            Contains logic that determines whether an implicit conversion exists between two types.
            </summary>
            <remarks>
            This class is thread-safe.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.Get(ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Gets the Conversions instance for the specified <see cref="T:ICSharpCode.Decompiler.TypeSystem.ICompilation"/>.
            This will make use of the context's cache manager to reuse the Conversions instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IsConstraintConvertible(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type 'fromType' is convertible to 'toType'
            using one of the conversions allowed when satisying constraints (4.4.4)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IdentityConversion(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether there is an identity conversion from <paramref name="fromType"/> to <paramref name="toType"/>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.UnpackGenericArrayInterface(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            For IList{T}, ICollection{T}, IEnumerable{T} and IReadOnlyList{T}, returns T.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IsBoxingConversionOrInvolvingTypeParameter(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the conversion from fromType to toType is a boxing conversion,
            or an implicit conversion involving a type parameter that might be
            a boxing conversion when instantiated with a value type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.ImplicitTypeParameterConversion(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Implicit conversions involving type parameters.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IsEncompassedBy(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether type A is encompassed by type B.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IsDelegateCompatible(ICSharpCode.Decompiler.TypeSystem.IMethod,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether a <paramref name="method"/> is compatible with a delegate type.
            15.2 Delegate compatibility
            </summary>
            <param name="method">The method to test for compatibility</param>
            <param name="delegateType">The delegate type</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.IsDelegateCompatible(ICSharpCode.Decompiler.TypeSystem.IMethod,ICSharpCode.Decompiler.TypeSystem.IMethod,System.Boolean)">
            <summary>
            Gets whether a method <paramref name="m"/> is compatible with a delegate type.
            15.2 Delegate compatibility
            </summary>
            <param name="m">The method to test for compatibility</param>
            <param name="invoke">The invoke method of the delegate</param>
            <param name="isExtensionMethodInvocation">Gets whether m is accessed using extension method syntax.
            If this parameter is true, the first parameter of <paramref name="m"/> will be ignored.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.BetterConversion(ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.3)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.UnpackTask(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Unpacks the generic Task[T]. Returns null if the input is not Task[T].
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.BetterConversion(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.4)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions.BetterConversionTarget(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the better conversion target (C# 4.0 spec, 7.5.3.5)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult">
            <summary>
            Represents the result of a method, constructor or indexer invocation.
            Provides additional C#-specific information for InvocationResolveResult.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult.IsExtensionMethodInvocation">
            <summary>
            Gets whether this invocation is calling an extension method using extension method syntax.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult.IsDelegateInvocation">
            <summary>
            Gets whether this invocation is calling a delegate (without explicitly calling ".Invoke()").
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult.IsExpandedForm">
            <summary>
            Gets whether a params-Array is being used in its expanded form.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult.GetArgumentToParameterMap">
            <summary>
            Gets an array that maps argument indices to parameter indices.
            For arguments that could not be mapped to any parameter, the value will be -1.
            
            parameterIndex = ArgumentToParameterMap[argumentIndex]
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpOperators.Get(ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Gets the CSharpOperators instance for the specified <see cref="T:ICSharpCode.Decompiler.TypeSystem.ICompilation"/>.
            This will make use of the context's cache manager (if available) to reuse the CSharpOperators instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.ILiftedOperator">
            <summary>
            Implement this interface to give overload resolution a hint that the member represents a lifted operator,
            which is used in the tie-breaking rules.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver">
            <summary>
            Contains the main resolver logic.
            </summary>
            <remarks>
            This class is thread-safe.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.Compilation">
            <summary>
            Gets the compilation used by the resolver.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentTypeResolveContext">
            <summary>
            Gets the current type resolve context.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CheckForOverflow">
            <summary>
            Gets whether the current context is <c>checked</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.WithCheckForOverflow(System.Boolean)">
            <summary>
            Sets whether the current context is <c>checked</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.IsWithinLambdaExpression">
            <summary>
            Gets whether the resolver is currently within a lambda expression or anonymous method.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.WithIsWithinLambdaExpression(System.Boolean)">
            <summary>
            Sets whether the resolver is currently within a lambda expression.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentMember">
            <summary>
            Gets the current member definition that is used to look up identifiers as parameters
            or type parameters.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.WithCurrentMember(ICSharpCode.Decompiler.TypeSystem.IMember)">
            <summary>
            Sets the current member definition.
            </summary>
            <remarks>Don't forget to also set CurrentTypeDefinition when setting CurrentMember;
            setting one of the properties does not automatically set the other.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentUsingScope">
            <summary>
            Gets the current using scope that is used to look up identifiers as class names.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.WithCurrentUsingScope(ICSharpCode.Decompiler.CSharp.TypeSystem.ResolvedUsingScope)">
            <summary>
            Sets the current using scope that is used to look up identifiers as class names.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentTypeDefinition">
            <summary>
            Gets the current type definition.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.WithCurrentTypeDefinition(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Sets the current type definition.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.PushBlock">
            <summary>
            Opens a new scope for local variables.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.PopBlock">
            <summary>
            Closes the current scope for local variables; removing all variables in that scope.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.AddVariable(ICSharpCode.Decompiler.TypeSystem.IVariable)">
            <summary>
            Adds a new variable or lambda parameter to the current block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.PopLastVariable">
            <summary>
            Removes the variable that was just added.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.LocalVariables">
            <summary>
            Gets all currently visible local variables and lambda parameters.
            Does not include method parameters.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.PushObjectInitializer(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Pushes the type of the object that is currently being initialized.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.IsInObjectInitializer">
            <summary>
            Gets whether this context is within an object initializer.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentObjectInitializer">
            <summary>
            Gets the current object initializer. This usually is an <see cref="T:ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult"/>
            or (for nested initializers) a semantic tree based on an <see cref="T:ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult"/>.
            Returns ErrorResolveResult if there is no object initializer.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CurrentObjectInitializerType">
            <summary>
            Gets the type of the object currently being initialized.
            Returns SharedTypes.Unknown if no object initializer is currently open (or if the object initializer
            has unknown type).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.HandleEnumComparison(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType,ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean,ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Handle the case where an enum value is compared with another enum value
            bool operator op(E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.HandleEnumSubtraction(System.Boolean,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Handle the case where an enum value is subtracted from another enum value
            U operator (E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.HandleEnumOperator(System.Boolean,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType,ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Handle the following enum operators:
            E operator +(E x, U y);
            E operator +(U x, E y);
            E operator (E x, U y);
            E operator &amp;(E x, E y);
            E operator |(E x, E y);
            E operator ^(E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.TryConvertEnum(ICSharpCode.Decompiler.Semantics.ResolveResult@,ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean@,ICSharpCode.Decompiler.Semantics.ResolveResult@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="rr">The input resolve result that should be converted.
            If a conversion exists, it is applied to the resolve result</param>
            <param name="targetType">The target type that we should convert to</param>
            <param name="isNullable">Whether we are dealing with a lifted operator</param>
            <param name="enumRR">The resolve result that is enum-typed.
            If necessary, a nullable conversion is applied.</param>
            <param name="allowConversionFromConstantZero">
            Whether the conversion from the constant zero is allowed.
            </param>
            <returns>True if the conversion is successful; false otherwise.
            If the conversion is not successful, the ref parameters will not be modified.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveAlias(System.String)">
            <summary>
            Looks up an alias (identifier in front of :: operator)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CreateMemberLookup">
            <summary>
            Creates a MemberLookup instance using this resolver's settings.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.CreateMemberLookup(ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode)">
            <summary>
            Creates a MemberLookup instance using this resolver's settings.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.GetExtensionMethods(System.String,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Gets all extension methods that are available in the current context.
            </summary>
            <param name="name">Name of the extension method. Pass null to retrieve all extension methods.</param>
            <param name="typeArguments">Explicitly provided type arguments.
            An empty list will return all matching extension method definitions;
            a non-empty list will return <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/>s for all extension methods
            with the matching number of type parameters.</param>
            <remarks>
            The results are stored in nested lists because they are grouped by using scope.
            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
            the return value will be
            new List {
               new List { all extensions from MoreExtensions },
               new List { all extensions from SomeExtensions }
            }
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.GetExtensionMethods(ICSharpCode.Decompiler.TypeSystem.IType,System.String,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Boolean)">
            <summary>
            Gets the extension methods that are called 'name'
            and are applicable with a first argument type of 'targetType'.
            </summary>
            <param name="targetType">Type of the 'this' argument</param>
            <param name="name">Name of the extension method. Pass null to retrieve all extension methods.</param>
            <param name="typeArguments">Explicitly provided type arguments.
            An empty list will return all matching extension method definitions;
            a non-empty list will return <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/>s for all extension methods
            with the matching number of type parameters.</param>
            <param name="substituteInferredTypes">
            Specifies whether to produce a <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/>
            when type arguments could be inferred from <paramref name="targetType"/>. This parameter
            is only used for inferred types and has no effect if <paramref name="typeArguments"/> is non-empty.
            </param>
            <remarks>
            The results are stored in nested lists because they are grouped by using scope.
            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
            the return value will be
            new List {
               new List { all extensions from MoreExtensions },
               new List { all extensions from SomeExtensions }
            }
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.IsEligibleExtensionMethod(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IMethod,System.Boolean,ICSharpCode.Decompiler.TypeSystem.IType[]@)">
            <summary>
            Checks whether the specified extension method is eligible on the target type.
            </summary>
            <param name="targetType">Target type that is passed as first argument to the extension method.</param>
            <param name="method">The extension method.</param>
            <param name="useTypeInference">Whether to perform type inference for the method.
            Use <c>false</c> if <paramref name="method"/> is already parameterized (e.g. when type arguments were given explicitly).
            Otherwise, use <c>true</c>.
            </param>
            <param name="outInferredTypes">If the method is generic and <paramref name="useTypeInference"/> is <c>true</c>,
            and at least some of the type arguments could be inferred, this parameter receives the inferred type arguments.
            Since only the type for the first parameter is considered, not all type arguments may be inferred.
            If an array is returned, any slot with an uninferred type argument will be set to the method's
            corresponding type parameter.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.GetAllExtensionMethods(ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup)">
            <summary>
            Gets all extension methods available in the current using scope.
            This list includes inaccessible methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveInvocation(ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.Semantics.ResolveResult[],System.String[])">
            <summary>
            Resolves an invocation.
            </summary>
            <param name="target">The target of the invocation. Usually a MethodGroupResolveResult.</param>
            <param name="arguments">
            Arguments passed to the method.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
            <param name="argumentNames">
            The argument names. Pass the null string for positional arguments.
            </param>
            <returns>InvocationResolveResult or UnknownMethodResolveResult</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveIndexer(ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.Semantics.ResolveResult[],System.String[])">
            <summary>
            Resolves an indexer access.
            </summary>
            <param name="target">Target expression.</param>
            <param name="arguments">
            Arguments passed to the indexer.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
            <param name="argumentNames">
            The argument names. Pass the null string for positional arguments.
            </param>
            <returns>ArrayAccessResolveResult, InvocationResolveResult, or ErrorResolveResult</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.AdjustArrayAccessArguments(ICSharpCode.Decompiler.Semantics.ResolveResult[])">
            <summary>
            Converts all arguments to int,uint,long or ulong.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveObjectCreation(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.Semantics.ResolveResult[],System.String[],System.Boolean,System.Collections.Generic.IList{ICSharpCode.Decompiler.Semantics.ResolveResult})">
            <summary>
            Resolves an object creation.
            </summary>
            <param name="type">Type of the object to create.</param>
            <param name="arguments">
            Arguments passed to the constructor.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
            <param name="argumentNames">
            The argument names. Pass the null string for positional arguments.
            </param>
            <param name="allowProtectedAccess">
            Whether to allow calling protected constructors.
            This should be false except when resolving constructor initializers.
            </param>
            <param name="initializerStatements">
            Statements for Objects/Collections initializer.
            <see cref="F:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.InitializerStatements"/>
            </param>
            <returns>InvocationResolveResult or ErrorResolveResult</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveSizeOf(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Resolves 'sizeof(type)'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveThisReference">
            <summary>
            Resolves 'this'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveBaseReference">
            <summary>
            Resolves 'base'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveCondition(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Converts the input to <c>bool</c> using the rules for boolean expressions.
            That is, <c>operator true</c> is used if a regular conversion to <c>bool</c> is not possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveConditionFalse(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Converts the negated input to <c>bool</c> using the rules for boolean expressions.
            Computes <c>!(bool)input</c> if the implicit cast to bool is valid; otherwise
            computes <c>input.operator false()</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveArrayCreation(ICSharpCode.Decompiler.TypeSystem.IType,System.Int32[],ICSharpCode.Decompiler.Semantics.ResolveResult[])">
            <summary>
            Resolves an array creation.
            </summary>
            <param name="elementType">
            The array element type.
            Pass null to resolve an implicitly-typed array creation.
            </param>
            <param name="sizeArguments">
            The size arguments.
            The length of this array will be used as the number of dimensions of the array type.
            Negative values will be treated as errors.
            </param>
            <param name="initializerElements">
            The initializer elements. May be null if no array initializer was specified.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver.ResolveArrayCreation(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.Semantics.ResolveResult[],ICSharpCode.Decompiler.Semantics.ResolveResult[])">
            <summary>
            Resolves an array creation.
            </summary>
            <param name="elementType">
            The array element type.
            Pass null to resolve an implicitly-typed array creation.
            </param>
            <param name="sizeArguments">
            The size arguments.
            The length of this array will be used as the number of dimensions of the array type.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
            <param name="initializerElements">
            The initializer elements. May be null if no array initializer was specified.
            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/>s!
            </param>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationType.Invocation">
            <summary>
            The invocation is a normal invocation ( 'a(b)' ).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationType.Indexing">
            <summary>
            The invocation is an indexing ( 'a[b]' ).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationType.ObjectCreation">
            <summary>
            The invocation is an object creation ( 'new a(b)' ).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult">
            <summary>
            Represents the result of an invocation of a member of a dynamic object.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult.Target">
            <summary>
            Target of the invocation. Can be a dynamic expression or a <see cref="T:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult.InvocationType">
            <summary>
            Type of the invocation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult.Arguments">
            <summary>
            Arguments for the call. Named arguments will be instances of <see cref="T:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult.InitializerStatements">
            <summary>
            Gets the list of initializer statements that are appplied to the result of this invocation.
            This is used to represent object and collection initializers.
            With the initializer statements, the <see cref="T:ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult"/> is used
            to refer to the result of this invocation.
            Initializer statements can only exist if the <see cref="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult.InvocationType"/> is <see cref="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationType.ObjectCreation"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.DynamicMemberResolveResult">
            <summary>
            Represents the result of an access to a member of a dynamic object.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicMemberResolveResult.Target">
            <summary>
            Target of the member access (a dynamic object).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DynamicMemberResolveResult.Member">
            <summary>
            Name of the accessed member.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult">
            <summary>
            Represents an anonymous method or lambda expression.
            Note: the lambda has no type.
            To retrieve the delegate type, look at the anonymous function conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.HasParameterList">
            <summary>
            Gets whether there is a parameter list.
            This property always returns true for C# 3.0-lambdas, but may return false
            for C# 2.0 anonymous methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.IsAnonymousMethod">
            <summary>
            Gets whether this lambda is using the C# 2.0 anonymous method syntax.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.IsImplicitlyTyped">
            <summary>
            Gets whether the lambda parameters are implicitly typed.
            </summary>
            <remarks>This property returns false for anonymous methods without parameter list.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.IsAsync">
            <summary>
            Gets whether the lambda is async.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.GetInferredReturnType(ICSharpCode.Decompiler.TypeSystem.IType[])">
            <summary>
            Gets the return type inferred when the parameter types are inferred to be <paramref name="parameterTypes"/>
            </summary>
            <remarks>
            This method determines the return type inferred from the lambda body, which is used as part of C# type inference.
            Use the <see cref="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.ReturnType"/> property to retrieve the actual return type as determined by the target delegate type.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.Parameters">
            <summary>
            Gets the list of parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.ReturnType">
            <summary>
            Gets the return type of the lambda.
            
            If the lambda is async, the return type includes <code>Task&lt;T&gt;</code>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.IsValid(ICSharpCode.Decompiler.TypeSystem.IType[],ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions)">
            <summary>
            Gets whether the lambda body is valid for the given parameter types and return type.
            </summary>
            <returns>
            Produces a conversion with <see cref="P:ICSharpCode.Decompiler.Semantics.Conversion.IsAnonymousFunctionConversion"/>=<c>true</c> if the lambda is valid;
            otherwise returns <see cref="F:ICSharpCode.Decompiler.Semantics.Conversion.None"/>.
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult.Body">
            <summary>
            Gets the resolve result for the lambda body.
            Returns a resolve result for 'void' for statement lambdas.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.DecompiledLambdaResolveResult.InferredReturnType">
            <summary>
            The inferred return type.
            Can differ from <c>ReturnType</c> if a return statement
            performs an implicit conversion.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.Log">
            <summary>
            Resolver logging helper.
            Wraps System.Diagnostics.Debug so that resolver-specific logging can be enabled/disabled on demand.
            (it's a huge amount of debug spew and slows down the resolver quite a bit)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup">
            <summary>
            Implementation of member lookup (C# 4.0 spec, 7.4).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.IsInvocable(ICSharpCode.Decompiler.TypeSystem.IMember)">
            <summary>
            Gets whether the member is considered to be invocable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.IsProtectedAccessAllowed(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Gets whether access to protected instance members of the target expression is possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.IsProtectedAccessAllowed(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether access to protected instance members of the target type is possible.
            </summary>
            <remarks>
            This method does not consider the special case of the 'base' reference. If possible, use the
            <c>IsProtectedAccessAllowed(ResolveResult)</c> overload instead.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.IsAccessible(ICSharpCode.Decompiler.TypeSystem.IEntity,System.Boolean)">
            <summary>
            Gets whether <paramref name="entity"/> is accessible in the current class.
            </summary>
            <param name="entity">The entity to test</param>
            <param name="allowProtectedAccess">
            Whether protected access to instance members is allowed.
            True if the type of the reference is derived from the current class.
            Protected static members may be accessible even if false is passed for this parameter.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.GetAccessibleMembers(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Retrieves all members that are accessible and not hidden (by being overridden or shadowed).
            Returns both members and nested type definitions. Does not include extension methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.Lookup(ICSharpCode.Decompiler.Semantics.ResolveResult,System.String,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Boolean)">
            <summary>
            Performs a member lookup.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.LookupIndexers(ICSharpCode.Decompiler.Semantics.ResolveResult)">
            <summary>
            Looks up the indexers on the target type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.AddNestedTypes(ICSharpCode.Decompiler.TypeSystem.IType,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IType},System.Int32,System.Collections.Generic.List{ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.LookupGroup},System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IType}@,System.Collections.Generic.List{ICSharpCode.Decompiler.TypeSystem.IType}@)">
            <summary>
            Adds the nested types to 'newNestedTypes' and removes any hidden members from the existing lookup groups.
            </summary>
            <param name="type">Declaring type of the nested types</param>
            <param name="nestedTypes">List of nested types to add.</param>
            <param name="typeArgumentCount">The number of type arguments - used for hiding types from the base class</param>
            <param name="lookupGroups">List of existing lookup groups</param>
            <param name="typeBaseTypes">The base types of 'type' (initialized on demand)</param>
            <param name="newNestedTypes">The target list (created on demand).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.AddMembers(ICSharpCode.Decompiler.TypeSystem.IType,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IMember},System.Boolean,System.Collections.Generic.List{ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup.LookupGroup},System.Boolean,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IType}@,System.Collections.Generic.List{ICSharpCode.Decompiler.TypeSystem.IParameterizedMember}@,ICSharpCode.Decompiler.TypeSystem.IMember@)">
            <summary>
            Adds members to 'newMethods'/'newNonMethod'.
            Removes any members in the existing lookup groups that were hidden by added members.
            Substitutes 'virtual' members in the existing lookup groups for added 'override' members.
            </summary>
            <param name="type">Declaring type of the members</param>
            <param name="members">List of members to add.</param>
            <param name="allowProtectedAccess">Whether protected members are accessible</param>
            <param name="lookupGroups">List of existing lookup groups</param>
            <param name="treatAllParameterizedMembersAsMethods">Whether to treat properties as methods</param>
            <param name="typeBaseTypes">The base types of 'type' (initialized on demand)</param>
            <param name="newMethods">The target list for methods (created on demand).</param>
            <param name="newNonMethod">The target variable for non-method members.</param>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.MethodListWithDeclaringType">
            <summary>
            A method list that belongs to a declaring type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodListWithDeclaringType.DeclaringType">
            <summary>
            The declaring type.
            </summary>
            <remarks>
            Not all methods in this list necessarily have this as their declaring type.
            For example, this program:
            <code>
             class Base {
               public virtual void M() {}
             }
             class Derived : Base {
               public override void M() {}
               public void M(int i) {}
             }
            </code>
            results in two lists:
             <c>new MethodListWithDeclaringType(Base) { Derived.M() }</c>,
             <c>new MethodListWithDeclaringType(Derived) { Derived.M(int) }</c>
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult">
            <summary>
            Represents a group of methods.
            A method reference used to create a delegate is resolved to a MethodGroupResolveResult.
            The MethodGroupResolveResult has no type.
            To retrieve the delegate type or the chosen overload, look at the method group conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.TargetResult">
            <summary>
            Gets the resolve result for the target object.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.TargetType">
            <summary>
            Gets the type of the reference to the target object.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.MethodName">
            <summary>
            Gets the name of the methods in this group.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.Methods">
            <summary>
            Gets the methods that were found.
            This list does not include extension methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.MethodsGroupedByDeclaringType">
            <summary>
            Gets the methods that were found, grouped by their declaring type.
            This list does not include extension methods.
            Base types come first in the list.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.TypeArguments">
            <summary>
            Gets the type arguments that were explicitly provided.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.extensionMethods">
            <summary>
            List of extension methods, used to avoid re-calculating it in ResolveInvocation() when it was already
            calculated by ResolveMemberAccess().
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.GetExtensionMethods">
            <summary>
            Gets all candidate extension methods.
            Note: this includes candidates that are not eligible due to an inapplicable
            this argument.
            The candidates will only be specialized if the type arguments were provided explicitly.
            </summary>
            <remarks>
            The results are stored in nested lists because they are grouped by using scope.
            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
            the return value will be
            new List {
               new List { all extensions from MoreExtensions },
               new List { all extensions from SomeExtensions }
            }
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.GetEligibleExtensionMethods(System.Boolean)">
            <summary>
            Gets the eligible extension methods.
            </summary>
            <param name="substituteInferredTypes">
            Specifies whether to produce a <c>SpecializedMethod</c>
            when type arguments could be inferred from <see cref="P:ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult.TargetType"/>.
            This setting is only used for inferred types and has no effect if the type parameters are
            specified explicitly.
            </param>
            <remarks>
            The results are stored in nested lists because they are grouped by using scope.
            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
            the return value will be
            new List {
               new List { all extensions from MoreExtensions },
               new List { all extensions from SomeExtensions }
            }
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode.Expression">
            <summary>
            Normal name lookup in expressions
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode.InvocationTarget">
            <summary>
            Name lookup in expression, where the expression is the target of an invocation.
            Such a lookup will only return methods and delegate-typed fields.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode.Type">
            <summary>
            Normal name lookup in type references.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode.TypeInUsingDeclaration">
            <summary>
            Name lookup in the type reference inside a using declaration.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode.BaseTypeReference">
            <summary>
            Name lookup for base type references.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution">
            <summary>
            C# overload resolution (C# 4.0 spec: 7.5).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.IsExpandedForm">
            <summary>
            Returns the normal form candidate, if this is an expanded candidate.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.ParameterTypes">
            <summary>
            Gets the parameter types. In the first step, these are the types without any substition.
            After type inference, substitutions will be performed.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.ArgumentToParameterMap">
            <summary>
            argument index -> parameter index; -1 for arguments that could not be mapped
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.Parameters">
            <summary>
            Gets the original member parameters (before any substitution!)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.TypeParameters">
            <summary>
            Gets the original method type parameters (before any substitution!)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate.ArgumentConversions">
            <summary>
            Conversions applied to the arguments.
            This field is set by the CheckApplicability step.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.IsExtensionMethodInvocation">
            <summary>
            Gets/Sets whether the methods are extension methods that are being called using extension method syntax.
            </summary>
            <remarks>
            Setting this property to true restricts the possible conversions on the first argument to
            implicit identity, reference, or boxing conversions.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.AllowExpandingParams">
            <summary>
            Gets/Sets whether expanding 'params' into individual elements is allowed.
            The default value is true.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.AllowOptionalParameters">
            <summary>
            Gets/Sets whether optional parameters may be left at their default value.
            The default value is true.
            If this property is set to false, optional parameters will be treated like regular parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.CheckForOverflow">
            <summary>
            Gets/Sets whether ConversionResolveResults created by this OverloadResolution
            instance apply overflow checking.
            The default value is false.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Arguments">
            <summary>
            Gets the arguments for which this OverloadResolution instance was created.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.AddCandidate(ICSharpCode.Decompiler.TypeSystem.IParameterizedMember)">
            <summary>
            Adds a candidate to overload resolution.
            </summary>
            <param name="member">The candidate member to add.</param>
            <returns>The errors that prevent the member from being applicable, if any.
            Note: this method does not return errors that do not affect applicability.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.AddCandidate(ICSharpCode.Decompiler.TypeSystem.IParameterizedMember,ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors)">
            <summary>
            Adds a candidate to overload resolution.
            </summary>
            <param name="member">The candidate member to add.</param>
            <param name="additionalErrors">Additional errors that apply to the candidate.
            This is used to represent errors during member lookup (e.g. OverloadResolutionErrors.Inaccessible)
            in overload resolution.</param>
            <returns>The errors that prevent the member from being applicable, if any.
            Note: this method does not return errors that do not affect applicability.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.CalculateCandidate(ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate)">
            <summary>
            Calculates applicability etc. for the candidate.
            </summary>
            <returns>True if the calculation was successful, false if the candidate should be removed without reporting an error</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.AddMethodLists(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.CSharp.Resolver.MethodListWithDeclaringType})">
            <summary>
            Adds all candidates from the method lists.
            
            This method implements the logic that causes applicable methods in derived types to hide
            all methods in base types.
            </summary>
            <param name="methodLists">The methods, grouped by declaring type. Base types must come first in the list.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.ValidateConstraints(ICSharpCode.Decompiler.TypeSystem.ITypeParameter,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.TypeVisitor)">
            <summary>
            Validates whether the given type argument satisfies the constraints for the given type parameter.
            </summary>
            <param name="typeParameter">The type parameter.</param>
            <param name="typeArgument">The type argument.</param>
            <param name="substitution">The substitution that defines how type parameters are replaced with type arguments.
            The substitution is used to check constraints that depend on other type parameters (or recursively on the same type parameter).
            May be null if no substitution should be used.</param>
            <returns>True if the constraints are satisfied; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.IsApplicable(ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors)">
            <summary>
            Returns whether a candidate with the given errors is still considered to be applicable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.BetterFunctionMember(ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate,ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.Candidate)">
            <summary>
            Returns 1 if c1 is better than c2; 2 if c2 is better than c1; or 0 if neither is better.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.BestCandidateErrors">
            <summary>
            Returns the errors that apply to the best candidate.
            This includes additional errors that do not affect applicability (e.g. AmbiguousMatch, MethodConstraintsNotSatisfied)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.ArgumentConversions">
            <summary>
            Gets the implicit conversions that are being applied to the arguments.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.GetArgumentToParameterMap">
            <summary>
            Gets an array that maps argument indices to parameter indices.
            For arguments that could not be mapped to any parameter, the value will be -1.
            
            parameterIndex = GetArgumentToParameterMap()[argumentIndex]
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.GetArgumentsWithConversions">
            <summary>
            Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
            Arguments are wrapped in a <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/> if an implicit conversion is being applied
            to them when calling the method.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.GetArgumentsWithConversionsAndNames">
            <summary>
            Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
            Arguments are wrapped in a <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/> if an implicit conversion is being applied
            to them when calling the method.
            For arguments where an explicit argument name was provided, the argument will
            be wrapped in a <see cref="T:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution.CreateResolveResult(ICSharpCode.Decompiler.Semantics.ResolveResult,System.Collections.Generic.IList{ICSharpCode.Decompiler.Semantics.ResolveResult},ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Creates a ResolveResult representing the result of overload resolution.
            </summary>
            <param name="targetResolveResult">
            The target expression of the call. May be <c>null</c> for static methods/constructors.
            </param>
            <param name="initializerStatements">
            Statements for Objects/Collections initializer.
            <see cref="F:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.InitializerStatements"/>
            </param>
            <param name="returnTypeOverride">
            If not null, use this instead of the ReturnType of the member as the type of the created resolve result.
            </param>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.TooManyPositionalArguments">
            <summary>
            Too many positional arguments (some could not be mapped to any parameter).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.NoParameterFoundForNamedArgument">
            <summary>
            A named argument could not be mapped to any parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.TypeInferenceFailed">
            <summary>
            Type inference failed for a generic method.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.WrongNumberOfTypeArguments">
            <summary>
            Type arguments were explicitly specified, but did not match the number of type parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.ConstructedTypeDoesNotSatisfyConstraint">
            <summary>
            After substituting type parameters with the inferred types; a constructed type within the formal parameters
            does not satisfy its constraint.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.MissingArgumentForRequiredParameter">
            <summary>
            No argument was mapped to a non-optional parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.MultipleArgumentsForSingleParameter">
            <summary>
            Several arguments were mapped to a single (non-params-array) parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.ParameterPassingModeMismatch">
            <summary>
            'ref'/'out' passing mode doesn't match for at least 1 parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.ArgumentTypeMismatch">
            <summary>
            Argument type cannot be converted to parameter type
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.AmbiguousMatch">
            <summary>
            There is no unique best overload.
            This error does not apply to any single candidate, but only to the overall result of overload resolution.
            </summary>
            <remarks>
            This error does not prevent a candidate from being applicable.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.Inaccessible">
            <summary>
            The member is not accessible.
            </summary>
            <remarks>
            This error is generated by member lookup; not by overload resolution.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors.MethodConstraintsNotSatisfied">
            <summary>
            A generic method 
            </summary>
            <remarks>
            This error does not prevent a candidate from being applicable.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.TypeInferenceAlgorithm.CSharp4">
            <summary>
            C# 4.0 type inference.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.TypeInferenceAlgorithm.Improved">
            <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Resolver.TypeInferenceAlgorithm.ImprovedReturnAllResults">
            <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing;
            uses <see cref="T:ICSharpCode.Decompiler.TypeSystem.IntersectionType"/> to report all results (in case of ambiguities).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference">
            <summary>
            Implements C# 4.0 Type Inference (7.5.2).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.Algorithm">
            <summary>
            Gets/Sets the type inference algorithm used.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.InferTypeArguments(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.ITypeParameter},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.Semantics.ResolveResult},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Boolean@,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Performs type inference.
            </summary>
            <param name="typeParameters">The method type parameters that should be inferred.</param>
            <param name="arguments">The arguments passed to the method.</param>
            <param name="parameterTypes">The parameter types of the method.</param>
            <param name="success">Out: whether type inference was successful</param>
            <param name="classTypeArguments">
            Class type arguments. These are substituted for class type parameters in the formal parameter types
            when inferring a method group or lambda.
            </param>
            <returns>The inferred type arguments.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.InferTypeArgumentsFromBounds(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.ITypeParameter},ICSharpCode.Decompiler.TypeSystem.IType,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IType},System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.TypeSystem.IType},System.Boolean@)">
            <summary>
            Infers type arguments for the <paramref name="typeParameters"/> occurring in the <paramref name="targetType"/>
            so that the resulting type (after substition) satisfies the given bounds.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.MakeExactInference(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Make exact inference from U to V.
            C# 4.0 spec: 7.5.2.8 Exact inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.MakeLowerBoundInference(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Make lower bound inference from U to V.
            C# 4.0 spec: 7.5.2.9 Lower-bound inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.MakeUpperBoundInference(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Make upper bound inference from U to V.
            C# 4.0 spec: 7.5.2.10 Upper-bound inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.GetBestCommonType(System.Collections.Generic.IList{ICSharpCode.Decompiler.Semantics.ResolveResult},System.Boolean@)">
            <summary>
            Gets the best common type (C# 4.0 spec: 7.5.2.14) of a set of expressions.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Resolver.TypeInference.FindTypeInBounds(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Finds a type that satisfies the given lower and upper bounds.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.CombineQueryExpressions">
            <summary>
            Combines query expressions and removes transparent identifiers.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.CombineQueryExpressions.RemoveTransparentIdentifierReferences(ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Removes all occurrences of transparent identifiers
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceExtensionMethods">
            <summary>
            Converts extension method calls into infix syntax.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceQueryExpressions">
            <summary>
            Decompiles query expressions.
            Based on C# 4.0 spec, 7.16.2 Query expression translation
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceQueryExpressions.WrapExpressionInParenthesesIfNecessary(ICSharpCode.Decompiler.CSharp.Syntax.Expression,System.String)">
            <summary>
            This fixes #437: Decompilation of query expression loses material parentheses
            We wrap the expression in parentheses if:
            - the Select-call is explicit (see caller(s))
            - the expression is a plain identifier matching the parameter name
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceQueryExpressions.ValidateThenByChain(ICSharpCode.Decompiler.CSharp.Syntax.InvocationExpression,System.String)">
            <summary>
            Ensure that all ThenBy's are correct, and that the list of ThenBy's is terminated by an 'OrderBy' invocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceQueryExpressions.MatchSimpleLambda(ICSharpCode.Decompiler.CSharp.Syntax.Expression,ICSharpCode.Decompiler.CSharp.Syntax.ParameterDeclaration@,ICSharpCode.Decompiler.CSharp.Syntax.Expression@)">
            <summary>Matches simple lambdas of the form "a => b"</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.NormalizeBlockStatements.movableModifiers">
            <summary>
            Modifiers that are emitted on accessors, but can be moved to the property declaration.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.PrettifyAssignments">
            <summary>
            Simplifies "x = x op y" into "x op= y" where possible.
            </summary>
            <remarks>
            Because the two "x" in "x = x op y" may refer to different ILVariables,
            this transform must run after DeclareVariables.
            
            It must also run after ReplaceMethodCallsWithOperators (so that it can work for custom operator, too);
            and after AddCheckedBlocks (because "for (;; x = unchecked(x op y))" cannot be transformed into "x += y").
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.RemoveCLSCompliantAttribute">
            <summary>
            This transform is used to remove CLSCompliant attributes added by the compiler. We remove them in order to get rid of many warnings.
            </summary>
            <remarks>This transform is only enabled, when exporting a full assembly as project.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.ContextTrackingVisitor`1">
            <summary>
            Base class for AST visitors that need the current type/method context info.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.DecimalConstantTransform">
            <summary>
            Transforms decimal constant fields.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables">
            <summary>
            Insert variable declarations.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.InsertionPoint">
            <summary>
            Represents a position immediately before nextNode.
            nextNode is either an ExpressionStatement in a BlockStatement, or an initializer in a for-loop.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.InsertionPoint.level">
            <summary>
            The nesting level of `nextNode` within the AST.
            Used to speed up FindCommonParent().
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.InsertionPoint.Up">
            <summary>Go up one level</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.VariableToDeclare.DefaultInitialization">
            <summary>
            Whether the variable needs to be default-initialized.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.VariableToDeclare.SourceOrder">
            <summary>
            Integer value that can be used to compare to VariableToDeclare instances
            to determine which variable was used first in the source code.
            
            The variable with the lower SourceOrder value has the insertion point
            that comes first in the source code.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.VariableToDeclare.InsertionPoint">
            <summary>
            The insertion point, i.e. the node before which the variable declaration should be inserted.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.VariableToDeclare.FirstUse">
            <summary>
            The first use of the variable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.Analyze(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Analyze the input AST (containing undeclared variables)
            for where those variables would be declared by this transform.
            Analysis does not modify the AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.GetDeclarationPoint(ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Get the position where the declaration for the variable will be inserted.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.WasMerged(ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Determines whether a variable was merged with other variables.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.FindInsertionPoints(ICSharpCode.Decompiler.CSharp.Syntax.AstNode,System.Int32)">
            <summary>
            Finds insertion points for all variables used within `node`
            and adds them to the variableDict.
            
            `level` == nesting depth of `node` within root node.
            </summary>
            <remarks>
            Insertion point for a variable = common parent of all uses of that variable
            = smallest possible scope that contains all the uses of the variable
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.FindCommonParent(ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.InsertionPoint,ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.InsertionPoint)">
            <summary>
            Finds an insertion point in a common parent instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.ResolveCollisions">
            <summary>
            Some variable declarations in C# are illegal (colliding),
            even though the variable live ranges are not overlapping.
            
            Multiple declarations in same block:
            <code>
            int i = 1; use(1);
            int i = 2; use(2);
            </code>
            
            "Hiding" declaration in nested block:
            <code>
            int i = 1; use(1);
            if (...) {
              int i = 2; use(2);
            }
            </code>
            
            Nested blocks are illegal even if the parent block
            declares the variable later:
            <code>
            if (...) {
              int i = 1; use(i);
            }
            int i = 2; use(i);
            </code>
            
            ResolveCollisions() detects all these cases, and combines the variable declarations
            to a single declaration that is usable for the combined scopes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables.UpdateAnnotations(ICSharpCode.Decompiler.CSharp.Syntax.AstNode)">
            <summary>
            Update ILVariableResolveResult annotations of all ILVariables that have been replaced by ResolveCollisions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.EscapeInvalidIdentifiers">
            <summary>
            Escape invalid identifiers.
            </summary>
            <remarks>
            This transform is not enabled by default.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.RemoveCompilerGeneratedAssemblyAttributes">
            <summary>
            This transform is used to remove assembly-attributes that are generated by the compiler,
            thus don't need to be declared. (We have to remove them, in order to avoid conflicts while compiling.)
            </summary>
            <remarks>This transform is only enabled, when exporting a full assembly as project.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.FixNameCollisions">
            <summary>
            Rename entities to solve name collisions that make the code uncompilable.
            </summary>
            <remarks>
            Currently, we only rename private fields that collide with property or event names.
            This helps especially with compiler-generated events that were not detected as a pattern.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.IntroduceUsingDeclarations">
            <summary>
            Introduces using declarations.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform">
            <summary>
            Finds the expanded form of using statements using pattern matching and replaces it with a UsingStatement.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.variableAssignPattern">
            <summary>
            $variable = $initializer;
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.variableAssignUpperBoundPattern">
            <summary>
            $variable = $collection.GetUpperBound($index);
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.variableAssignLowerBoundPattern">
            <summary>
            $variable = $collection.GetLowerBound($index);
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.foreachVariableOnMultArrayAssignPattern">
            <summary>
            $variable = $collection[$index1, $index2, ...];
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.automaticPropertyBackingFieldNameRegex">
            <summary>
            This matches the following patterns
            <list type="bullet">
            	<item>&lt;Property&gt;k__BackingField (used by C#)</item>
            	<item>_Property (used by VB)</item>
            </list>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.TransformTryCatchFinally(ICSharpCode.Decompiler.CSharp.Syntax.TryCatchStatement)">
            <summary>
            Simplify nested 'try { try {} catch {} } finally {}'.
            This transformation must run after the using/lock tranformations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform.VisitBinaryOperatorExpression(ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorExpression)">
            <summary>
            Use associativity of logic operators to avoid parentheses.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.TransformContext">
            <summary>
            Parameters for IAstTransform.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Transforms.TransformContext.CurrentMember">
            <summary>
            Returns the current member; or null if a whole type or module is being decompiled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Transforms.TransformContext.CurrentTypeDefinition">
            <summary>
            Returns the current type definition; or null if a module is being decompiled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Transforms.TransformContext.CurrentModule">
            <summary>
            Returns the module that is being decompiled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.Transforms.TransformContext.RequiredNamespacesSuperset">
            <summary>
            Returns the max possible set of namespaces that will be used during decompilation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks">
            <summary>
            Add checked/unchecked blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks.CheckedUncheckedAnnotation.IsChecked">
            <summary>
            true=checked, false=unchecked
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks.Cost.WrapInCheckedExpr">
            <summary>
            Gets the new cost if an expression with this cost is wrapped in a checked/unchecked expression.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks.InsertedNode">
            <summary>
            Holds the blocks and expressions that should be inserted
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks.Result">
            <summary>
            Holds the result of an insertion operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.TransformFieldAndConstructorInitializers">
            <summary>
            This transform moves field initializers at the start of constructors to their respective field declarations
            and transforms this-/base-ctor calls in constructors to constructor initializers.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.TypeOfPattern">
            <summary>
            typeof-Pattern that applies on the expanded form of typeof (prior to ReplaceMethodCallsWithOperators)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.ReplaceMethodCallsWithOperators">
            <summary>
            Replaces method calls with the appropriate operator expressions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.Transforms.AddXmlDocumentationTransform">
            <summary>
            Adds XML documentation for member definitions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TranslationContext">
            <summary>
            Context struct passed in to ExpressionBuilder.Visit() methods.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.TranslationContext.TypeHint">
            <summary>
            The expected type during ILAst->C# translation; or <c>SpecialType.Unknown</c>
            if no specific type is expected.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.AliasNamespaceReference">
            <summary>
            Looks up an alias (identifier in front of :: operator).
            </summary>
            <remarks>
            The member lookup performed by the :: operator is handled
            by <see cref="T:ICSharpCode.Decompiler.CSharp.TypeSystem.MemberTypeOrNamespaceReference"/>.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.MemberTypeOrNamespaceReference">
            <summary>
            Reference to a qualified type or namespace name.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.MemberTypeOrNamespaceReference.AddSuffix(System.String)">
            <summary>
            Adds a suffix to the identifier.
            Does not modify the existing type reference, but returns a new one.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.ResolvedUsingScope">
            <summary>
            Resolved version of using scope.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.ResolvedUsingScope.HasAlias(System.String)">
            <summary>
            Gets whether this using scope has an alias (either using or extern)
            with the specified name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.SimpleTypeOrNamespaceReference">
            <summary>
            Represents a simple C# name. (a single non-qualified identifier with an optional list of type arguments)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.SimpleTypeOrNamespaceReference.AddSuffix(System.String)">
            <summary>
            Adds a suffix to the identifier.
            Does not modify the existing type reference, but returns a new one.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.TypeOrNamespaceReference">
            <summary>
            Represents a reference which could point to a type or namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.TypeOrNamespaceReference.Resolve(ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver)">
            <summary>
            Resolves the reference and returns the ResolveResult.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.TypeOrNamespaceReference.ResolveType(ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver)">
            <summary>
            Returns the type that is referenced; or an <c>UnknownType</c> if the type isn't found.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.TypeOrNamespaceReference.ResolveNamespace(ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver)">
            <summary>
            Returns the namespace that is referenced; or null if no such namespace is found.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope">
            <summary>
            Represents a scope that contains "using" statements.
            This is either the file itself, or a namespace declaration.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope.#ctor">
            <summary>
            Creates a new root using scope.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope.#ctor(ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope,System.String)">
            <summary>
            Creates a new nested using scope.
            </summary>
            <param name="parent">The parent using scope.</param>
            <param name="shortName">The short namespace name.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope.HasAlias(System.String)">
            <summary>
            Gets whether this using scope has an alias (either using or extern)
            with the specified name.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope.Resolve(ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Resolves the namespace represented by this using scope.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ExpressionWithILInstruction">
            <summary>
            Helper struct so that the compiler can ensure we don't forget both the ILInstruction annotation and the ResolveResult annotation.
            Use '.WithILInstruction(...)' or '.WithoutILInstruction()' to create an instance of this struct.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ExpressionWithResolveResult">
            <summary>
            Helper struct so that the compiler can ensure we don't forget both the ILInstruction annotation and the ResolveResult annotation.
            Use '.WithRR(...)'.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.TranslatedExpression">
            <summary>
            Output of C# ExpressionBuilder -- a decompiled C# expression that has both a resolve result and ILInstruction annotation.
            </summary>
            <remarks>
            The resolve result is also always available as annotation on the expression, but having
            TranslatedExpression as a separate type is still useful to ensure that no case in the expression builder
            forgets to add the annotation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TranslatedExpression.UnwrapChild(ICSharpCode.Decompiler.CSharp.Syntax.Expression)">
            <summary>
            Returns a new TranslatedExpression that represents the specified descendant expression.
            All ILInstruction annotations from the current expression are copied to the descendant expression.
            The descendant expression is detached from the AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TranslatedExpression.ConvertTo(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.CSharp.ExpressionBuilder,System.Boolean,System.Boolean)">
            <summary>
            Adds casts (if necessary) to convert this expression to the specified target type.
            </summary>
            <remarks>
            If the target type is narrower than the source type, the value is truncated.
            If the target type is wider than the source type, the value is sign- or zero-extended based on the
            sign of the source type.
            This fits with the ExpressionBuilder's post-condition, so e.g. an assignment can simply
            call <c>Translate(stloc.Value).ConvertTo(stloc.Variable.Type)</c> and have the overall C# semantics match the IL semantics.
            
            From the caller's perspective, IntPtr/UIntPtr behave like normal C# integers except that they have native int size.
            All the special cases necessary to make IntPtr/UIntPtr behave sanely are handled internally in ConvertTo().
            
            Post-condition:
               The "expected evaluation result" is the value computed by <c>this.Expression</c>,
               converted to targetType via an IL conv instruction.
            
               ConvertTo(targetType, allowImplicitConversion=false).Type must be equal to targetType (modulo identity conversions).
                 The value computed by the converted expression must match the "expected evaluation result".
            
               ConvertTo(targetType, allowImplicitConversion=true) must produce an expression that,
                 when evaluated in a context where it will be implicitly converted to targetType,
                 evaluates to the "expected evaluation result".
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TranslatedExpression.CastCanBeMadeImplicit(ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions,ICSharpCode.Decompiler.Semantics.Conversion,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether an implicit conversion from 'inputType' to 'newTargetType'
            would have the same semantics as the existing cast from 'inputType' to 'oldTargetType'.
            The existing cast is classified in 'conversion'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TranslatedExpression.UnwrapImplicitBoolConversion(System.Func{ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean})">
            <summary>
            In conditional contexts, remove the bool-cast emitted when converting
            an "implicit operator bool" invocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.TranslatedExpression.ConvertToBoolean(ICSharpCode.Decompiler.CSharp.ExpressionBuilder,System.Boolean)">
            <summary>
            Converts this expression to a boolean expression.
            
            Expects that the input expression is an integer expression; produces an expression
            that returns <c>true</c> iff the integer value is not 0.
            
            If negate is true, instead produces an expression that returns <c>true</c> iff the integer value is 0.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.CSharpDecompiler">
            <summary>
            Main class of the C# decompiler engine.
            </summary>
            <remarks>
            Instances of this class are not thread-safe. Use separate instances to decompile multiple members in parallel.
            (in particular, the transform instances are not thread-safe)
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.EarlyILTransforms(System.Boolean)">
            <summary>
            Pre-yield/await transforms.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.GetILTransforms">
            <summary>
            Returns all built-in transforms of the ILAst pipeline.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.GetAstTransforms">
            <summary>
            Returns all built-in transforms of the C# AST pipeline.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.CancellationToken">
            <summary>
            Token to check for requested cancellation of the decompilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.TypeSystem">
            <summary>
            The type system created from the main module and referenced modules.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DebugInfoProvider">
            <summary>
            Gets or sets the optional provider for debug info.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DocumentationProvider">
            <summary>
            Gets or sets the optional provider for XML documentation strings.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.ILTransforms">
            <summary>
            IL transforms.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.AstTransforms">
            <summary>
            C# AST transforms.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.#ctor(System.String,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.Decompiler.CSharp.CSharpDecompiler"/> instance from the given <paramref name="fileName"/> using the given <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.#ctor(System.String,ICSharpCode.Decompiler.Metadata.IAssemblyResolver,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.Decompiler.CSharp.CSharpDecompiler"/> instance from the given <paramref name="fileName"/> using the given <paramref name="assemblyResolver"/> and <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.#ctor(ICSharpCode.Decompiler.Metadata.PEFile,ICSharpCode.Decompiler.Metadata.IAssemblyResolver,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.Decompiler.CSharp.CSharpDecompiler"/> instance from the given <paramref name="module"/> using the given <paramref name="assemblyResolver"/> and <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.#ctor(ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.Decompiler.CSharp.CSharpDecompiler"/> instance from the given <paramref name="typeSystem"/> and the given <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.MemberIsHidden(ICSharpCode.Decompiler.Metadata.PEFile,System.Reflection.Metadata.EntityHandle,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Determines whether a <paramref name="member"/> should be hidden from the decompiled code. This is used to exclude compiler-generated code that is handled by transforms from the output.
            </summary>
            <param name="module">The module containing the member.</param>
            <param name="member">The metadata token/handle of the member. Can be a TypeDef, MethodDef or FieldDef.</param>
            <param name="settings">THe settings used to determine whether code should be hidden. E.g. if async methods are not transformed, async state machines are included in the decompiled code.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileModuleAndAssemblyAttributes">
            <summary>
            Decompile assembly and module attributes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileModuleAndAssemblyAttributesToString">
            <summary>
            Decompile assembly and module attributes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileWholeModuleAsSingleFile">
            <summary>
            Decompiles the whole module into a single syntax tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileWholeModuleAsSingleFile(System.Boolean)">
            <summary>
            Decompiles the whole module into a single syntax tree.
            </summary>
            <param name="sortTypes">If true, top-level-types are emitted sorted by namespace/name.
            If false, types are emitted in metadata order.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.CreateILTransformContext(ICSharpCode.Decompiler.IL.ILFunction)">
            <summary>
            Creates an <see cref="T:ICSharpCode.Decompiler.IL.Transforms.ILTransformContext"/> for the given <paramref name="function"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.GetCodeMappingInfo(ICSharpCode.Decompiler.Metadata.PEFile,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Determines the "code-mappings" for a given TypeDef or MethodDef. See <see cref="T:ICSharpCode.Decompiler.Metadata.CodeMappingInfo"/> for more information.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileWholeModuleAsString">
            <summary>
            Decompiles the whole module into a single string.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileTypes(System.Collections.Generic.IEnumerable{System.Reflection.Metadata.TypeDefinitionHandle})">
            <summary>
            Decompile the given types.
            </summary>
            <remarks>
            Unlike Decompile(IMemberDefinition[]), this method will add namespace declarations around the type definitions.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileTypesAsString(System.Collections.Generic.IEnumerable{System.Reflection.Metadata.TypeDefinitionHandle})">
            <summary>
            Decompile the given types.
            </summary>
            <remarks>
            Unlike Decompile(IMemberDefinition[]), this method will add namespace declarations around the type definitions.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileType(ICSharpCode.Decompiler.TypeSystem.FullTypeName)">
            <summary>
            Decompile the given type.
            </summary>
            <remarks>
            Unlike Decompile(IMemberDefinition[]), this method will add namespace declarations around the type definition.
            Note that decompiling types from modules other than the main module is not supported.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileTypeAsString(ICSharpCode.Decompiler.TypeSystem.FullTypeName)">
            <summary>
            Decompile the given type.
            </summary>
            <remarks>
            Unlike Decompile(IMemberDefinition[]), this method will add namespace declarations around the type definition.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.Decompile(System.Reflection.Metadata.EntityHandle[])">
            <summary>
            Decompile the specified types and/or members.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.Decompile(System.Collections.Generic.IEnumerable{System.Reflection.Metadata.EntityHandle})">
            <summary>
            Decompile the specified types and/or members.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileAsString(System.Reflection.Metadata.EntityHandle[])">
            <summary>
            Decompile the specified types and/or members.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.DecompileAsString(System.Collections.Generic.IEnumerable{System.Reflection.Metadata.EntityHandle})">
            <summary>
            Decompile the specified types and/or members.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.SetNewModifier(ICSharpCode.Decompiler.CSharp.Syntax.EntityDeclaration)">
            <summary>
            Sets new modifier if the member hides some other member from a base type.
            </summary>
            <param name="member">The node of the member which new modifier state should be determined.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.CSharpDecompiler.CreateSequencePoints(ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree)">
            <summary>
            Creates sequence points for the given syntax tree.
            
            This only works correctly when the nodes in the syntax tree have line/column information.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.CSharp.ExpressionBuilder">
            <summary>
            Translates from ILAst to C# expressions.
            </summary>
            <remarks>
            Every translated expression must have:
            * an ILInstruction annotation
            * a ResolveResult annotation
            Post-condition for Translate() calls:
              * The type of the ResolveResult must match the StackType of the corresponding ILInstruction,
                except that the width of integer types does not need to match (I4, I and I8 count as the same stack type here)
              * Evaluating the resulting C# expression shall produce the same side effects as evaluating the ILInstruction.
              * If the IL instruction has <c>ResultType == StackType.Void</c>, the C# expression may evaluate to an arbitrary type and value.
              * Otherwise, evaluating the resulting C# expression shall produce a similar value as evaluating the ILInstruction.
                 * If the IL instruction evaluates to an integer stack type (I4, I, or I8),
                   the C# type of the resulting expression shall also be an integer (or enum/pointer/char/bool) type.
                   * If sizeof(C# type) == sizeof(IL stack type), the values must be the same.
                   * If sizeof(C# type) > sizeof(IL stack type), the C# value truncated to the width of the IL stack type must equal the IL value.
                   * If sizeof(C# type) &lt; sizeof(IL stack type), the C# value (sign/zero-)extended to the width of the IL stack type
                     must equal the IL value.
                     Whether sign or zero extension is used depends on the sign of the C# type (as determined by <c>IType.GetSign()</c>).
                 * If the IL instruction is a lifted nullable operation, and the underlying operation evaluates to an integer stack type,
                   the C# type of the resulting expression shall be Nullable{T}, where T is an integer type (as above).
                   The C# value shall be null iff the IL-level value evaluates to null, and otherwise the values shall correspond
                   as with non-lifted integer operations.
                 * If the IL instruction evaluates to a managed reference (Ref) created by starting tracking of an unmanaged reference,
                   the C# instruction may evaluate to any integral/enum/pointer type that when converted to pointer type
                   is equivalent to the managed reference.
                 * Otherwise, the C# type of the resulting expression shall match the IL stack type,
                   and the evaluated values shall be the same.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.TranslateCeq(ICSharpCode.Decompiler.IL.Comp,System.Boolean@)">
            <summary>
            Translates the equality comparison between left and right.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.TranslateComp(ICSharpCode.Decompiler.IL.Comp)">
            <summary>
            Handle Comp instruction, operators other than equality/inequality.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.HandlePointerArithmetic(ICSharpCode.Decompiler.IL.BinaryNumericInstruction,ICSharpCode.Decompiler.CSharp.TranslatedExpression,ICSharpCode.Decompiler.CSharp.TranslatedExpression)">
            <summary>
            Translates pointer arithmetic:
              ptr + int
              int + ptr
              ptr - int
            Returns null if 'inst' is not performing pointer arithmetic.
            'ptr - ptr' is not handled here, but in HandlePointerSubtraction()!
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.HandleManagedPointerArithmetic(ICSharpCode.Decompiler.IL.BinaryNumericInstruction,ICSharpCode.Decompiler.CSharp.TranslatedExpression,ICSharpCode.Decompiler.CSharp.TranslatedExpression)">
            <summary>
            Translates pointer arithmetic with managed pointers:
              ref + int
              int + ref
              ref - int
              ref - ref
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.HandlePointerSubtraction(ICSharpCode.Decompiler.IL.BinaryNumericInstruction)">
            <summary>
            Called for divisions, detect and handles the code pattern:
              div(sub(a, b), sizeof(T))
            when a,b are of type T*.
            This is what the C# compiler generates for pointer subtraction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.FindType(ICSharpCode.Decompiler.IL.StackType,ICSharpCode.Decompiler.TypeSystem.Sign)">
            <summary>
            Gets a type matching the stack type and sign.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.FindArithmeticType(ICSharpCode.Decompiler.IL.StackType,ICSharpCode.Decompiler.TypeSystem.Sign)">
            <summary>
            Gets a type used for performing arithmetic with the stack type and sign.
            
            This may result in a larger type than requested when the selected C# version
            doesn't support native integers.
            Should only be used after a call to PrepareArithmeticArgument()
            to ensure that we're not preserving extra bits from an oversized TranslatedExpression.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.PrepareArithmeticArgument(ICSharpCode.Decompiler.CSharp.TranslatedExpression,ICSharpCode.Decompiler.IL.StackType,ICSharpCode.Decompiler.TypeSystem.Sign,System.Boolean)">
            <summary>
            Handle oversized arguments needing truncation; and avoid IntPtr/pointers in arguments.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.IsCompatibleWithSign(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.Sign)">
            <summary>
            Gets whether <paramref name="type"/> has the specified <paramref name="sign"/>.
            If <paramref name="sign"/> is None, always returns true.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.ValueMightBeOversized(ICSharpCode.Decompiler.Semantics.ResolveResult,ICSharpCode.Decompiler.IL.StackType)">
            <summary>
            Gets whether the ResolveResult computes a value that might be oversized for the specified stack type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.ExpressionBuilder.AdjustConstantExpressionToType(ICSharpCode.Decompiler.CSharp.TranslatedExpression,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            If expr is a constant integer expression, and its value fits into type,
            convert the expression into the target type.
            Otherwise, returns the expression unmodified.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.continueTarget">
            <summary>Target block that a 'continue;' statement would jump to</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.continueCount">
            <summary>Number of ContinueStatements that were created for the current continueTarget</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.caseLabelMapping">
            <summary>Maps blocks to cases.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.breakTarget">
            <summary>Target container that a 'break;' statement would break out of</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.endContainerLabels">
            <summary>Dictionary from BlockContainer to label name for 'goto of_container';</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.StatementBuilder.UnwrapNestedContainerIfPossible(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Leave@)">
            <summary>
            Unwraps a nested BlockContainer, if container contains only a single block,
            and that single block contains only a BlockContainer followed by a Leave instruction.
            If the leave instruction is a return that carries a value, the container is unwrapped only
            if the value has no side-effects.
            Otherwise returns the unmodified container.
            </summary>
            <param name="optionalReturnInst">If the leave is a return and has no side-effects, we can move the return out of the using-block and put it after the loop, otherwise returns null.</param>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation.NoForeach">
            <summary>
            Foreach transformation not possible.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation.UseExistingVariable">
            <summary>
            Uninline the stloc foreachVar(call get_Current()) and insert it as first statement in the loop body.
            <code>
            ... (stloc foreachVar(call get_Current()) ...
            =>
            stloc foreachVar(call get_Current())
            ... (ldloc foreachVar) ...
            </code>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation.IntroduceNewVariable">
            <summary>
            No store was found, thus create a new variable and use it as foreach variable.
            <code>
            ... (call get_Current()) ...
            =>
            stloc foreachVar(call get_Current())
            ... (ldloc foreachVar) ...
            </code>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation.IntroduceNewVariableAndLocalCopy">
            <summary>
            No store was found, thus create a new variable and use it as foreach variable.
            Additionally it is necessary to copy the value of the foreach variable to another local
            to allow safe modification of its value.
            <code>
            ... addressof(call get_Current()) ...
            =>
            stloc foreachVar(call get_Current())
            stloc copy(ldloc foreachVar)
            ... (ldloca copy) ...
            </code>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation.Deconstruction">
            <summary>
            call get_Current() is the tested operand of a deconstruct instruction.
            and the deconstruct instruction is the first statement in the loop body.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.StatementBuilder.DetectGetCurrentTransformation(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.CallInstruction@,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Determines whether <paramref name="enumerator"/> is only used once inside <paramref name="loopBody"/> for accessing the Current property.
            </summary>
            <param name="usingContainer">The using body container. This is only used for variable usage checks.</param>
            <param name="loopBody">The loop body. The first statement of this block is analyzed.</param>
            <param name="enumerator">The current enumerator.</param>
            <param name="moveNextUsage">The call MoveNext(ldloc enumerator) pattern.</param>
            <param name="singleGetter">Returns the call instruction invoking Current's getter.</param>
            <param name="foreachVariable">Returns the the foreach variable, if a suitable was found. This variable is only assigned once and its assignment is the first statement in <paramref name="loopBody"/>.</param>
            <returns><see cref="T:ICSharpCode.Decompiler.CSharp.StatementBuilder.RequiredGetCurrentTransformation"/> for details.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.StatementBuilder.VariableIsOnlyUsedInBlock(ICSharpCode.Decompiler.IL.StLoc,ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.BlockContainer)">
            <summary>
            Determines whether storeInst.Variable is only assigned once and used only inside <paramref name="usingContainer"/>.
            Loads by reference (ldloca) are only allowed in the context of this pointer in call instructions,
            or as target of ldobj.
            (This only applies to value types.)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.CSharp.StatementBuilder.CurrentIsStructSetterTarget(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.CallInstruction)">
            <summary>
            Returns true if singleGetter is a value type and its address is used as setter target.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.DeconstructionTransform">
            <summary>
            
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DeconstructionTransform.FindIndex(ICSharpCode.Decompiler.IL.ILInstruction,System.Action{ICSharpCode.Decompiler.IL.DeconstructInstruction}@)">
            <summary>
            Get index of deconstruction result or tuple element
            Returns -1 on failure.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DeconstructionTransform.InlineDeconstructionInitializer(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc v(value)
            expr(..., deconstruct { ... }, ...)
            =>
            expr(..., deconstruct { init: stloc v(value) ... }, ...)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.FixLoneIsInst">
            <summary>
            C# cannot represent `isinst T` directly for value-types.
            This transform un-inlines the argument of `isinst` instructions that can't be directly translated to C#,
            thus allowing the emulation via "expr is T ? (T)expr : null".
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform">
            <summary>
            Transform for the C# 8 System.Index / System.Range feature
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.HandleLdElema(ICSharpCode.Decompiler.IL.LdElema,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Called by expression transforms.
            Handles the `array[System.Index]` cases.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.CheckContainerLengthVariableUseCount(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind,ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind)">
            <summary>
            Check that the number of uses of the containerLengthVar variable matches those expected in the pattern.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.MatchIndexFromRange(ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,System.String)">
            <summary>
            Matches 'addressof System.Index(call get_Start/get_End(ldloca rangeVar))'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.CSharpWillGenerateIndexer(ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean)">
            <summary>
            Gets whether the C# compiler will call `container[int]` when using `container[Index]`.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.MatchContainerLengthStore(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable@,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Matches the instruction:
               stloc containerLengthVar(call get_Length/get_Count(ldloc containerVar))
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.MatchContainerLength(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            If lengthVar is non-null, matches 'ldloc lengthVar'.
            
            Otherwise, matches the instruction:
            	call get_Length/get_Count(ldloc containerVar)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind.FromStart">
            <summary>
            indexLoad is an integer, from the start of the container
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind.RefSystemIndex">
            <summary>
            indexLoad is loading the address of a System.Index struct
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind.FromEnd">
            <summary>
            indexLoad is an integer, from the end of the container
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind.TheStart">
            <summary>
            Always equivalent to `0`, used for the start-index when slicing without a startpoint `a[..end]`
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind.TheEnd">
            <summary>
            Always equivalent to `^0`, used for the end-index when slicing without an endpoint `a[start..]`
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.MatchGetOffset(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Matches an instruction computing an offset:
               call System.Index.GetOffset(indexLoad, ldloc containerLengthVar)
            or
               binary.sub.i4(ldloc containerLengthVar, indexLoad)
            
            Anything else not matching these patterns is interpreted as an `int` expression from the start of the container.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.MatchSliceLength(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform.IndexKind@,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILVariable@,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Matches an instruction computing a slice length:
               binary.sub.i4(call GetOffset(endIndexLoad, ldloc length), ldloc startOffset))
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext">
            <summary>
            Context object for the ILInstruction.Extract() operation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext.Function">
            <summary>
            Nearest function, used for registering the new locals that are created by extraction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext.FlagsBeingMoved">
            <summary>
            Combined flags of all instructions being moved.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext.MoveActions">
            <summary>
            List of actions to be executed when performing the extraction.
            
            Each function in this list has the side-effect of replacing the instruction-to-be-moved
            with a load of a fresh temporary variable; and returns the the store to the temporary variable,
            which will be inserted at block-level.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext.CanReorderWithInstructionsBeingMoved(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Currently, <c>predecessor</c> is evaluated before the instructions being moved.
            If this function returns true, <c>predecessor</c> can stay as-is, despite the move changing the evaluation order.
            If this function returns false, <c>predecessor</c> will need to also move, to ensure the evaluation order stays unchanged.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExtractionContext.Extract(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Extracts the specified instruction:
              The instruction is replaced with a load of a new temporary variable;
              and the instruction is moved to a store to said variable at block-level.
            
            May return null if extraction is not possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DynamicIsEventAssignmentTransform.Run(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)">
            stloc V_1(dynamic.isevent (target))
            if (logic.not(ldloc V_1)) Block IL_004a {
            	stloc V_2(dynamic.getmember B(target))
            }
            [stloc copyOfValue(value)]
            if (logic.not(ldloc V_1)) Block IL_0149 {
            	dynamic.setmember.compound B(target, dynamic.binary.operator AddAssign(ldloc V_2,  value))
            } else Block IL_0151 {
            	dynamic.invokemember.invokespecial.discard add_B(target, value)
            }
            =>
            if (logic.not(dynamic.isevent (target))) Block IL_0149 {
            	dynamic.setmember.compound B(target, dynamic.binary.operator AddAssign(dynamic.getmember B(target),  value))
            } else Block IL_0151 {
            	dynamic.invokemember.invokespecial.discard add_B(target, value)
            }
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DynamicIsEventAssignmentTransform.MatchIsEventAssignmentIfInstruction(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.DynamicIsEventInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.DynamicSetMemberInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            if (logic.not(ldloc V_1)) Block IL_0149 {
            	dynamic.setmember.compound B(target, dynamic.binary.operator AddAssign(ldloc V_2,  value))
            } else Block IL_0151 {
            	dynamic.invokemember.invokespecial.discard add_B(target, value)
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DynamicIsEventAssignmentTransform.MatchLhsCacheIfInstruction(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.StLoc@)">
            <summary>
            if (logic.not(ldloc V_1)) Block IL_004a {
            	stloc V_2(dynamic.getmember B(target))
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler">
            <summary>
            Decompiler step for C# 7.0 local functions
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler.LocalFunctionInfo.LocalFunctionArguments">
            <summary>
            Used to store all synthesized call-site arguments grouped by the parameter index.
            We use a dictionary instead of a simple array, because -1 is used for the this parameter
            and there might be many non-synthesized arguments in between.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler.Run(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            The transform works like this:
            
            <para>
            local functions can either be used in method calls, i.e., call and callvirt instructions,
            or can be used as part of the "delegate construction" pattern, i.e.,
            <c>newobj Delegate(&lt;target-expression&gt;, ldftn &lt;method&gt;)</c>.
            </para>
            As local functions can be declared practically anywhere, we have to take a look at
            all use-sites and infer the declaration location from that. Use-sites can be call,
            callvirt and ldftn instructions.
            After all use-sites are collected we construct the ILAst of the local function
            and add it to the parent function.
            Then all use-sites of the local-function are transformed to a call to the 
            <c>LocalFunctionMethod</c> or a ldftn of the <c>LocalFunctionMethod</c>.
            In a next step we handle all nested local functions.
            After all local functions are transformed, we move all local functions that capture
            any variables to their respective declaration scope.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler.functionNameRegex">
            <summary>
            Newer Roslyn versions use the format "&lt;callerName&gt;g__functionName|x_y"
            Older versions use "&lt;callerName&gt;g__functionNamex_y"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage">
            <summary>
            Transforms closure fields to local variables.
            
            This is a post-processing step of <see cref="T:ICSharpCode.Decompiler.IL.Transforms.DelegateConstruction"/>, <see cref="T:ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler"/>
            and <see cref="T:ICSharpCode.Decompiler.IL.Transforms.TransformExpressionTrees"/>.
            
            In general we can perform SROA (scalar replacement of aggregates) on any variable that
            satisfies the following conditions:
            1) It is initialized by an empty/default constructor call.
            2) The variable is never passed to another method.
            3) The variable is never the target of an invocation.
            
            Note that 2) and 3) apply because declarations and uses of lambdas and local functions
            are already transformed by the time this transform is applied.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage.ResolveVariableToPropagate(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Resolves references to variables that can be propagated.
            If a value does not match either LdLoc or a LdObj LdLdFlda* LdLoc chain, null is returned.
            The if any of the variables/fields in the chain cannot be propagated, null is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage.HandleMonoStateMachine(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            mcs likes to optimize closures in yield state machines away by moving the captured variables' fields into the state machine type,
            We construct a <see cref="T:ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage.DisplayClass"/> that spans the whole method body.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.UserDefinedLogicTransform.Transform(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
                  if (call op_False(ldloc lhsVar)) ldloc lhsVar else call op_BitwiseAnd(ldloc lhsVar, rhsInst)
               -> user.logic op_BitwiseAnd(ldloc lhsVar, rhsInst)
            or
                  if (call op_True(ldloc lhsVar)) ldloc lhsVar else call op_BitwiseOr(ldloc lhsVar, rhsInst)
               -> user.logic op_BitwiseOr(ldloc lhsVar, rhsInst)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.DynamicCallSiteTransform">
            <summary>
            Transforms the "callsite initialization pattern" into DynamicInstructions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform">
            <summary>
            If possible, transforms plain ILAst loops into while (condition), do-while and for-loops.
            For the invariants of the transforms <see cref="M:ICSharpCode.Decompiler.IL.BlockContainer.CheckInvariant(ICSharpCode.Decompiler.IL.ILPhase)"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform.MatchDoWhileLoop(ICSharpCode.Decompiler.IL.BlockContainer)">
            <summary>
            Matches a do-while loop and performs the following transformations:
            - combine all compatible conditions into one IfInstruction.
            - extract conditions into a condition block, or move the existing condition block to the end.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform.CollectConditions(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,System.Boolean)">
            <summary>
            Returns a list of all IfInstructions that can be used as loop conditon, i.e.,
            that have no false-instruction and have leave loop (if swapped) or branch entry-point as true-instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform.MatchIncrement(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Returns true if the instruction is stloc v(add(ldloc v, arg))
            or compound.assign(ldloca v, arg)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform.IsSimpleStatement(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether the statement is 'simple' (usable as for loop iterator):
            Currently we only accept calls and assignments.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NamedArgumentTransform.IntroduceNamedArgument(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Introduce a named argument for 'arg' and evaluate it before the other arguments
            (except for the "this" pointer)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform">
            <summary>
            Transform that converts code patterns like "v != null ? v.M() : null" to "v?.M()"
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Mode.ReferenceType">
            <summary>
            reference type or generic type (comparison is 'comp(ldloc(testedVar) == null)')
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Mode.NullableByValue">
            <summary>
            nullable type, used by value (comparison is 'call get_HasValue(ldloca(testedVar))')
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Mode.NullableByReference">
            <summary>
            nullable type, used by reference (comparison is 'call get_HasValue(ldloc(testedVar))')
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Mode.UnconstrainedType">
            <summary>
            unconstrained generic type (see the pattern described in TransformNullPropagationOnUnconstrainedGenericExpression)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Run(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Check if "condition ? trueInst : falseInst" can be simplified using the null-conditional operator.
            Returns the replacement instruction, or null if no replacement is possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.TryNullPropagation(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.Mode)">
            <summary>
            testedVar != null ? nonNullInst : nullInst
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform.RunStatements(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            if (x != null) x.AccessChain();
            => x?.AccessChain();
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.InlineReturnTransform">
            <summary>
            This transform duplicates return blocks if they return a local variable that was assigned right before the return.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.InlineReturnTransform.CanModifyInstructions(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.Block,System.Collections.Generic.List{System.ValueTuple{ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Branch}}@)">
            <summary>
            Determines a list of all store instructions that write to a given <paramref name="returnVar"/>.
            Returns false if any of these instructions does not meet the following criteria:
            - must be a stloc
            - must be a direct child of a block
            - must be the penultimate instruction
            - must be followed by a branch instruction to <paramref name="leaveBlock"/>
            - must have a BlockContainer as ancestor.
            Returns true, if all instructions meet these criteria, and <paramref name="instructionsToModify"/> contains a list of 3-tuples.
            Each tuple consists of the target block container, the leave block, and the branch instruction that should be modified.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.SwitchOnNullableTransform">
            <summary>
            Detects switch-on-nullable patterns employed by the C# compiler and transforms them to an ILAst-switch-instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnNullableTransform.MatchSwitchOnNullable(ICSharpCode.Decompiler.IL.InstructionCollection{ICSharpCode.Decompiler.IL.ILInstruction},System.Int32,ICSharpCode.Decompiler.IL.SwitchInstruction@)">
            <summary>
            Matches legacy C# switch on nullable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnNullableTransform.MatchRoslynSwitchOnNullable(ICSharpCode.Decompiler.IL.InstructionCollection{ICSharpCode.Decompiler.IL.ILInstruction},System.Int32,ICSharpCode.Decompiler.IL.SwitchInstruction@)">
            <summary>
            Matches Roslyn C# switch on nullable.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform">
            <summary>
            Detects switch-on-string patterns employed by the C# compiler and transforms them to an ILAst-switch-instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchCaseBlock(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILVariable,System.String@,System.Boolean@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Each case consists of two blocks:
            1. block:
            if (call op_Equality(ldloc switchVariable, ldstr value)) br caseBlock
            br nextBlock
            -or-
            if (comp(ldloc switchValueVar == ldnull)) br nextBlock
            br caseBlock
            2. block is caseBlock
            This method matches the above pattern or its inverted form:
            the call to ==(string, string) is wrapped in logic.not and the branch targets are reversed.
            Returns the next block that follows in the block-chain.
            The <paramref name="switchVariable"/> is updated if the value gets copied to a different variable.
            See comments below for more info.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchLegacySwitchOnStringWithDict(ICSharpCode.Decompiler.IL.InstructionCollection{ICSharpCode.Decompiler.IL.ILInstruction},System.Int32@)">
            <summary>
            Matches the C# 2.0 switch-on-string pattern, which uses Dictionary&lt;string, int&gt;.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchDictionaryFieldLoad(ICSharpCode.Decompiler.IL.ILInstruction,System.Func{ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean},ICSharpCode.Decompiler.TypeSystem.IField@,ICSharpCode.Decompiler.TypeSystem.IType@)">
            <summary>
            Matches 'volatile.ldobj dictionaryType(ldsflda dictField)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.ExtractStringValuesFromInitBlock(ICSharpCode.Decompiler.IL.Block,System.Collections.Generic.List{System.ValueTuple{System.String,System.Int32}}@,ICSharpCode.Decompiler.IL.Block@,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IField,System.Boolean)">
            <summary>
            Matches and extracts values from Add-call sequences.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchAddCall(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,System.Int32@,System.String@)">
            <summary>
            call Add(ldloc dictVar, ldstr value, ldc.i4 index)
            -or-
            call Add(ldloc dictVar, ldstr value, box System.Int32(ldc.i4 index))
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.IsNullCheckInDefaultBlock(ICSharpCode.Decompiler.IL.Block@,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.Block@)">
            <summary>
            Matches:
            Block oldDefaultBlock (incoming: 1) {
                if (comp.o(ldloc switchVar == ldnull)) br nullValueCaseBlock
                br newDefaultBlock
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchRoslynCaseBlockHead(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.Block@,System.String@,System.Boolean@)">
            <summary>
            Matches (and the negated version):
            if (call op_Equality(ldloc switchValueVar, stringValue)) br body
            br exit
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchRoslynEmptyStringCaseBlockHead(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.Block@)">
            <summary>
            Block target(incoming: 1) {
            	if (comp.o(ldloc switchValueVar == ldnull)) br exit
            	br lengthCheckBlock
            }
            
            Block lengthCheckBlock(incoming: 1) {
            	if (logic.not(call get_Length(ldloc switchValueVar))) br body
            	br exit
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchStringLengthCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            call get_Length(ldloc switchValueVar)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchComputeStringHashCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.LdLoc@)">
            <summary>
            Matches 'stloc(targetVar, call ComputeStringHash(ldloc switchValue))'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchStringEqualityComparison(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,System.String@,System.Boolean@)">
            <summary>
            Matches 'call string.op_Equality(ldloc(variable), ldstr(stringValue))'
                 or 'comp(ldloc(variable) == ldnull)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform.MatchStringEqualityComparison(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable@,System.String@,System.Boolean@)">
            <summary>
            Matches 'call string.op_Equality(ldloc(variable), ldstr(stringValue))'
                 or 'comp(ldloc(variable) == ldnull)'
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.TransformExpressionTrees">
            <summary>
            Converts LINQ Expression Trees to ILFunctions/ILAst instructions.
            
            We build a tree of Func{ILInstruction}s, which are only executed, if the whole transform succeeds.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformExpressionTrees.MightBeExpressionTree(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Returns true if the instruction matches the pattern for Expression.Lambda calls.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformExpressionTrees.ConvertLambda(ICSharpCode.Decompiler.IL.CallInstruction)">
            <summary>
            Converts a Expression.Lambda call into an ILFunction.
            If the conversion fails, null is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.UsingTransform.TransformUsing(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc obj(resourceExpression)
            .try BlockContainer {
            	Block IL_0003(incoming: 1) {
            		call WriteLine(ldstr "using (null)")
            		leave IL_0003(nop)
            	}
            } finally BlockContainer {
            	Block IL_0012(incoming: 1) {
            		if (comp(ldloc obj != ldnull)) Block IL_001a  {
            			callvirt Dispose(ldnull)
            		}
            		leave IL_0012(nop)
            	}
            }
            leave IL_0000(nop)
            =>
            using (resourceExpression) {
            	BlockContainer {
            		Block IL_0003(incoming: 1) {
            			call WriteLine(ldstr "using (null)")
            			leave IL_0003(nop)
            		}
            	}
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.UsingTransform.TransformUsingVB(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            .try BlockContainer {
            	Block IL_0003(incoming: 1) {
            		stloc obj(resourceExpression)
            		call WriteLine(ldstr "using (null)")
            		leave IL_0003(nop)
            	}
            } finally BlockContainer {
            	Block IL_0012(incoming: 1) {
            		if (comp(ldloc obj != ldnull)) Block IL_001a  {
            			callvirt Dispose(ldnull)
            		}
            		leave IL_0012(nop)
            	}
            }
            leave IL_0000(nop)
            =>
            using (resourceExpression) {
            	BlockContainer {
            		Block IL_0003(incoming: 1) {
            			call WriteLine(ldstr "using (null)")
            			leave IL_0003(nop)
            		}
            	}
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.UsingTransform.TransformAsyncUsing(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc test(resourceExpression)
            .try BlockContainer {
            	Block IL_002b (incoming: 1) {
            		call Use(ldloc test)
            		leave IL_002b (nop)
            	}
            
            } finally BlockContainer {
            	Block IL_0045 (incoming: 1) {
            		if (comp.o(ldloc test == ldnull)) leave IL_0045 (nop)
            		br IL_00ae
            	}
            
            	Block IL_00ae (incoming: 1) {
            		await(addressof System.Threading.Tasks.ValueTask(callvirt DisposeAsync(ldloc test)))
            		leave IL_0045 (nop)
            	}
            
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.AssignVariableNames.IsSupportedInstruction(System.Object)">
            <remarks>
            Must be in sync with <see cref="M:ICSharpCode.Decompiler.IL.Transforms.AssignVariableNames.GetNameFromInstruction(ICSharpCode.Decompiler.IL.ILInstruction)" />.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DetectCatchWhenConditionBlocks.MatchCatchWhenEntryPoint(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.TypeSystem.IType@,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.Block@)">
            <summary>
            Block entryPoint (incoming: 1)  {
              stloc temp(isinst exceptionType(ldloc exceptionVar))
              if (comp(ldloc temp != ldnull)) br whenConditionBlock
              br falseBlock
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DetectCatchWhenConditionBlocks.MatchFalseBlock(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILVariable@,ICSharpCode.Decompiler.IL.Block@)">
            <summary>
            Block falseBlock (incoming: 1)  {
              stloc returnVar(ldc.i4 0)
              br exitBlock
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.DetectCatchWhenConditionBlocks.MatchExitBlock(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Block exitBlock(incoming: 2) {
              leave container(ldloc returnVar)
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.LockTransform.TransformLockMCS(ICSharpCode.Decompiler.IL.Block,System.Int32)">
             <summary>
            	stloc lockObj(lockExpression)
            	call Enter(ldloc lockObj)
            	.try BlockContainer {
            		Block lockBlock (incoming: 1) {
            			call WriteLine()
            			leave lockBlock (nop)
            		}
            
            	} finally BlockContainer {
            		Block exitBlock (incoming: 1) {
            			call Exit(ldloc lockObj)
            			leave exitBlock (nop)
            		}
            
            	}
             =>
             .lock (lockExpression) BlockContainer {
             	Block lockBlock (incoming: 1) {
            			call WriteLine()
            			leave lockBlock (nop)
            		}
             }
             </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.LockTransform.TransformLockV2(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc lockObj(ldloc tempVar)
            call Enter(ldloc tempVar)
            .try BlockContainer {
            	Block lockBlock(incoming: 1) {
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            } finally BlockContainer {
            	Block exitBlock(incoming: 1) {
            		call Exit(ldloc lockObj)
            		leave exitBlock (nop)
            	}
            }
            =>
            .lock (lockObj) BlockContainer {
            	Block lockBlock (incoming: 1) {
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.LockTransform.TransformLockV4(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc flag(ldc.i4 0)
            .try BlockContainer {
            	Block lockBlock (incoming: 1) {
            		call Enter(stloc obj(lockObj), ldloca flag)
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            } finally BlockContainer {
            	Block (incoming: 1) {
            		if (ldloc flag) Block  {
            			call Exit(ldloc obj)
            		}
            		leave lockBlock (nop)
            	}		
            }
            =>
            .lock (lockObj) BlockContainer {
            	Block lockBlock (incoming: 1) {
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.LockTransform.TransformLockRoslyn(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            stloc obj(lockObj)
            stloc flag(ldc.i4 0)
            .try BlockContainer {
            	Block lockBlock (incoming: 1) {
            		call Enter(ldloc obj, ldloca flag)
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            } finally BlockContainer {
            	Block (incoming: 1) {
            		if (ldloc flag) Block  {
            			call Exit(ldloc obj)
            		}
            		leave lockBlock (nop)
            	}		
            }
            =>
            .lock (lockObj) BlockContainer {
            	Block lockBlock (incoming: 1) {
            		call WriteLine()
            		leave lockBlock (nop)
            	}
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform">
            <summary>
            Nullable lifting gets run in two places:
             * the usual form looks at an if-else, and runs within the ExpressionTransforms.
             * the NullableLiftingBlockTransform handles the cases where Roslyn generates
               two 'ret' statements for the null/non-null cases of a lifted operator.
            
            The transform handles the following languages constructs:
             * lifted conversions
             * lifted unary and binary operators
             * lifted comparisons
             * the ?? operator with type Nullable{T} on the left-hand-side
             * the ?. operator (via NullPropagationTransform)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.Run(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            Main entry point into the normal code path of this transform.
            Called by expression transform.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.Run(ICSharpCode.Decompiler.IL.BinaryNumericInstruction)">
            <summary>
            VS2017.8 / Roslyn 2.9 started optimizing some cases of
              "a.GetValueOrDefault() == b.GetValueOrDefault() &amp;&amp; (a.HasValue &amp; b.HasValue)"
            to
              "(a.GetValueOrDefault() == b.GetValueOrDefault()) &amp; (a.HasValue &amp; b.HasValue)"
            so this secondary entry point analyses logic.and as-if it was a short-circuiting &amp;&amp;.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.Lift(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Main entry point for lifting; called by both the expression-transform
            and the block transform.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.CompOrDecimal">
            <summary>
            Represents either non-lifted IL `Comp` or a call to one of the (non-lifted) 6 comparison operators on `System.Decimal`.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.LiftCSharpComparison(ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.CompOrDecimal,ICSharpCode.Decompiler.IL.ComparisonKind)">
            <summary>
            Lift a C# comparison.
            This method cannot be used for (in)equality comparisons where both sides are nullable
            (these special cases are handled in LiftCSharpEqualityComparison instead).
            
            The output instructions should evaluate to <c>false</c> when any of the <c>nullableVars</c> is <c>null</c>
              (except for newComparisonKind==Inequality, where this case should evaluate to <c>true</c> instead).
            Otherwise, the output instruction should evaluate to the same value as the input instruction.
            The output instruction should have the same side-effects (incl. exceptions being thrown) as the input instruction.
            This means unlike LiftNormal(), we cannot rely on the input instruction not being evaluated if
            a variable is <c>null</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.LiftNormal(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Performs nullable lifting.
            
            Produces a lifted instruction with semantics equivalent to:
              (v1 != null &amp;&amp; ... &amp;&amp; vn != null) ? trueInst : falseInst,
            where the v1,...,vn are the <c>this.nullableVars</c>.
            If lifting fails, returns <c>null</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.DoLift(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Recursive function that lifts the specified instruction.
            The input instruction is expected to a subexpression of the trueInst
            (so that all nullableVars are guaranteed non-null within this expression).
            
            Creates a new lifted instruction without modifying the input instruction.
            On success, returns (new lifted instruction, bitset).
            If lifting fails, returns (null, null).
            
            The returned bitset specifies which nullableVars were considered "relevant" for this instruction.
            bitSet[i] == true means nullableVars[i] was relevant.
            
            The new lifted instruction will have equivalent semantics to the input instruction
            if all relevant variables are non-null [except that the result will be wrapped in a Nullable{T} struct].
            If any relevant variable is null, the new instruction is guaranteed to evaluate to <c>null</c>
            without having any other effect.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchHasValueCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches 'call get_HasValue(arg)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchHasValueCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Matches 'call get_HasValue(ldloca v)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchHasValueCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Matches 'call get_HasValue(ldloca v)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchNegatedHasValueCall(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Matches 'logic.not(call get_HasValue(ldloca v))'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchNullableCtor(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.IType@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches 'newobj Nullable{underlyingType}.ctor(arg)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchGetValueOrDefault(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches 'call Nullable{T}.GetValueOrDefault(arg)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchGetValueOrDefault(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Matches 'call Nullable{T}.GetValueOrDefault(ldloca v)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform.MatchGetValueOrDefault(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Matches 'call Nullable{T}.GetValueOrDefault(ldloca v)'
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.NullCoalescingTransform">
            <summary>
            Transform for constructing the NullCoalescingInstruction (if.notnull(a,b), or in C#: ??)
            Note that this transform only handles the case where a,b are reference types.
            
            The ?? operator for nullable value types is handled by NullableLiftingTransform.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullCoalescingTransform.TransformRefTypes(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)">
            <summary>
            Handles NullCoalescingInstruction case 1: reference types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.NullCoalescingTransform.TransformThrowExpressionValueTypes(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)">
            <summary>
            stloc v(value)
            if (logic.not(call get_HasValue(ldloca v))) throw(...)
            ... Call(arg1, arg2, call GetValueOrDefault(ldloca v), arg4) ...
            =>
            ... Call(arg1, arg2, if.notnull(value, throw(...)), arg4) ...
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.IStatementTransform">
            <summary>
            IL transform that runs on a sequence of statements within a block.
            </summary>
            <remarks>
            Interleaving different statement-combining transforms on a per-statement level
            improves detection of nested constructs.
            For example, array initializers can assume that each element assignment was already
            reduced to a single statement, even if the element contains a high-level construct
            detected by a different transform (e.g. object initializer).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)">
            <summary>
            Runs the transform on the statements within a block.
            
            Note: the transform may only modify block.Instructions[pos..].
            The transform will be called repeatedly for pos=block.Instructions.Count-1, pos=block.Instructions.Count-2, ..., pos=0.
            </summary>
            <param name="block">The current block.</param>
            <param name="pos">The starting position where the transform is allowed to work.</param>
            <param name="context">Additional parameters.</param>
            <remarks>
            Instructions prior to block.Instructions[pos] must not be modified.
            It is valid to read such instructions, but not recommended as those have not been transformed yet.
            
            This function is only called on control-flow blocks with unreachable end-point.
            Thus, the last instruction in the block always must have the EndPointUnreachable flag.
            ==> Instructions with reachable end can't be last. Some transforms use this to save some bounds checks.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext">
            <summary>
            Parameter class holding various arguments for <see cref="M:ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext.Block">
            <summary>
            Gets the block on which the transform is running.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext.RequestRerun(System.Int32)">
            <summary>
            After the current statement transform has completed,
            do not continue with the next statement transform at the same position.
            Instead, re-run all statement transforms (including the current transform) starting at the specified position.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext.RequestRerun">
            <summary>
            After the current statement transform has completed,
            repeat all statement transforms on the current position.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.StatementTransform">
            <summary>
            Block transform that runs a list of statement transforms.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.TransformCollectionAndObjectInitializers">
            <summary>
            Transforms collection and object initialization patterns.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.IBlockTransform">
            <summary>
            Per-block IL transform.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.IBlockTransform.Run(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext)">
            <summary>
            Runs the transform on the specified block.
            
            Note: the transform may only modify the specified block and its descendants,
            as well as any sibling blocks that are dominated by the specified block.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext">
            <summary>
            Parameter class holding various arguments for <see cref="M:ICSharpCode.Decompiler.IL.Transforms.IBlockTransform.Run(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext)"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext.Block">
            <summary>
            The block to process.
            </summary>
            <remarks>
            Should be identical to the <c>block</c> parameter to <c>IBlockTransform.Run</c>.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext.ControlFlowNode">
            <summary>
            The control flow node corresponding to the block being processed.
            </summary>
            <remarks>
            Identical to <c>ControlFlowGraph.GetNode(Block)</c>.
            Note: the control flow graph is not up-to-date, but was created at the start of the
            block transforms (before loop detection).
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext.ControlFlowGraph">
            <summary>
            Gets the control flow graph.
            
            Note: the control flow graph is not up-to-date, but was created at the start of the
            block transforms (before loop detection).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.BlockILTransform">
            <summary>
            IL transform that runs a list of per-block transforms.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.CachedDelegateInitialization.CachedDelegateInitializationWithField(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            if (comp(ldsfld CachedAnonMethodDelegate == ldnull)) {
                stsfld CachedAnonMethodDelegate(DelegateConstruction)
            }
            ... one usage of CachedAnonMethodDelegate ...
            =>
            ... one usage of DelegateConstruction ...
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.CachedDelegateInitialization.CachedDelegateInitializationWithLocal(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            if (comp(ldloc v == ldnull)) {
                stloc v(DelegateConstruction)
            }
            =>
            stloc v(DelegateConstruction)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.CachedDelegateInitialization.CachedDelegateInitializationRoslynInStaticWithLocal(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            stloc s(ldobj(ldsflda(CachedAnonMethodDelegate))
            if (comp(ldloc s == null)) {
            	stloc s(stobj(ldsflda(CachedAnonMethodDelegate), DelegateConstruction))
            }
            =>
            stloc s(DelegateConstruction)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.CachedDelegateInitialization.CachedDelegateInitializationRoslynWithLocal(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            stloc s(ldobj(ldflda(CachedAnonMethodDelegate))
            if (comp(ldloc s == null)) {
            	stloc s(stobj(ldflda(CachedAnonMethodDelegate), DelegateConstruction))
            }
            =>
            stloc s(DelegateConstruction)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.CopyPropagation">
            <summary>
            Runs a very simple form of copy propagation.
            Copy propagation is used in two cases:
            1) assignments from arguments to local variables
               If the target variable is assigned to only once (so always is that argument) and the argument is never changed (no ldarga/starg),
               then we can replace the variable with the argument.
            2) assignments of address-loading instructions to local variables
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.IILTransform">
            <summary>
            Per-function IL transform.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.ILTransformContext">
            <summary>
            Parameter class holding various arguments for <see cref="M:ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILTransformContext.CreateILReader">
            <summary>
            Creates a new ILReader instance for decompiling another method in the same assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILTransformContext.Step(System.String,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Call this method immediately before performing a transform step.
            Unlike <c>context.Stepper.Step()</c>, calls to this method are only compiled in debug builds.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.ILInlining">
            <summary>
            Performs inlining transformations.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.InlineInto(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.InliningOptions,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Inlines instructions before pos into block.Instructions[pos].
            </summary>
            <returns>The number of instructions that were inlined.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.InlineIfPossible(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Aggressively inlines the stloc instruction at block.Body[pos] into the next instruction, if possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.InlineOneIfPossible(ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.Transforms.InliningOptions,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Inlines the stloc instruction at block.Instructions[pos] into the next instruction, if possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.InlineOne(ICSharpCode.Decompiler.IL.StLoc,ICSharpCode.Decompiler.IL.Transforms.InliningOptions,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Inlines the stloc instruction at block.Instructions[pos] into the next instruction.
            
            Note that this method does not check whether 'v' has only one use;
            the caller is expected to validate whether inlining 'v' has any effects on other uses of 'v'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.DoInline(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.InliningOptions,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Inlines 'expr' into 'next', if possible.
            
            Note that this method does not check whether 'v' has only one use;
            the caller is expected to validate whether inlining 'v' has any effects on other uses of 'v'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.IsGeneratedValueTypeTemporary(ICSharpCode.Decompiler.IL.LdLoca,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Is this a temporary variable generated by the C# compiler for instance method calls on value type values
            </summary>
            <param name="loadInst">The load instruction (a descendant within 'next')</param>
            <param name="v">The variable being inlined.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.ClassifyExpression(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether the instruction, when converted into C#, turns into an l-value that can
            be used to mutate a value-type.
            If this function returns false, the C# compiler would introduce a temporary copy
            when calling a method on a value-type (and any mutations performed by the method will be lost)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.NonAggressiveInlineInto(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResult,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Determines whether a variable should be inlined in non-aggressive mode, even though it is not a generated variable.
            </summary>
            <param name="next">The next top-level expression</param>
            <param name="v">The variable being eliminated by inlining.</param>
            <param name="inlinedExpression">The expression being inlined</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.CanInlineInto(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether 'expressionBeingMoved' can be inlined into 'expr'.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResultType.Found">
            <summary>
            Found a load; inlining is possible.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResultType.Stop">
            <summary>
            Load not found and re-ordering not possible. Stop the search.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResultType.Continue">
            <summary>
            Load not found, but the expressionBeingMoved can be re-ordered with regards to the
            tested expression, so we may continue searching for the matching load.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResultType.NamedArgument">
            <summary>
            Found a load in call, but re-ordering not possible with regards to the
            other call arguments.
            Inlining is not possible, but we might convert the call to named arguments.
            Only used with <see cref="F:ICSharpCode.Decompiler.IL.Transforms.InliningOptions.IntroduceNamedArguments"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindResultType.Deconstruction">
            <summary>
            Found a deconstruction.
            Only used with <see cref="F:ICSharpCode.Decompiler.IL.Transforms.InliningOptions.FindDeconstruction"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindLoadInNext(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.InliningOptions)">
            <summary>
            Finds the position to inline to.
            </summary>
            <returns>true = found; false = cannot continue search; null = not found</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.IsSafeForInlineOver(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Determines whether it is safe to move 'expressionBeingMoved' past 'expr'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.FindFirstInlinedCall(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Finds the first call instruction within the instructions that were inlined into inst.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.CanMoveInto(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether 'expressionBeingMoved' can be moved from somewhere before 'stmt' to become the replacement of 'targetLoad'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ILInlining.CanUninline(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether arg can be un-inlined out of stmt.
            </summary>
            <seealso cref="M:ICSharpCode.Decompiler.IL.ILInstruction.Extract"/>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms">
            <summary>
            Collection of transforms that detect simple expression patterns
            (e.g. 'cgt.un(..., ld.null)') and replace them with different instructions.
            </summary>
            <remarks>
            Should run after inlining so that the expression patterns can be detected.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.TransformDelegateCtorLdVirtFtnToLdVirtDelegate(ICSharpCode.Decompiler.IL.NewObj,ICSharpCode.Decompiler.IL.LdVirtDelegate@)">
            <summary>
            newobj Delegate..ctor(target, ldvirtftn TargetMethod(target))
            =>
            ldvirtdelegate System.Delegate TargetMethod(target)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.TransformSpanTCtorContainingStackAlloc(ICSharpCode.Decompiler.IL.NewObj,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            newobj Span..ctor(localloc(conv i4->u &lt;zero extend&gt;(ldc.i4 sizeInBytes)), numberOfElementsExpr)
            =>
            localloc.span T(numberOfElementsExpr)
            
            -or-
            
            newobj Span..ctor(Block IL_0000 (StackAllocInitializer) {
            	stloc I_0(localloc(conv i4->u&lt;zero extend>(ldc.i4 sizeInBytes)))
            	...
            	final: ldloc I_0
            }, numberOfElementsExpr)
            =>
            Block IL_0000 (StackAllocInitializer) {
            	stloc I_0(localloc.span T(numberOfElementsExpr))
            	...
            	final: ldloc I_0
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.TransformDynamicAddAssignOrRemoveAssign(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            op is either add or remove/subtract:
            if (dynamic.isevent (target)) {
                dynamic.invokemember.invokespecial.discard op_Name(target, value)
            } else {
                dynamic.compound.op (dynamic.getmember Name(target), value)
            }
            =>
            dynamic.compound.op (dynamic.getmember Name(target), value)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.VisitDynamicSetMemberInstruction(ICSharpCode.Decompiler.IL.DynamicSetMemberInstruction)">
            <summary>
            dynamic.setmember.compound Name(target, dynamic.binary.operator op(dynamic.getmember Name(target), value))
            =>
            dynamic.compound.op (dynamic.getmember Name(target), value)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.VisitDynamicSetIndexInstruction(ICSharpCode.Decompiler.IL.DynamicSetIndexInstruction)">
            <summary>
            dynamic.setindex.compound(target, index, dynamic.binary.operator op(dynamic.getindex(target, index), value))
            =>
            dynamic.compound.op (dynamic.getindex(target, index), value)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.TransformCatchVariable(ICSharpCode.Decompiler.IL.TryCatchHandler,ICSharpCode.Decompiler.IL.Block,System.Boolean)">
            <summary>
            catch ex : TException when (...) BlockContainer {
            	Block entryPoint (incoming: 1) {
            		stloc v(ldloc ex)
            		...
            	}
            }
            =>
            catch v : TException when (...) BlockContainer {
            	Block entryPoint (incoming: 1) {
            		...
            	}
            }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms.TransformCatchWhen(ICSharpCode.Decompiler.IL.TryCatchHandler,ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Inline condition from catch-when condition BlockContainer, if possible.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.DelegateConstruction">
            <summary>
            Transforms anonymous methods and lambdas by creating nested ILFunctions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.DelegateConstruction.ReplaceDelegateTargetVisitor">
            <summary>
            Replaces loads of 'this' with the target expression.
            Async delegates use: ldobj(ldloca this).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.RemoveDeadVariableInit">
            <summary>
            Remove <c>HasInitialValue</c> from locals that are definitely assigned before every use
            (=the initial value is a dead store).
            
            In yield return generators, additionally removes dead 'V = null;' assignments.
            
            Additionally infers IType of stack slots that have StackType.Ref
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.SplitVariables">
            <summary>
            Live range splitting for IL variables.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.AddressUse.Immediate">
            <summary>
            Address is immediately used for reading and/or writing,
            without the possibility of the variable being directly stored to (via 'stloc')
            in between the 'ldloca' and the use of the address.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.AddressUse.WithSupportedRefLocals">
            <summary>
            We support some limited form of ref locals referring to a target variable,
            without giving up splitting of the target variable.
            Requirements:
             * the ref local is single-assignment
             * the ref local is initialized directly with 'ldloca target; stloc ref_local',
                  not a derived pointer (e.g. 'ldloca target; ldflda F; stloc ref_local').
             * all uses of the ref_local are immediate.
            There may be stores to the target variable in between the 'stloc ref_local' and its uses,
            but we handle that case by treating each use of the ref_local as an address access
            of the target variable (as if the ref_local was eliminated via copy propagation).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.GetAddressLoadForRefLocalUse(ICSharpCode.Decompiler.IL.LdLoc)">
            <summary>
            Given 'ldloc ref_local' and 'ldloca target; stloc ref_local', returns the ldloca.
            This function must return a non-null LdLoca for every use of a SupportedRefLocal.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.GroupStores">
            <summary>
            Use the union-find structure to merge
            </summary>
            <remarks>
            Instructions in a group are stores to the same variable that must stay together (cannot be split).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.GroupStores.uninitVariableUsage">
            <summary>
            For each uninitialized variable, one representative instruction that
            potentially observes the unintialized value of the variable.
            Used to merge together all such loads of the same uninitialized value.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.SplitVariables.GroupStores.GetNewVariable(ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand)">
            <summary>
            Gets the new variable for a LdLoc, StLoc or TryCatchHandler instruction.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.StepLimitReachedException">
            <summary>
            Exception thrown when an IL transform runs into the <see cref="P:ICSharpCode.Decompiler.IL.Transforms.Stepper.StepLimit"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.Stepper">
            <summary>
            Helper class that manages recording transform steps.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.Stepper.SteppingAvailable">
            <summary>
            Gets whether stepping of built-in transforms is supported in this build of ICSharpCode.Decompiler.
            Usually only debug builds support transform stepping.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.Stepper.Node.BeginStep">
            <summary>
            BeginStep is inclusive.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Transforms.Stepper.Node.EndStep">
            <summary>
            EndStep is exclusive.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.Stepper.Step(System.String,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Call this method immediately before performing a transform step.
            Used for debugging the IL transforms. Has no effect in release mode.
            
            May throw <see cref="T:ICSharpCode.Decompiler.IL.Transforms.StepLimitReachedException"/> in debug mode.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.TransformArrayInitializers">
            <summary>
            Transforms array initialization pattern of System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray.
            For collection and object initializers see <see cref="T:ICSharpCode.Decompiler.IL.Transforms.TransformCollectionAndObjectInitializers"/>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformArrayInitializers.HandleSimpleArrayInitializer(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.IL.Block,System.Int32,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.TypeSystem.IType,System.Int32[],System.ValueTuple{ICSharpCode.Decompiler.IL.ILInstruction[],ICSharpCode.Decompiler.IL.ILInstruction}[]@,System.Int32@)">
            <summary>
            Handle simple case where RuntimeHelpers.InitializeArray is not used.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformArrayInitializers.DoTransformInlineRuntimeHelpersInitializeArray(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <summary>
            call InitializeArray(newarr T(size), ldmembertoken fieldToken)
            =>
            Block (ArrayInitializer) {
            	stloc i(newarr T(size))
            	stobj T(ldelema T(... indices ...), value)
            	final: ldloc i
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment">
            <summary>
            Constructs compound assignments and inline assignments.
            </summary>
            <remarks>
            This is a statement transform;
            but some portions are executed as an expression transform instead
            (with HandleCompoundAssign() as entry point)
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.TransformInlineAssignmentStObjOrCall(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <code>
            stloc s(value)
            stloc l(ldloc s)
            stobj(..., ldloc s)
              where ... is pure and does not use s or l,
              and where neither the 'stloc s' nor the 'stobj' truncates
            -->
            stloc l(stobj (..., value))
            </code>
            e.g. used for inline assignment to instance field
            
            -or-
            
            <code>
            stloc s(value)
            stobj (..., ldloc s)
              where ... is pure and does not use s, and where the 'stobj' does not truncate
            -->
            stloc s(stobj (..., value))
            </code>
            e.g. used for inline assignment to static field
            
            -or-
            
            <code>
            stloc s(value)
            call set_Property(..., ldloc s)
              where the '...' arguments are pure and not using 's'
            -->
            stloc s(Block InlineAssign { call set_Property(..., stloc i(value)); final: ldloc i })
              new temporary 'i' has type of the property; transform only valid if 'stloc i' doesn't truncate
            </code>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.HandleCompoundAssign(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext)">
            <summary>
            Transform compound assignments where the return value is not being used,
            or where there's an inlined assignment within the setter call.
            
            Patterns handled:
            1.
              callvirt set_Property(ldloc S_1, binary.op(callvirt get_Property(ldloc S_1), value))
              ==> compound.op.new(callvirt get_Property(ldloc S_1), value)
            2.
              callvirt set_Property(ldloc S_1, stloc v(binary.op(callvirt get_Property(ldloc S_1), value)))
              ==> stloc v(compound.op.new(callvirt get_Property(ldloc S_1), value))
            3.
              stobj(target, binary.op(ldobj(target), ...))
                where target is pure
              => compound.op(target, ...)
            </summary>
            <remarks>
            Called by ExpressionTransforms, or after the inline-assignment transform for setters.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.TransformInlineAssignmentLocal(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <code>
            stloc s(value)
            stloc l(ldloc s)
              where neither 'stloc s' nor 'stloc l' truncates the value
            -->
            stloc s(stloc l(value))
            </code>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.IsImplicitTruncation(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.ICompilation,System.Boolean)">
            <summary>
            Gets whether 'stobj type(..., value)' would evaluate to a different value than 'value'
            due to implicit truncation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.IsCompoundStore(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.IType@,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Gets whether 'inst' is a possible store for use as a compound store.
            </summary>
            <remarks>
            Output parameters:
            storeType: The type of the value being stored.
            value: The value being stored (will be analyzed further to detect compound assignments)
            
            Every IsCompoundStore() call should be followed by an IsMatchingCompoundLoad() call.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.IsMatchingCompoundLoad(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.CompoundTargetKind@,System.Action{ICSharpCode.Decompiler.IL.Transforms.ILTransformContext}@,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Checks whether 'load' and 'store' both access the same store, and can be combined to a compound assignment.
            </summary>
            <param name="load">The load instruction to test.</param>
            <param name="store">The compound store to test against. Must have previously been tested via IsCompoundStore()</param>
            <param name="target">The target to use for the compound assignment instruction.</param>
            <param name="targetKind">The target kind to use for the compound assignment instruction.</param>
            <param name="finalizeMatch">If set to a non-null value, call this delegate to fix up minor mismatches between getter and setter.</param>
            <param name="forbiddenVariable">
            If given a non-null value, this function returns false if the forbiddenVariable is used in the load/store instructions.
            Some transforms effectively move a store around,
            which is only valid if the variable stored to does not occur in the compound load/store.
            </param>
            <param name="previousInstruction">
            Instruction preceding the load.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.TransformPostIncDecOperatorWithInlineStore(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <code>
            stobj(target, binary.add(stloc l(ldobj(target)), ldc.i4 1))
              where target is pure and does not use 'l', and the 'stloc l' does not truncate
            -->
            stloc l(compound.op.old(ldobj(target), ldc.i4 1))
            
             -or-
            
            call set_Prop(args..., binary.add(stloc l(call get_Prop(args...)), ldc.i4 1))
              where args.. are pure and do not use 'l', and the 'stloc l' does not truncate
            -->
            stloc l(compound.op.old(call get_Prop(target), ldc.i4 1))
            </code>
            <remarks>
            This pattern is used for post-increment by legacy csc.
            
            Even though this transform operates only on a single expression, it's not an expression transform
            as the result value of the expression changes (this is OK only for statements in a block).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Transforms.TransformAssignment.TransformPostIncDecOperator(ICSharpCode.Decompiler.IL.Block,System.Int32)">
            <code>
            stloc tmp(ldobj(target))
            stobj(target, binary.op(ldloc tmp, ldc.i4 1))
              target is pure and does not use 'tmp', 'stloc does not truncate'
            -->
            stloc tmp(compound.op.old(ldobj(target), ldc.i4 1))
            </code>
            This is usually followed by inlining or eliminating 'tmp'.
            
            Local variables use a similar pattern, also detected by this function:
            <code>
            stloc tmp(ldloc target)
            stloc target(binary.op(ldloc tmp, ldc.i4 1))
            -->
            stloc tmp(compound.op.old(ldloca target, ldc.i4 1))
            </code>
            <remarks>
            This pattern occurs with legacy csc for static fields, and with Roslyn for most post-increments.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DeconstructInstruction">
            <summary>Deconstruction statement</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DeconstructResultInstruction">
            <summary>Represents a deconstructed value</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.MatchInstruction">
            <summary>ILAst representation of C# patterns</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.MatchInstruction.IsPatternMatch(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Checks whether the input instruction can represent a pattern matching operation.
            
            Any pattern matching instruction will first evaluate the `testedOperand` (a descendant of `inst`),
            and then match the value of that operand against the pattern encoded in the instruction.
            The matching may have side-effects on the newly-initialized pattern variables
            (even if the pattern fails to match!).
            The pattern matching instruction evaluates to 1 (as I4) if the pattern matches, or 0 otherwise.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.MatchInstruction.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AwaitInFinallyTransform.MatchExceptionCaptureBlock(ICSharpCode.Decompiler.IL.StLoc,ICSharpCode.Decompiler.IL.Block@,ICSharpCode.Decompiler.IL.Block@,System.Collections.Generic.List{ICSharpCode.Decompiler.IL.Block}@)">
            <summary>
            Block finallyHead (incoming: 2) {
            	[body of finally]
            	stloc V_4(ldloc V_1)
            	if (comp(ldloc V_4 == ldnull)) br afterFinally
            	br typeCheckBlock
            }
            
            Block typeCheckBlock (incoming: 1) {
            	stloc S_110(isinst System.Exception(ldloc V_4))
            	if (comp(ldloc S_110 != ldnull)) br captureBlock
            	br throwBlock
            }
            
            Block throwBlock (incoming: 1) {
            	throw(ldloc V_4)
            }
            
            Block captureBlock (incoming: 1) {
            	callvirt Throw(call Capture(ldloc S_110))
            	br afterFinally
            }
            
            Block afterFinally (incoming: 2) {
            	stloc V_1(ldnull)
            	[after finally]
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler">
            <summary>
            Decompiler step for C# 5 async/await.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.MatchCall(ICSharpCode.Decompiler.IL.ILInstruction,System.String,ICSharpCode.Decompiler.IL.InstructionCollection{ICSharpCode.Decompiler.IL.ILInstruction}@)">
            <summary>
            Matches a (potentially virtual) instance method call.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.MatchStFld(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.TypeSystem.IField@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches a store to the state machine.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.AnalyzeMoveNext">
            <summary>
            First peek into MoveNext(); analyzes everything outside the big try-catch.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.AnalyzeDisposeAsync">
            <summary>
            Analyse the DisposeAsync() method in order to find the disposeModeField.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.AnalyzeStateMachine(ICSharpCode.Decompiler.IL.ILFunction)">
            <summary>
            Analyze the the state machine; and replace 'leave IL_0000' with await+jump to block that gets
            entered on the next MoveNext() call.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler.CleanDoFinallyBodies(ICSharpCode.Decompiler.IL.ILFunction)">
            <summary>
            Eliminates usage of doFinallyBodies
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AwaitInCatchTransform.AnalyzeHandlers(ICSharpCode.Decompiler.IL.InstructionCollection{ICSharpCode.Decompiler.IL.TryCatchHandler},ICSharpCode.Decompiler.IL.ILVariable@,System.Collections.Generic.List{System.ValueTuple{System.Int32,ICSharpCode.Decompiler.IL.TryCatchHandler,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.IfInstruction,ICSharpCode.Decompiler.IL.StLoc}}@)">
            <summary>
            Analyzes all catch handlers and returns every handler that follows the await catch handler pattern.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.AwaitInCatchTransform.MatchAwaitCatchHandler(ICSharpCode.Decompiler.IL.BlockContainer,System.Int32@,ICSharpCode.Decompiler.IL.ILVariable@,ICSharpCode.Decompiler.IL.Block@,ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.IfInstruction@,ICSharpCode.Decompiler.IL.StLoc@)">
            <summary>
            Matches the await catch handler pattern:
            stloc V_3(ldloc E_100)	- copy exception variable to a temporary
            stloc V_6(ldloc V_3)	- store exception in 'global' object variable
            stloc V_5(ldc.i4 2)		- store id of catch block in 'identifierVariable'
            br IL_0075				- jump out of catch block to the head of the catch-handler jump table
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.currentType">
            <summary>The type that contains the function being decompiled.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.enumeratorType">
            <summary>The compiler-generated enumerator class.</summary>
            <remarks>Set in MatchEnumeratorCreationPattern()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.enumeratorCtor">
            <summary>The constructor of the compiler-generated enumerator class.</summary>
            <remarks>Set in MatchEnumeratorCreationPattern()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.isCompiledWithMono">
            <remarks>Set in MatchEnumeratorCreationPattern()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.disposeMethod">
            <summary>The dispose method of the compiler-generated enumerator class.</summary>
            <remarks>Set in ConstructExceptionTable()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.stateField">
            <summary>The field in the compiler-generated class holding the current state of the state machine</summary>
            <remarks>Set in AnalyzeCtor() for MS, MatchEnumeratorCreationPattern() or AnalyzeMoveNext() for Mono</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.currentField">
            <summary>The backing field of the 'Current' property in the compiler-generated class</summary>
            <remarks>Set in AnalyzeCurrentProperty()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.disposingField">
            <summary>The disposing field of the compiler-generated enumerator class.</summary>
            <remarks>Set in ConstructExceptionTable() for assembly compiled with Mono</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.fieldToParameterMap">
            <summary>Maps the fields of the compiler-generated class to the original parameters.</summary>
            <remarks>Set in MatchEnumeratorCreationPattern() and ResolveIEnumerableIEnumeratorFieldMapping()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.finallyMethodToStateRange">
            <summary>This dictionary stores the information extracted from the Dispose() method:
            for each "Finally Method", it stores the set of states for which the method is being called.</summary>
            <remarks>Set in ConstructExceptionTable()</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.decompiledFinallyMethods">
            <summary>
            For each finally method, stores the target state when entering the finally block,
            and the decompiled code of the finally method body.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.returnStores">
            <summary>
            Temporary stores for 'yield break'.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.skipFinallyBodies">
            <summary>
            Local bool variable in MoveNext() that signifies whether to skip finally bodies.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.cachedStateVars">
            <summary>
            Set of variables might hold copies of the generated state field.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.SingleBlock(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Matches the body of a method as a single basic block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.MatchEnumeratorCreationNewObj(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Matches the newobj instruction that creates an instance of the compiler-generated enumerator helper class.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.AnalyzeCtor">
            <summary>
            Looks at the enumerator's ctor and figures out which of the fields holds the state.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.CreateILAst(System.Reflection.Metadata.MethodDefinitionHandle,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Creates ILAst for the specified method, optimized up to before the 'YieldReturn' step.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.AnalyzeCurrentProperty">
            <summary>
            Looks at the enumerator's get_Current method and figures out which of the fields holds the current value.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.ConvertBody(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis)">
            <summary>
            Convert the old body (of MoveNext function) to the new body (of decompiled iterator method).
            
            * Replace the sequence
                  this.currentField = expr;
                  this.state = N;
                  return true;
                with:
                  yield return expr;
                  goto blockForState(N);
             * Replace the sequence:
                  this._finally2();
                  this._finally1();
                  return false;
                with:
                  yield break;
             * Reconstruct try-finally blocks from
                 (on enter) this.state = N;
                 (on exit)  this._finallyX();
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.TranslateFieldsToLocalAccess(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.IL.ILInstruction,System.Collections.Generic.Dictionary{ICSharpCode.Decompiler.TypeSystem.IField,ICSharpCode.Decompiler.IL.ILVariable},System.Boolean)">
            <summary>
            Translates all field accesses in `function` to local variable accesses.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.ReconstructTryFinallyBlocks(ICSharpCode.Decompiler.IL.ILFunction)">
            <summary>
            Reconstruct try-finally blocks.
            * The stateChanges (iterator._state = N;) tell us when to open a try-finally block
            * The calls to the finally method tell us when to leave the try block.
            
            There might be multiple stateChanges for a given try-finally block, e.g.
            both the original entry point, and the target when leaving a nested block.
            In proper C# code, the entry point of the try-finally will dominate all other code
            in the try-block, so we can use dominance to find the proper entry point.
            
            Precondition: the blocks in newBody are topologically sorted.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler.CleanSkipFinallyBodies(ICSharpCode.Decompiler.IL.ILFunction)">
            <summary>
            Eliminates usage of doFinallyBodies
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph">
            <summary>
            Holds the control flow graph.
            A separate graph is computed for each BlockContainer at the start of the block transforms
            (before loop detection).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.Container">
            <summary>
            The container for which the ControlFlowGraph was created.
            
            This may differ from the container currently holding a block,
            because a transform could have moved the block since the CFG was created.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.cfg">
            <summary>
            Nodes array, indexed by original block index.
            
            Originally <c>cfg[i].UserData == container.Blocks[i]</c>,
            but the ILAst blocks may be moved/reordered by transforms.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.dict">
            <summary>
            Dictionary from Block to ControlFlowNode.
            Unlike the cfg array, this can be used to discover control flow nodes even after
            blocks were moved/reordered by transforms.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.nodeHasDirectExitOutOfContainer">
            <summary>
            nodeHasDirectExitOutOfContainer[i] == true iff cfg[i] directly contains a
            branch/leave instruction leaving the <c>container</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.nodeHasReachableExit">
            <summary>
            nodeHasReachableExit[i] == true iff there is a path from cfg[i] to a node not dominated by cfg[i],
            or if there is a path from cfg[i] to a branch/leave instruction leaving the <c>container</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.#ctor(ICSharpCode.Decompiler.IL.BlockContainer,System.Threading.CancellationToken)">
            <summary>
            Constructs a control flow graph for the blocks in the given block container.
            
            Return statements, exceptions, or branches leaving the block container are not
            modeled by the control flow graph.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.GetNode(ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Gets the ControlFlowNode for the block.
            
            Precondition: the block belonged to the <c>container</c> at the start of the block transforms
            (when the control flow graph was created).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.HasReachableExit(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Returns true iff there is a control flow path from <c>node</c> to one of the following:
             * branch or leave instruction leaving <c>this.Container</c>
             * branch instruction within this container to another node that is not dominated by <c>node</c>.
            
            If this function returns false, the only way control flow can leave the set of nodes
            dominated by <c>node</c> is by executing a <c>return</c> or <c>throw</c> instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph.HasDirectExitOutOfContainer(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Gets whether the control flow node directly contains a branch/leave instruction
            exiting the container.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis">
            <summary>
            Symbolically executes code to determine which blocks are reachable for which values
            of the 'state' field.
            </summary>
            <remarks>
            Assumption: there are no loops/backward jumps
            We 'run' the code, with "state" being a symbolic variable
            so it can form expressions like "state + x" (when there's a sub instruction)
            
            For each block, we maintain the set of values for state for which the block is reachable.
            This is (int.MinValue, int.MaxValue) for the first instruction.
            These ranges are propagated depending on the conditional jumps performed by the code.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis.CreateNestedAnalysis">
            <summary>
            Creates a new StateRangeAnalysis with the same settings, including any cached state vars
            discovered by this analysis.
            However, the new analysis has a fresh set of result ranges.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis.AssignStateRanges(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.Util.LongSet)">
            <summary>
            Assign state ranges for all blocks within 'inst'.
            </summary>
            <returns>
            The set of states for which the exit point of the instruction is reached.
            This must be a subset of the input set.
            
            Returns an empty set for unsupported instructions.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis.GetBlockStateSetMapping(ICSharpCode.Decompiler.IL.BlockContainer)">
            <summary>
            Gets a mapping from states to blocks.
            
            Within the given container (which should be the container that was analyzed),
            the mapping prefers the last block.
            Blocks outside of the given container are preferred over blocks within the container.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicAnalysisFailedException">
            <summary>
            This exception is thrown when we find something else than we expect from the C# compiler.
            This aborts the analysis and makes the whole transform fail.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType.Unknown">
            <summary>
            Unknown value
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType.IntegerConstant">
            <summary>
            int: Constant (result of ldc.i4)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType.State">
            <summary>
            int: State + Constant
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType.This">
            <summary>
            This pointer (result of ldarg.0)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType.StateInSet">
            <summary>
            bool: ValueSet.Contains(State)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection">
            <summary>
            Detects 'if' structure and other non-loop aspects of control flow.
            </summary>
            <remarks>
            Order dependency: should run after loop detection.
            Blocks should be basic blocks prior to this transform.
            After this transform, they will be extended basic blocks.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.Run(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext)">
            <summary>
            Builds structured control flow for the block associated with the control flow node.
            </summary>
            <remarks>
            After a block was processed, it should use structured control flow
            and have just a single 'regular' exit point (last branch instruction in the block)
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.HandleIfInstruction(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            Repeatedly inlines and simplifies, maintaining a good block exit and then attempting to match IL order
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.InlineTrueBranch(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
              if (...) br trueBlock;
            ->
              if (...) { trueBlock... }
            
            Only inlines branches that are strictly dominated by this block (incoming edge count == 1)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.InlineExitBranch(ICSharpCode.Decompiler.IL.Block)">
            <summary>
              ...; br nextBlock;
            ->
              ...; { nextBlock... }
            
            Only inlines branches that are strictly dominated by this block (incoming edge count == 1)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.CanInline(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether <c>potentialBranchInstruction</c> is a branch to a block that is dominated by <c>cfgNode</c>.
            If this function returns true, we replace the branch instruction with the block itself.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.MergeCommonBranches(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            Looks for common exits in the inlined then and else branches of an if instruction
            and performs inversions and simplifications to merge them provided they don't 
            isolate a higher priority block exit
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.AddExits(ICSharpCode.Decompiler.IL.ILInstruction,System.Int32,System.Collections.Generic.IList{ICSharpCode.Decompiler.IL.ILInstruction})">
            <summary>
            Finds all exits which could be brought to the block root via inversion
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.ProduceExit(ICSharpCode.Decompiler.IL.ILInstruction,System.Int32,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Recursively performs inversions to bring a desired exit to the root of the block
            for example:
              if (a) {
                ...;
                if (b) {
                  ...;
                  targetExit;
                }
                ...;
                exit1;
              }
              ...;
              exit2;
            ->
              if (!a) {
                ...;
                exit2;
              }
              ...;
              if (!b) {
                ...;
                exit1;
              }
              ...;
              targetExit;
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.WillShortCircuit(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Anticipates the introduction of an || operator when merging ifInst and elseExit
            
              if (cond) commonExit;
              if (cond2) commonExit;
              ...;
              blockExit;
            will become:
              if (cond || cond2) commonExit;
              ...;
              blockExit;
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.InvertIf(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction,ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
              if (cond) { then... }
              else...;
              exit;
            ->
              if (!cond) { else...; exit }
              then...;
            
            Assumes ifInst does not have an else block
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.SwapEmptyThen(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
              if (cond) { } else { ... }
            ->
              if (!cond) { ... }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.IntroduceShortCircuit(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
              if (cond) { if (nestedCond) { nestedThen... } }
            ->
              if (cond &amp;&amp; nestedCond) { nestedThen... }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.OrderIfBlocks(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
              if (cond) { lateBlock... } else { earlyBlock... }
            ->
              if (!cond) { earlyBlock... } else { lateBlock... }
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.PickBetterBlockExit(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            Compares the current block exit, and the exit of ifInst.ThenInst 
            and inverts if necessary to pick the better exit
            
            Does nothing when ifInst has an else block (because inverting wouldn't affect the block exit)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.CompareBlockExitPriority(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction,System.Boolean)">
            <summary>
            Compares two exit instructions for block exit priority
            A higher priority exit should be kept as the last instruction in a block
            even if it prevents the merging of a two compatible lower priority exits
            
            leave from try containers must always be the final instruction, or a goto will be inserted
            loops will endeavour to leave at least one continue branch as the last instruction in the block
            
            The priority is:
              leave > branch > other-keyword > continue > return > break
            
            non-keyword leave instructions are ordered with the outer container having higher priority
            
            if the exits have equal priority, and the <c>strongly</c> flag is not provided
            then the exits are sorted by IL order (target block for branches)
            
            break has higher priority than other keywords in a switch block (for aesthetic reasons)
            </summary>
            <returns>{-1, 0, 1} if exit1 has {lower, equal, higher} priority an exit2</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.IsKeywordExit(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.Keyword@)">
            <summary>
            Determines if an exit instruction has a corresponding keyword and thus doesn't strictly need merging
            Branches can be 'continue' or goto (non-keyword)
            Leave can be 'return', 'break' or a pinned container exit (try/using/lock etc)
            All other instructions (throw, using, etc) are returned as Keyword.Other
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.TryGetExit(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Determine if the specified instruction necessarily exits (EndPointUnreachable)
            and if so return last (or single) exit instruction
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.GetExit(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets the final instruction from a block (or a single instruction) assuming that all blocks
            or instructions in this position have unreachable endpoints
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.IsEmpty(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Returns true if inst is Nop or a Block with no instructions.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.IsContinueBlock(ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Import some pattern matching from HighLevelLoopTransform to guess the continue block of loop containers.
            Used to identify branches targetting this block as continue statements, for ordering priority.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection.ExtractBlock(ICSharpCode.Decompiler.IL.Block,System.Int32,System.Int32)">
            <summary>
            Removes a subrange of instructions from a block and returns them in a new Block
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowSimplification">
            <summary>
            This transform 'optimizes' the control flow logic in the IL code:
            it replaces constructs that are generated by the C# compiler in debug mode
            with shorter constructs that are more straightforward to analyze.
            </summary>
            <remarks>
            The transformations performed are:
            * 'nop' instructions are removed
            * branches that lead to other branches are replaced with branches that directly jump to the destination
            * branches that lead to a 'return block' are replaced with a return instruction
            * basic blocks are combined where possible
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowSimplification.IsDeadTrueStore(ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Returns true if the last two instructions before the branch are storing the value 'true' into an unused variable.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.DetectPinnedRegions">
            <summary>
            IL uses 'pinned locals' to prevent the GC from moving objects.
            
            C#:
            <code>
            fixed (int* s = &amp;arr[index]) { use(s); use(s); }
            </code>
            
            <para>Gets translated into IL:</para>
            <code>
            pinned local P : System.Int32&amp;
            
            stloc(P, ldelema(arr, index))
            call use(conv ref->i(ldloc P))
            call use(conv ref->i(ldloc P))
            stloc(P, conv i4->u(ldc.i4 0))
            </code>
            
            In C#, the only way to pin something is to use a fixed block
            (or to mess around with GCHandles).
            But fixed blocks are scoped, so we need to detect the region affected by the pin.
            To ensure we'll be able to collect all blocks in that region, we perform this transform
            early, before building any other control flow constructs that aren't as critical for correctness.
            
            This means this transform must run before LoopDetection.
            To make our detection job easier, we must run after variable inlining.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.DetectPinnedRegions.SplitBlocksAtWritesToPinnedLocals(ICSharpCode.Decompiler.IL.BlockContainer)">
            <summary>
            Ensures that every write to a pinned local is followed by a branch instruction.
            This ensures the 'pinning region' does not involve any half blocks, which makes it easier to extract.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.DetectPinnedRegions.ProcessPinnedRegion(ICSharpCode.Decompiler.IL.PinnedRegion)">
            <summary>
            After a pinned region was detected; process its body; replacing the pin variable
            with a native pointer as far as possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.DetectPinnedRegions.UseExistingVariableForPinnedRegion(ICSharpCode.Decompiler.IL.PinnedRegion)">
            <summary>
            Modifies a pinned region to eliminate an extra local variable that roslyn tends to generate.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints">
            <summary>
            Detect suitable exit points for BlockContainers.
            
            An "exit point" is an instruction that causes control flow
            to leave the container (a branch or leave instruction).
            
            If an "exit point" instruction is placed immediately following a
            block container, each equivalent exit point within the container
            can be replaced with a "leave container" instruction.
            
            This transform performs this replacement: any exit points
            equivalent to the exit point following the container are
            replaced with a leave instruction.
            Additionally, if the container is not yet followed by an exit point,
            but has room to introduce such an exit point (i.e. iff the container's 
            end point is currently unreachable), we pick one of the non-return
            exit points within the container, move it to the position following the
            container, and replace all instances within the container with a leave
            instruction.
            
            This makes it easier for the following transforms to construct
            control flow that falls out of blocks instead of using goto/break statements.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints.GetExit(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets the next instruction after <paramref name="inst"/> is executed.
            Returns NoExit when the next instruction cannot be identified;
            returns <c>null</c> when the end of a Block is reached (so that we could insert an arbitrary instruction)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints.CompatibleExitInstruction(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Returns true iff exit1 and exit2 are both exit instructions
            (branch or leave) and both represent the same exit.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints.currentExit">
            <summary>
            The instruction that will be executed next after leaving the currentContainer.
            <c>ExitNotYetDetermined</c> means the container is last in its parent block, and thus does not
            yet have any leave instructions. This means we can move any exit instruction of
            our choice our of the container and replace it with a leave instruction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints.potentialExits">
            <summary>
            If <c>currentExit==ExitNotYetDetermined</c>, holds the list of potential exit instructions.
            After the currentContainer was visited completely, one of these will be selected as exit instruction.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection">
            <summary>
            Detect loops in IL AST.
            </summary>
            <remarks>
            Transform ordering:
            * LoopDetection should run before other control flow structures are detected.
            * Blocks should be basic blocks (not extended basic blocks) so that the natural loops
            don't include more instructions than strictly necessary.
            * Loop detection should run after the 'return block' is duplicated (ControlFlowSimplification).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.currentBlockContainer">
            <summary>Block container corresponding to the current cfg.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.isSwitch">
            <summary>
            Enabled during DetectSwitchBody, used by ExtendLoop and children
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.loopContext">
            <summary>
            Used when isSwitch == true, to determine appropriate exit points within loops
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.Run(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext)">
            <summary>
            Check whether 'block' is a loop head; and construct a loop instruction
            (nested BlockContainer) if it is.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.IncludeNestedContainers(System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode})">
            <summary>
            For each block in the input loop that is the head of a nested loop or switch,
            include all blocks from the nested container into the loop.
            
            This ensures that all blocks that were included into inner loops are also
            included into the outer loop, thus keeping our loops well-nested.
            </summary>
            <remarks>
            More details for why this is necessary are here:
            https://github.com/icsharpcode/ILSpy/issues/915
            
            Pre+Post-Condition: node.Visited iff loop.Contains(node)
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.ExtendLoop(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode@)">
            <summary>
            Given a natural loop, add additional CFG nodes to the loop in order
            to reduce the number of exit points out of the loop.
            We do this because C# only allows reaching a single exit point (with 'break'
            statements or when the loop condition evaluates to false), so we'd have
            to introduce 'goto' statements for any additional exit points.
            </summary>
            <remarks>
            Definition:
            A "reachable exit" is a branch/leave target that is reachable from the loop,
            but not dominated by the loop head. A reachable exit may or may not have a
            corresponding CFG node (depending on whether it is a block in the current block container).
              -> reachable exits are leaving the code region dominated by the loop
            
            Definition:
            A loop "exit point" is a CFG node that is not itself part of the loop,
            but has at least one predecessor which is part of the loop.
              -> exit points are leaving the loop itself
            
            Nodes can only be added to the loop if they are dominated by the loop head.
            When adding a node to the loop, we must also add all of that node's predecessors
            to the loop. (this ensures that the loop keeps its single entry point)
            
            Goal: If possible, find a set of nodes that can be added to the loop so that there
            remains only a single exit point.
            Add as little code as possible to the loop to reach this goal.
            
            This means we need to partition the set of nodes dominated by the loop entry point
            into two sets (in-loop and out-of-loop).
            Constraints:
             * the loop head itself is in-loop
             * there must not be any edge from an out-of-loop node to an in-loop node
               -> all predecessors of in-loop nodes are also in-loop
               -> all nodes in a cycle are part of the same partition
            Optimize:
             * use only a single exit point if at all possible
             * minimize the amount of code in the in-loop partition
               (thus: maximize the amount of code in the out-of-loop partition)
            
            Observations:
             * If a node is in-loop, so are all its ancestors in the dominator tree (up to the loop entry point)
             * If there are no exits reachable from a node (i.e. all paths from that node lead to a return/throw instruction),
               it is valid to put the group of nodes dominated by that node into either partition independently of
               any other nodes except for the ancestors in the dominator tree.
                  (exception: the loop head itself must always be in-loop)
            
            There are two different cases we need to consider:
            1) There are no exits reachable at all from the loop head.
               ->  it is possible to create a loop with zero exit points by adding all nodes
                   dominated by the loop to the loop.
               -> the only way to exit the loop is by "return;" or "throw;"
            2) There are some exits reachable from the loop head.
            
            In case 1, we can pick a single exit point freely by picking any node that has no reachable exits
            (other than the loop head).
            All nodes dominated by the exit point are out-of-loop, all other nodes are in-loop.
            See PickExitPoint() for the heuristic that picks the exit point in this case.
            
            In case 2, we need to pick our exit point so that all paths from the loop head
            to the reachable exits run through that exit point.
            
            This is a form of postdominance where the reachable exits are considered exit nodes,
            while "return;" or "throw;" instructions are not considered exit nodes.
            
            Using this form of postdominance, we are looking for an exit point that post-dominates all nodes in the natural loop.
            --> a common ancestor in post-dominator tree.
            To minimize the amount of code in-loop, we pick the lowest common ancestor.
            All nodes dominated by the exit point are out-of-loop, all other nodes are in-loop.
            (using normal dominance as in case 1, not post-dominance!)
            
            If it is impossible to use a single exit point for the loop, the lowest common ancestor will be the fake "exit node"
            used by the post-dominance analysis. In this case, we fall back to the old heuristic algorithm.
            
            Requires and maintains the invariant that a node is marked as visited iff it is contained in the loop.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.NoExitPoint">
            <summary>
            Special control flow node (not part of any graph) that signifies that we want to construct a loop
            without any exit point.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.FindExitPoint(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode})">
            <summary>
            Finds a suitable single exit point for the specified loop.
            </summary>
            <returns>
            1) If a suitable exit point was found: the control flow block that should be reached when breaking from the loop
            2) If the loop should not have any exit point (extend by all dominated blocks): NoExitPoint
            3) otherwise (exit point unknown, heuristically extend loop): null
            </returns>
            <remarks>This method must not write to the Visited flags on the CFG.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.ValidateExitPoint(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Validates an exit point.
            
            An exit point is invalid iff there is a node reachable from the exit point that
            is dominated by the loop head, but not by the exit point.
            (i.e. this method returns false iff the exit point's dominance frontier contains
            a node dominated by the loop head. but we implement this the slow way because
            we don't have dominance frontiers precomputed)
            </summary>
            <remarks>
            We need this because it's possible that there's a return block (thus reverse-unreachable node ignored by post-dominance)
            that is reachable both directly from the loop, and from the exit point.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.HasReachableExit(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Extension of ControlFlowGraph.HasReachableExit
            Uses loopContext.GetBreakTargets().Any() when analyzing switches to avoid 
            classifying continue blocks as reachable exits.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.DominatorTreeChildren(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Returns the children in a loop dominator tree, with an optional exit point
            Avoids returning continue statements when analysing switches (because increment blocks can be dominated)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.PickExitPoint(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode@,System.Int32@)">
            <summary>
            Pick exit point by picking any node that has no reachable exits.
            
            In the common case where the code was compiled with a compiler that emits IL code
            in source order (like the C# compiler), we can find the "real" exit point
            by simply picking the block with the highest IL offset.
            So let's do that instead of maximizing amount of code.
            </summary>
            <returns>Code amount in <paramref name="node"/> and its dominated nodes.</returns>
            <remarks>This method must not write to the Visited flags on the CFG.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.PrepareReverseCFG(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Int32@)">
            <summary>
            Constructs a new control flow graph.
            Each node cfg[i] has a corresponding node rev[i].
            Edges are only created for nodes dominated by loopHead, and are in reverse from their direction
            in the primary CFG.
            An artificial exit node is used for edges that leave the set of nodes dominated by loopHead,
            or that leave the block Container.
            </summary>
            <param name="loopHead">Entry point of the loop.</param>
            <param name="exitNodeArity">out: The number of different CFG nodes.
            Possible values:
             0 = no CFG nodes used as exit nodes (although edges leaving the block container might still be exits);
             1 = a single CFG node (not dominated by loopHead) was used as an exit node;
             2 = more than one CFG node (not dominated by loopHead) was used as an exit node.
            </param>
            <returns></returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.ExtendLoopHeuristic(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            This function implements a heuristic algorithm that tries to reduce the number of exit
            points. It is only used as fall-back when it is impossible to use a single exit point.
            </summary>
            <remarks>
            This heuristic loop extension algorithm traverses the loop head's dominator tree in pre-order.
            For each candidate node, we detect whether adding it to the loop reduces the number of exit points.
            If it does, the candidate is added to the loop.
            
            Adding a node to the loop has two effects on the the number of exit points:
            * exit points that were added to the loop are no longer exit points, thus reducing the total number of exit points
            * successors of the newly added nodes might be new, additional exit points
            
            Requires and maintains the invariant that a node is marked as visited iff it is contained in the loop.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.IsExitPoint(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Gets whether 'node' is an exit point for the loop marked by the Visited flag.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection.ConstructLoop(System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Move the blocks associated with the loop into a new block container.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis">
            <summary>
            C# switch statements are not necessarily compiled into IL switch instructions.
            For example, when the label values are not contiguous, the C# compiler
            will generate if statements similar to a binary search.
            
            This class analyses such sequences of if statements to reconstruct the original switch.
            </summary>
            <remarks>
            This analysis expects to be run on basic blocks (not extended basic blocks).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.switchVar">
            <summary>
            The variable that is used to represent the switch expression.
            <c>null</c> while analyzing the first block.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.SwitchVariable">
            <summary>
            The variable to be used as the argument of the switch instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.ContainsILSwitch">
            <summary>
            Whether at least one the analyzed blocks contained an IL switch constructors.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.Sections">
            <summary>
            Gets the sections that were detected by the previous AnalyzeBlock() call.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.targetBlockToSectionIndex">
            <summary>
            Used to de-duplicate sections with a branch instruction.
            Invariant: (Sections[targetBlockToSectionIndex[branch.TargetBlock]].Instruction as Branch).TargetBlock == branch.TargetBlock
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.targetContainerToSectionIndex">
            <summary>
            Used to de-duplicate sections with a value-less leave instruction.
            Invariant: (Sections[targetBlockToSectionIndex[leave.TargetContainer]].Instruction as Leave).TargetContainer == leave.TargetContainer
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.InnerBlocks">
            <summary>
            Blocks that can be deleted if the tail of the initial block is replaced with a switch instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.AllowUnreachableCases">
            <summary>
            Gets/sets whether to allow unreachable cases in switch instructions.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.AnalyzeBlock(ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Analyze the last two statements in the block and see if they can be turned into a
            switch instruction.
            </summary>
            <returns>true if the block could be analyzed successfully; false otherwise</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.AnalyzeBlock(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.Util.LongSet,System.Boolean)">
            <summary>
            Analyzes the tail end (last two instructions) of a block.
            </summary>
            <remarks>
            Sets <c>switchVar</c> and <c>defaultInstruction</c> if they are null,
            and adds found sections to <c>sectionLabels</c> and <c>sectionInstructions</c>.
            
            If the function returns false, <c>sectionLabels</c> and <c>sectionInstructions</c> are unmodified.
            </remarks>
            <param name="block">The block to analyze.</param>
            <param name="inputValues">The possible values of the "interesting" variable
            when control flow reaches this block.</param>
            <param name="tailOnly">If true, analyze only the tail (last two instructions).
            If false, analyze the whole block.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.AddSection(ICSharpCode.Decompiler.Util.LongSet,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Adds a new section to the Sections list.
            
            If the instruction is a branch instruction, unify the new section with an existing section
            that also branches to the same target.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.AnalyzeCondition(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.Util.LongSet@)">
            <summary>
            Analyzes the boolean condition, returning the set of values of the interesting
            variable for which the condition evaluates to true.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis.MakeSetWhereComparisonIsTrue(ICSharpCode.Decompiler.IL.ComparisonKind,System.Int64,ICSharpCode.Decompiler.TypeSystem.Sign)">
            <summary>
            Create the LongSet that contains a value x iff x compared with value is true.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection">
            <summary>
            C# switch statements are not necessarily compiled into
            IL switch instructions (e.g. when the integer values are non-contiguous).
            
            Detect sequences of conditional branches that all test a single integer value,
            and simplify them into a ILAst switch instruction (which like C# does not require contiguous values).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.LoopContext">
            <summary>
            When detecting a switch, it is important to distinguish Branch instructions which will
            eventually decompile to continue; statements. 
            
            A LoopContext is constructed for a node and its dominator tree, as for a Branch to be a continue;
            statement, it must be contained within the target-loop
            
            This class also supplies the depth of the loop targetted by a continue; statement relative to the
            context node, to avoid (or eventually support) labelled continues to outer loops
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.LoopContext.GetBreakTargets(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Lists all potential targets for break; statements from a domination tree,
            assuming the domination tree must be exited via either break; or continue;
            
            First list all nodes in the dominator tree (excluding continue nodes)
            Then return the all successors not contained within said tree.
            
            Note that node will be returned once for each outgoing edge.
            Labelled continue statements (depth > 1) are counted as break targets
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.UseCSharpSwitch(System.Collections.Generic.KeyValuePair{ICSharpCode.Decompiler.Util.LongSet,ICSharpCode.Decompiler.IL.ILInstruction}@)">
            <summary>
            Tests whether we should prefer a switch statement over an if statement.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.MatchRoslynSwitchOnString">
            <summary>
            stloc switchValueVar(call ComputeStringHash(switchValue))
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.AnalyzeControlFlow">
            <summary>
            Builds the control flow graph for the current container (if necessary), establishes loopContext
            and returns the ControlFlowNodes corresponding to the inner flow and case blocks of the potential switch
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.SwitchUsesGoto(System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},ICSharpCode.Decompiler.IL.Block@)">
            <summary>
            Determines if the analysed switch can be constructed without any gotos
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.AddNullCase(System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode})">
            <summary>
            Does some of the analysis of SwitchOnNullableTransform to add the null case control flow
            to the results of SwitchAnalysis
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.IsShortCircuit(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Int32)">
            <summary>
            Pattern matching for short circuit expressions
              p
              |\
              | n
              |/ \
              s   c
            
             where
              p: if (a) goto n; goto s;
              n: if (b) goto c; goto s;
            
             Can simplify to
               p|n
               / \
              s   c
            
             where:
              p|n: if (a &amp;&amp; b) goto c; goto s;
            
             Note that if n has only 1 successor, but is still a flow node, then a short circuit expression 
             has a target (c) with no corresponding block (leave)
            </summary>
            <param name="parent">A node with 2 successors</param>
            <param name="side">The successor index to consider n (the other successor will be the common sibling)</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.IsFlowNode(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            A flow node contains only two instructions, the first of which is an IfInstruction
            A short circuit expression is comprised of a root block ending in an IfInstruction and one or more flow nodes
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection.IsSingleCondition(System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode},System.Collections.Generic.List{ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode})">
            <summary>
            Determines whether the flowNodes are can be reduced to a single condition via short circuit operators
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ReduceNestingTransform">
             <summary>
             Improves code quality by duplicating keyword exits to reduce nesting and restoring IL order.
             </summary>
             <remarks>
             ConditionDetection and DetectSwitchBody both have aggressive inlining policies for else blocks and default cases respectively.
             This can lead to excessive indentation when the entire rest of the method/loop is included in the else block/default case.
             When an If/SwitchInstruction is followed immediately by a keyword exit, the exit can be moved into the child blocks
             allowing the else block or default case to be moved after the if/switch as all prior cases exit.
             Most importantly, this transformation does not change the IL order of any code.
            
             ConditionDetection also has a block exit priority system to assist exit point reduction which in some cases ignores IL order.
             After HighLevelLoopTransform has run, all structures have been detected and preference can be returned to maintaining IL ordering.
             </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.Visit(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Visits a block in context
            </summary>
            <param name="block"></param>
            <param name="continueTarget">Marks the target block of continue statements.</param>
            <param name="nextInstruction">The instruction following the end point of the block. Can only be null if the end point is unreachable.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ImproveILOrdering(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction,ICSharpCode.Decompiler.IL.Block)">
            <summary>
            For an if statement with an unreachable end point and no else block,
            inverts to match IL order of the first statement of each branch
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ReduceNesting(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.IfInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Reduce Nesting in if/else statements by duplicating an exit instruction.
            Does not affect IL order
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ReduceSwitchNesting(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.BlockContainer,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Reduce Nesting in switch statements by replacing break; in cases with the block exit, and extracting the default case
            Does not affect IL order
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.CanDuplicateExit(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Checks if an exit is a duplicable keyword exit (return; break; continue;)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.EnsureEndPointUnreachable(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Ensures the end point of a block is unreachable by duplicating and appending the [exit] instruction following the end point
            </summary>
            <param name="inst">The instruction/block of interest</param>
            <param name="fallthroughExit">The next instruction to be executed (provided inst does not exit)</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.RemoveRedundantExit(ICSharpCode.Decompiler.IL.Block,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Removes a redundant block exit instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.GetElseIfParent(ICSharpCode.Decompiler.IL.IfInstruction)">
             <summary>
             Determines if an IfInstruction is an else-if and returns the preceeding (parent) IfInstruction
            
             [else-]if (parent-cond) else { ifInst }
             </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.UpdateStats(ICSharpCode.Decompiler.IL.ILInstruction,System.Int32@,System.Int32@)">
            <summary>
            Adds a code path to the current heuristic tally
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ComputeStats(ICSharpCode.Decompiler.IL.ILInstruction,System.Int32@,System.Int32@,System.Int32,System.Boolean)">
            <summary>
            Recursively computes the number of statements and maximum nested depth of an instruction
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ShouldReduceNesting(ICSharpCode.Decompiler.IL.ILInstruction,System.Int32,System.Int32)">
            <summary>
            Heuristic to determine whether it is worth duplicating exits into the preceeding sibling blocks (then/else-if/case)
            in order to reduce the nesting of inst by 1
            </summary>
            <param name="inst">The instruction heading the nested candidate block</param>
            <param name="maxStatements">The number of statements in the largest sibling block</param>
            <param name="maxDepth">The relative depth of the most nested statement in the sibling blocks</param>
            <returns></returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ReduceNestingTransform.ExtractElseBlock(ICSharpCode.Decompiler.IL.IfInstruction)">
            <summary>
            if (cond) { ...; exit; } else { ... }
            ...;
              ->
            if (cond) { ...; exit; }
            ...;
            ...;
            </summary>
            <param name="ifInst"></param>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicInstruction">
            <summary>Instruction representing a dynamic call site.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicConvertInstruction">
            <summary>ILAst representation of a cast inside a dynamic expression (maps to Binder.Convert).</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.DynamicConvertInstruction.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicInvokeMemberInstruction">
            <summary>ILAst representation of a method call inside a dynamic expression (maps to Binder.InvokeMember).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicGetMemberInstruction">
            <summary>ILAst representation of a property get method call inside a dynamic expression (maps to Binder.GetMember).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicSetMemberInstruction">
            <summary>ILAst representation of a property set method call inside a dynamic expression (maps to Binder.SetMember).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicGetIndexInstruction">
            <summary>ILAst representation of an indexer get method call inside a dynamic expression (maps to Binder.GetIndex).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicSetIndexInstruction">
            <summary>ILAst representation of an indexer set method call inside a dynamic expression (maps to Binder.SetIndex).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicInvokeConstructorInstruction">
            <summary>ILAst representation of a constuctor invocation inside a dynamic expression (maps to Binder.InvokeConstructor).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicBinaryOperatorInstruction">
            <summary>ILAst representation of a binary operator inside a dynamic expression (maps to Binder.BinaryOperation).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicLogicOperatorInstruction">
            <summary>ILAst representation of a short-circuiting binary operator inside a dynamic expression.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicUnaryOperatorInstruction">
            <summary>ILAst representation of a unary operator inside a dynamic expression (maps to Binder.UnaryOperation).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicInvokeInstruction">
            <summary>ILAst representation of a delegate invocation inside a dynamic expression (maps to Binder.Invoke).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicIsEventInstruction">
            <summary>ILAst representation of a call to the Binder.IsEvent method inside a dynamic expression.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.PointerArithmeticOffset">
            <summary>
            Analyses the RHS of a 'ptr + int' or 'ptr - int' operation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.PointerArithmeticOffset.Detect(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.IType,System.Boolean,System.Boolean)">
            <summary>
            Given an instruction that computes a pointer arithmetic offset in bytes,
            returns an instruction that computes the same offset in number of elements.
            
            Returns null if no such instruction can be found.
            </summary>
            <param name="byteOffsetInst">Input instruction.</param>
            <param name="pointerElementType">The target type of the pointer type.</param>
            <param name="checkForOverflow">Whether the pointer arithmetic operation checks for overflow.</param>
            <param name="unwrapZeroExtension">Whether to allow zero extensions in the mul argument.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.PointerArithmeticOffset.IsFixedVariable(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Returns true if <c>inst</c> computes the address of a fixed variable; false if it computes the address of a moveable variable.
            (see "Fixed and moveable variables" in the C# specification)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILAstWritingOptions.UseLogicOperationSugar">
            <summary>
            Sugar for logic.not/and/or.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILAstWritingOptions.UseFieldSugar">
            <summary>
            Sugar for ldfld/stfld.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILAstWritingOptions.ShowILRanges">
            <summary>
            Show IL ranges in ILAst output.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILAstWritingOptions.ShowChildIndexInBlock">
            <summary>
            Show the child index of the instruction in ILAst output.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdFlda">
            <summary>Load address of instance field</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdFlda.Field">
            <summary>Returns the field operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.StObj">
            <summary>Indirect store (store to ref/pointer).
            Evaluates to the value that was stored (when using type byte/short: evaluates to the truncated value, sign/zero extended back to I4 based on type.GetSign())</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.StObj.CanInlineIntoTargetSlot(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            For a store to a field or array element, C# will only throw NullReferenceException/IndexOfBoundsException
            after the value-to-be-stored has been computed.
            This means a LdFlda/LdElema used as target for StObj must have DelayExceptions==true to allow a translation to C#
            without changing the program semantics. See https://github.com/icsharpcode/ILSpy/issues/2050
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.StObj.CheckTargetSlot">
            <summary>
            called as part of CheckInvariant()
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.StObj.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.StObj.IsVolatile">
            <summary>Gets/Sets whether the memory access is volatile.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.StObj.UnalignedPrefix">
            <summary>Returns the alignment specified by the 'unaligned' prefix; or 0 if there was no 'unaligned' prefix.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NullableUnwrap">
             <summary>
             For a nullable input, gets the underlying value.
             
             There are three possible input types:
              * reference type: if input!=null, evaluates to the input
              * nullable value type: if input.Has_Value, evaluates to input.GetValueOrDefault()
              * generic type: behavior depends on the type at runtime.
                If non-nullable value type, unconditionally evaluates to the input.
            
             If the input is null, control-flow is tranferred to the nearest surrounding nullable.rewrap
             instruction.
             </summary>
            <summary>The input operand must be one of:
              1. a nullable value type
              2. a reference type
              3. a managed reference to a type parameter.
            If the input is non-null, evaluates to the (unwrapped) input.
            If the input is null, jumps to the innermost nullable.rewrap instruction that contains this instruction.
            In case 3 (managed reference), the dereferenced value is the input being tested, and the nullable.unwrap instruction returns the managed reference unmodified (if the value is non-null).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NullableUnwrap.RefInput">
            <summary>
            Whether the argument is dereferenced before checking for a null input.
            If true, the argument must be a managed reference to a valid input type.
            </summary>
            <remarks>
            This mode exists because the C# compiler sometimes avoids copying the whole Nullable{T} struct
            before the null-check.
            The underlying struct T is still copied by the GetValueOrDefault() call, but only in the non-null case.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.NullableUnwrap.RefOutput">
            <summary>
            Consider the following code generated for <code>t?.Method()</code> on a generic t:
            <code>if (comp(box ``0(ldloc t) != ldnull)) newobj Nullable..ctor(constrained[``0].callvirt Method(ldloca t)) else default.value Nullable</code>
            Here, the method is called on the original reference, and any mutations performed by the method will be visible in the original variable.
            
            To represent this, we use a nullable.unwrap with ResultType==Ref: instead of returning the input value,
            the input reference is returned in the non-null case.
            Note that in case the generic type ends up being <c>Nullable{T}</c>, this means methods will end up being called on
            the nullable type, not on the underlying type. However, this ends up making no difference, because the only methods
            that can be called that way are those on System.Object. All the virtual methods are overridden in <c>Nullable{T}</c>
            and end up forwarding to <c>T</c>; and the non-virtual methods cause boxing which strips the <c>Nullable{T}</c> wrapper.
            
            RefOutput can only be used if RefInput is also used.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NullableRewrap">
            <summary>Serves as jump target for the nullable.unwrap instruction.
            If the input evaluates normally, evaluates to the input value (wrapped in Nullable&lt;T&gt; if the input is a non-nullable value type).If a nullable.unwrap instruction encounters a null input and jumps to the (endpoint of the) nullable.rewrap instruction,the nullable.rewrap instruction evaluates to null.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.StLoc">
            <summary>Stores a value into a local variable. (IL: starg/stloc)
            Evaluates to the value that was stored (for byte/short variables: evaluates to the truncated value, sign/zero extended back to I4 based on variable.Type.GetSign())</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StLoc.IsStackAdjustment">
            <summary>
            If true, this stloc represents a stack type adjustment.
            This field is only used in ILReader and BlockBuilder, and should be ignored by ILAst transforms.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StLoc.ILStackWasEmpty">
            <summary>
            Gets whether the IL stack was empty after this store.
            Only set for store instructions from the IL; not for stores to the stack
            or other stores generated by transforms.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.CallIndirect">
            <summary>Unsafe function pointer call.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DefaultValue">
            <summary>Returns the default value for a type.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.DefaultValue.ILStackWasEmpty">
            <summary>
            Gets whether the IL stack was empty at the point of this instruction.
            (not counting the argument of the instruction itself)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.DefaultValue.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ExpressionTreeCast">
            <summary>ILAst representation of Expression.Convert.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ExpressionTreeCast.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.IntroduceRefReadOnlyModifierOnLocals.IsUsedAsRefReadonly(ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Infer ref readonly type from usage:
            An ILVariable should be marked as readonly,
            if it's a "by-ref-like" type and the initialized value is known to be readonly.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.StringToInt">
            <summary>Maps a string value to an integer. This is used in switch(string).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.UsingInstruction">
            <summary>
            IL using instruction.
            Equivalent to:
            <code>
            stloc v(resourceExpression)
            try {
               body
            } finally {
               v?.Dispose();
            }
            </code>
            </summary>
            <remarks>
            The value of v is undefined after the end of the body block.
            </remarks>
            <summary>Using statement</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.TupleTransform.MatchTupleFieldAccess(ICSharpCode.Decompiler.IL.LdFlda,ICSharpCode.Decompiler.TypeSystem.IType@,ICSharpCode.Decompiler.IL.ILInstruction@,System.Int32@)">
            <summary>
            Matches an 'ldflda' instruction accessing a tuple element.
            
            E.g. matches:
            <c>ldflda Item1(ldflda Rest(target))</c>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.TupleTransform.MatchTupleConstruction(ICSharpCode.Decompiler.IL.NewObj,ICSharpCode.Decompiler.IL.ILInstruction[]@)">
            <summary>
            Matches 'newobj TupleType(...)'.
            Takes care of flattening long tuples.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Await">
            <summary>C# await operator.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILVariableCollection">
            <summary>
            The collection of variables in a <c>ILFunction</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariableCollection.Item(System.Int32)">
            <summary>
            Gets a variable given its <c>IndexInFunction</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILVariableCollection.RemoveDead">
            <summary>
            Remove variables that have StoreCount == LoadCount == AddressCount == 0.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LockInstruction">
            <summary>Lock statement</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NullCoalescingKind">
            <summary>
            Kind of null-coalescing operator.
            ILAst: <c>if.notnull(valueInst, fallbackInst)</c>
            C#: <c>value ?? fallback</c>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NullCoalescingKind.Ref">
            <summary>
            Both ValueInst and FallbackInst are of reference type.
            
            Semantics: equivalent to "valueInst != null ? valueInst : fallbackInst",
                       except that valueInst is evaluated only once.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NullCoalescingKind.Nullable">
            <summary>
            Both ValueInst and FallbackInst are of type Nullable{T}.
            
            Semantics: equivalent to "valueInst.HasValue ? valueInst : fallbackInst",
                       except that valueInst is evaluated only once.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NullCoalescingKind.NullableWithValueFallback">
            <summary>
            ValueInst is Nullable{T}, but FallbackInst is non-nullable value type.
            
            Semantics: equivalent to "valueInst.HasValue ? valueInst.Value : fallbackInst",
                       except that valueInst is evaluated only once.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NullCoalescingInstruction">
            <summary>Null coalescing operator expression. <c>if.notnull(valueInst, fallbackInst)</c></summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ThreeValuedBoolAnd">
            <summary>Three valued logic and. Inputs are of type bool? or I4, output is of type bool?. Unlike logic.and(), does not have short-circuiting behavior.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ThreeValuedBoolOr">
            <summary>Three valued logic or. Inputs are of type bool? or I4, output is of type bool?. Unlike logic.or(), does not have short-circuiting behavior.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.UserDefinedLogicOperator">
            <summary>Use of user-defined &amp;&amp; or || operator.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.UserDefinedLogicOperator.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Patterns.PatternInstruction">
            <summary>Base class for pattern matching in ILAst.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Patterns.AnyNode">
            <summary>Matches any node</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Patterns.ListMatch">
            <summary>
            Data holder for a single list matching operation.
            </summary>
            <remarks>
            Notes on backtracking:
            PerformMatch() may save backtracking-savepoints to the ListMatch instance.
            Each backtracking-savepoints is a Stack{int} with instructions of how to restore the saved state.
            When a savepoint is created by a PerformMatch() call, that call may be nested in several other PerformMatch() calls that operate on
            the same list.
            When leaving those calls (whether with a successful match or not), the outer PerformMatch() calls may push additional state onto
            all of the added backtracking-savepoints.
            When the overall list match fails but savepoints exists, the most recently added savepoint is restored by calling PerformMatch()
            with listMatch.restoreStack set to that savepoint. Each PerformMatch() call must pop its state from that stack before
            recursively calling its child patterns.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Patterns.ListMatch.DoMatch(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.IL.ILInstruction},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.IL.ILInstruction},ICSharpCode.Decompiler.IL.Patterns.Match@)">
            <summary>
            The main list matching logic.
            </summary>
            <returns>Returns whether the list match was successful.
            If the method returns true, it adds the capture groups (if any) to the match.
            If the method returns false, the match object remains in a partially-updated state and needs to be restored
            before it can be reused.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Patterns.ListMatch.PerformMatchSequence(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.IL.ILInstruction},ICSharpCode.Decompiler.IL.Patterns.ListMatch@,ICSharpCode.Decompiler.IL.Patterns.Match@)">
            <summary>
            PerformMatch() for a sequence of patterns.
            </summary>
            <param name="patterns">List of patterns to match.</param>
            <param name="listMatch">Stores state about the current list match.</param>
            <param name="match">The match object, used to store global state during the match (such as the results of capture groups).</param>
            <returns>Returns whether all patterns were matched successfully against a part of the list.
            If the method returns true, it updates listMatch.SyntaxIndex to point to the next node that was not part of the match,
            and adds the capture groups (if any) to the match.
            If the method returns false, the listMatch and match objects remain in a partially-updated state and need to be restored
            before they can be reused.</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Patterns.ListMatch.SavePoint">
            <summary>
            A savepoint that the list matching operation can be restored from.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Patterns.ListMatch.SyntaxList">
            <summary>
            The syntax list we are matching against.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Patterns.ListMatch.SyntaxIndex">
            <summary>
            The current index in the syntax list.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Patterns.ListMatch.RestoreSavePoint(ICSharpCode.Decompiler.IL.Patterns.Match@)">
            <summary>
            Restores the listmatch state from a savepoint.
            </summary>
            <returns>Returns whether a savepoint exists</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Patterns.Match">
            <summary>
            Data holder for the overall pattern matching operation.
            </summary>
            <remarks>
            This type is a struct in order to prevent unnecessary memory allocations during pattern matching.
            The default value <c>default(Match)</c> represents an unsuccessful match.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Patterns.Match.Success">
            <summary>
            Gets whether the match was successful.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Patterns.Match.op_True(ICSharpCode.Decompiler.IL.Patterns.Match)">
            <summary>
            Gets whether the match was successful.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Patterns.Match.op_False(ICSharpCode.Decompiler.IL.Patterns.Match)">
            <summary>
            Gets whether the match failed.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.OpCode">
            <summary>
            Enum representing the type of an <see cref="T:ICSharpCode.Decompiler.IL.ILInstruction"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.InvalidBranch">
            <summary>Represents invalid IL. Semantically, this instruction is considered to throw some kind of exception.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.InvalidExpression">
            <summary>Represents invalid IL. Semantically, this instruction is considered to produce some kind of value.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Nop">
            <summary>No operation. Takes 0 arguments and returns void.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.ILFunction">
            <summary>A container of IL blocks.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.BlockContainer">
            <summary>A container of IL blocks.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Block">
            <summary>A block of IL instructions.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.PinnedRegion">
            <summary>A region where a pinned variable is used (initial representation of future fixed statement).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.BinaryNumericInstruction">
            <summary>Common instruction for add, sub, mul, div, rem, bit.and, bit.or, bit.xor, shl and shr.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NumericCompoundAssign">
            <summary>Common instruction for numeric compound assignments.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.UserDefinedCompoundAssign">
            <summary>Common instruction for user-defined compound assignments.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicCompoundAssign">
            <summary>Common instruction for dynamic compound assignments.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.BitNot">
            <summary>Bitwise NOT</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Arglist">
            <summary>Retrieves the RuntimeArgumentHandle.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Branch">
            <summary>Unconditional branch. <c>goto target;</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Leave">
            <summary>Unconditional branch to end of block container. Return is represented using IsLeavingFunction and an (optional) return value. The block container evaluates to the value produced by the argument of the leave instruction.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.IfInstruction">
            <summary>If statement / conditional expression. <c>if (condition) trueExpr else falseExpr</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NullCoalescingInstruction">
            <summary>Null coalescing operator expression. <c>if.notnull(valueInst, fallbackInst)</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.SwitchInstruction">
            <summary>Switch statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.SwitchSection">
            <summary>Switch section within a switch statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.TryCatch">
            <summary>Try-catch statement.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.TryCatchHandler">
            <summary>Catch handler within a try-catch statement.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.TryFinally">
            <summary>Try-finally statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.TryFault">
            <summary>Try-fault statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LockInstruction">
            <summary>Lock statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.UsingInstruction">
            <summary>Using statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DebugBreak">
            <summary>Breakpoint instruction</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Comp">
            <summary>Comparison. The inputs must be both integers; or both floats; or both object references. Object references can only be compared for equality or inequality. Floating-point comparisons evaluate to 0 (false) when an input is NaN, except for 'NaN != NaN' which evaluates to 1 (true).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Call">
            <summary>Non-virtual method call.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.CallVirt">
            <summary>Virtual method call.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.CallIndirect">
            <summary>Unsafe function pointer call.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Ckfinite">
            <summary>Checks that the input float is not NaN or infinite.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Conv">
            <summary>Numeric cast.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdLoc">
            <summary>Loads the value of a local variable. (ldarg/ldloc)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdLoca">
            <summary>Loads the address of a local variable. (ldarga/ldloca)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.StLoc">
            <summary>Stores a value into a local variable. (IL: starg/stloc)
            Evaluates to the value that was stored (for byte/short variables: evaluates to the truncated value, sign/zero extended back to I4 based on variable.Type.GetSign())</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.AddressOf">
            <summary>Stores the value into an anonymous temporary variable, and returns the address of that variable.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.ThreeValuedBoolAnd">
            <summary>Three valued logic and. Inputs are of type bool? or I4, output is of type bool?. Unlike logic.and(), does not have short-circuiting behavior.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.ThreeValuedBoolOr">
            <summary>Three valued logic or. Inputs are of type bool? or I4, output is of type bool?. Unlike logic.or(), does not have short-circuiting behavior.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NullableUnwrap">
            <summary>The input operand must be one of:
              1. a nullable value type
              2. a reference type
              3. a managed reference to a type parameter.
            If the input is non-null, evaluates to the (unwrapped) input.
            If the input is null, jumps to the innermost nullable.rewrap instruction that contains this instruction.
            In case 3 (managed reference), the dereferenced value is the input being tested, and the nullable.unwrap instruction returns the managed reference unmodified (if the value is non-null).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NullableRewrap">
            <summary>Serves as jump target for the nullable.unwrap instruction.
            If the input evaluates normally, evaluates to the input value (wrapped in Nullable&lt;T&gt; if the input is a non-nullable value type).If a nullable.unwrap instruction encounters a null input and jumps to the (endpoint of the) nullable.rewrap instruction,the nullable.rewrap instruction evaluates to null.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdStr">
            <summary>Loads a constant string.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdcI4">
            <summary>Loads a constant 32-bit integer.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdcI8">
            <summary>Loads a constant 64-bit integer.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdcF4">
            <summary>Loads a constant 32-bit floating-point number.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdcF8">
            <summary>Loads a constant 64-bit floating-point number.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdcDecimal">
            <summary>Loads a constant decimal.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdNull">
            <summary>Loads the null reference.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdFtn">
            <summary>Load method pointer</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdVirtFtn">
            <summary>Load method pointer</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdVirtDelegate">
            <summary>Virtual delegate construction</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdTypeToken">
            <summary>Loads runtime representation of metadata token</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdMemberToken">
            <summary>Loads runtime representation of metadata token</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LocAlloc">
            <summary>Allocates space in the stack frame</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LocAllocSpan">
            <summary>Allocates space in the stack frame and wraps it in a Span</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Cpblk">
            <summary>memcpy(destAddress, sourceAddress, size);</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Initblk">
            <summary>memset(address, value, size)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdFlda">
            <summary>Load address of instance field</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdsFlda">
            <summary>Load static field address</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.CastClass">
            <summary>Casts an object to a class.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.IsInst">
            <summary>Test if object is instance of class or interface.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdObj">
            <summary>Indirect load (ref/pointer dereference).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.StObj">
            <summary>Indirect store (store to ref/pointer).
            Evaluates to the value that was stored (when using type byte/short: evaluates to the truncated value, sign/zero extended back to I4 based on type.GetSign())</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Box">
            <summary>Boxes a value.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Unbox">
            <summary>Compute address inside box.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.UnboxAny">
            <summary>Unbox a value.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NewObj">
            <summary>Creates an object instance and calls the constructor.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.NewArr">
            <summary>Creates an array instance.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DefaultValue">
            <summary>Returns the default value for a type.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Throw">
            <summary>Throws an exception.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Rethrow">
            <summary>Rethrows the current exception.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.SizeOf">
            <summary>Gets the size of a type in bytes.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdLen">
            <summary>Returns the length of an array as 'native unsigned int'.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.LdElema">
            <summary>Load address of array element.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.GetPinnableReference">
            <summary>Retrieves a pinnable reference for the input object.
            The input must be an object reference (O).
            If the input is an array/string, evaluates to a reference to the first element/character, or to a null reference if the array is null or empty.
            Otherwise, uses the GetPinnableReference method to get the reference, or evaluates to a null reference if the input is null.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.StringToInt">
            <summary>Maps a string value to an integer. This is used in switch(string).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.ExpressionTreeCast">
            <summary>ILAst representation of Expression.Convert.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.UserDefinedLogicOperator">
            <summary>Use of user-defined &amp;&amp; or || operator.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicLogicOperatorInstruction">
            <summary>ILAst representation of a short-circuiting binary operator inside a dynamic expression.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicBinaryOperatorInstruction">
            <summary>ILAst representation of a binary operator inside a dynamic expression (maps to Binder.BinaryOperation).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicUnaryOperatorInstruction">
            <summary>ILAst representation of a unary operator inside a dynamic expression (maps to Binder.UnaryOperation).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicConvertInstruction">
            <summary>ILAst representation of a cast inside a dynamic expression (maps to Binder.Convert).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicGetMemberInstruction">
            <summary>ILAst representation of a property get method call inside a dynamic expression (maps to Binder.GetMember).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicSetMemberInstruction">
            <summary>ILAst representation of a property set method call inside a dynamic expression (maps to Binder.SetMember).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicGetIndexInstruction">
            <summary>ILAst representation of an indexer get method call inside a dynamic expression (maps to Binder.GetIndex).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicSetIndexInstruction">
            <summary>ILAst representation of an indexer set method call inside a dynamic expression (maps to Binder.SetIndex).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicInvokeMemberInstruction">
            <summary>ILAst representation of a method call inside a dynamic expression (maps to Binder.InvokeMember).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicInvokeConstructorInstruction">
            <summary>ILAst representation of a constuctor invocation inside a dynamic expression (maps to Binder.InvokeConstructor).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicInvokeInstruction">
            <summary>ILAst representation of a delegate invocation inside a dynamic expression (maps to Binder.Invoke).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DynamicIsEventInstruction">
            <summary>ILAst representation of a call to the Binder.IsEvent method inside a dynamic expression.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.MatchInstruction">
            <summary>ILAst representation of C# patterns</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.MakeRefAny">
            <summary>Push a typed reference of type class onto the stack.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.RefAnyType">
            <summary>Push the type token stored in a typed reference.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.RefAnyValue">
            <summary>Push the address stored in a typed reference.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.YieldReturn">
            <summary>Yield an element from an iterator.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.Await">
            <summary>C# await operator.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DeconstructInstruction">
            <summary>Deconstruction statement</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.DeconstructResultInstruction">
            <summary>Represents a deconstructed value</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.OpCode.AnyNode">
            <summary>Matches any node</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.SimpleInstruction">
            <summary>Instruction without any arguments</summary>
            <summary>
            A simple instruction that does not have any arguments.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.UnaryInstruction">
            <summary>Instruction with a single argument</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.BinaryInstruction">
            <summary>Instruction with two arguments: Left and Right</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.CallInstruction">
            <summary>Instruction with a list of arguments.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CallInstruction.IsTail">
            <summary>
            Gets/Sets whether the call has the 'tail.' prefix.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CallInstruction.ConstrainedTo">
            <summary>
            Gets/Sets the type specified in the 'constrained.' prefix.
            Returns null if no 'constrained.' prefix exists for this call.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CallInstruction.ILStackWasEmpty">
            <summary>
            Gets whether the IL stack was empty at the point of this call.
            (not counting the arguments/return value of the call itself)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.CallInstruction.IsInstanceCall">
            <summary>
            Gets whether this is an instance call (i.e. whether the first argument is the 'this' pointer).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.CallInstruction.GetParameter(System.Int32)">
            <summary>
            Gets the parameter for the argument with the specified index.
            Returns null for the <c>this</c> parameter.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.CallInstruction.ExpectedTypeForThisPointer(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the expected stack type for passing the this pointer in a method call.
            Returns StackType.O for reference types (this pointer passed as object reference),
            and StackType.Ref for type parameters and value types (this pointer passed as managed reference).
            
            Returns StackType.Unknown if the input type is unknown.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.CompoundAssignmentInstruction">
            <summary>Common instruction for compound assignments.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundAssignmentInstruction.TargetKind">
            <summary>
            If TargetIsProperty is true, the Target must be a call to a property getter,
            and the compound.assign will implicitly call the corresponding property setter.
            Otherwise, the Target can be any instruction that evaluates to an address,
            and the compound.assign will implicit load and store from/to that address.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.InvalidBranch">
            <summary>Represents invalid IL. Semantically, this instruction is considered to throw some kind of exception.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.InvalidExpression">
            <summary>Represents invalid IL. Semantically, this instruction is considered to produce some kind of value.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Nop">
            <summary>No operation. Takes 0 arguments and returns void.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILFunction">
            <summary>A container of IL blocks.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.Method">
            <summary>
            Gets the method definition from metadata.
            May be null for functions that were not constructed from metadata,
            e.g., expression trees.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.GenericContext">
            <summary>
            Gets the generic context of this function.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.Name">
            <summary>
            Gets the name of this function, usually this returns the name from metadata.
            <para>
            For local functions:
            This is the name that is used to declare and use the function.
            It may not conflict with the names of local variables of ancestor functions
            and may be overwritten by the AssignVariableNames step.
            
            For top-level functions, delegates and expressions trees modifying this usually
            has no effect, as the name should not be used in the final AST construction.
            </para>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.CodeSize">
            <summary>
            Size of the IL code in this function.
            Note: after async/await transform, this is the code size of the MoveNext function.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.Variables">
            <summary>
            List of ILVariables used in this function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.DeclarationScope">
            <summary>
            Gets the scope in which the local function is declared.
            Returns null, if this is not a local function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.CapturedVariables">
            <summary>
            Gets the set of captured variables by this ILFunction.
            </summary>
            <remarks>This is populated by the <see cref="T:ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage" /> step.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.Warnings">
            <summary>
            List of warnings of ILReader.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.IsIterator">
            <summary>
            Gets whether this function is a decompiled iterator (is using yield).
            This flag gets set by the YieldReturnDecompiler.
            
            If set, the 'return' instruction has the semantics of 'yield break;'
            instead of a normal return.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.StateMachineCompiledWithMono">
            <summary>
            Gets whether the YieldReturnDecompiler determined that the Mono C# compiler was used to compile this function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.IsAsync">
            <summary>
            Gets whether this function is async.
            This flag gets set by the AsyncAwaitDecompiler.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.AsyncReturnType">
            <summary>
            Return element type -- if the async method returns Task{T}, this field stores T.
            If the async method returns Task or void, this field stores void.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.MoveNextMethod">
            <summary>
            If this function is an iterator/async, this field stores the compiler-generated MoveNext() method.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.ReducedMethod">
            <summary>
            If this function is a local function, this field stores the reduced version of the function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.ChainedConstructorCallILOffset">
            <summary>
            Returns the IL offset of the constructor call, -1 if this is not a constructor or no chained constructor call was found.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.DelegateType">
            <summary>
            If this is an expression tree or delegate, returns the expression tree type Expression{T} or T.
            T is the delegate type that matches the signature of this method.
            Otherwise this must be null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.Kind">
            <summary>
            Gets which kind of function this is.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.ReturnType">
            <summary>
            Return type of this function.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunction.Parameters">
            <summary>
            List of parameters of this function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILFunction.SequencePointCandidates">
            <summary>
            List of candidate locations for sequence points. Includes any offset
            where the stack is empty, nop instructions, and the instruction following
            a call instruction
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILFunction.#ctor(ICSharpCode.Decompiler.TypeSystem.IMethod,System.Int32,ICSharpCode.Decompiler.TypeSystem.GenericContext,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILFunctionKind)">
            <summary>
            Constructs a new ILFunction from the given metadata and with the given ILAst body.
            </summary>
            <remarks>
            Use <see cref="T:ICSharpCode.Decompiler.IL.ILReader"/> to create ILAst.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILFunction.#ctor(ICSharpCode.Decompiler.TypeSystem.IType,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IParameter},ICSharpCode.Decompiler.TypeSystem.GenericContext,ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILFunctionKind)">
            <summary>
            This constructor is only to be used by the TransformExpressionTrees step.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILFunction.RunTransforms(System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.IL.Transforms.IILTransform},ICSharpCode.Decompiler.IL.Transforms.ILTransformContext)">
            <summary>
            Apply a list of transforms to this function.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILFunction.RecombineVariables(ICSharpCode.Decompiler.IL.ILVariable,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Recombine split variables by replacing all occurrences of variable2 with variable1.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.BlockContainer">
            <summary>A container of IL blocks.</summary>
            <summary>
            A container of IL blocks.
            Each block is an extended basic block (branches may only jump to the beginning of blocks, not into the middle),
            and only branches within this container may reference the blocks in this container.
            That means that viewed from the outside, the block container has a single entry point (but possibly multiple exit points),
            and the same holds for every block within the container.
            
            All blocks in the container must perform unconditional control flow (falling through to the block end is not allowed).
            To exit the block container, use the 'leave' instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.BlockContainer.LeaveCount">
            <summary>
            Gets the number of 'leave' instructions that target this BlockContainer.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.BlockContainer.EntryPoint">
            <summary>
            Gets the container's entry point. This is the first block in the Blocks collection.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.BlockContainer.TopologicalSort(System.Boolean)">
            <summary>
            Topologically sort the blocks.
            The new order is returned without modifying the BlockContainer.
            </summary>
            <param name="deleteUnreachableBlocks">If true, unreachable blocks are not included in the new order.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.BlockContainer.SortBlocks(System.Boolean)">
            <summary>
            Topologically sort the blocks.
            </summary>
            <param name="deleteUnreachableBlocks">If true, delete unreachable blocks.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.BlockContainer.SingleInstruction">
            <summary>
            If the container consists of a single block with a single instruction,
            returns that instruction.
            Otherwise returns the block, or the container itself if it has multiple blocks.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Block">
            <summary>A block of IL instructions.</summary>
            <summary>
            A block consists of a list of IL instructions.
            
            <para>
            Note: if execution reaches the end of the instruction list,
            the FinalInstruction (which is not part of the list) will be executed.
            The block returns returns the result value of the FinalInstruction.
            For blocks returning void, the FinalInstruction will usually be 'nop'.
            </para>
            
            There are three different uses for blocks:
            1) Blocks in block containers. Used as targets for Branch instructions.
            2) Blocks to group a bunch of statements, e.g. the TrueInst of an IfInstruction.
            3) Inline blocks that evaluate to a value, e.g. for array initializers.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Block.IncomingEdgeCount">
            <summary>
            For blocks in a block container, this field holds
            the number of incoming control flow edges to this block.
            </summary>
            <remarks>
            This variable is automatically updated when adding/removing branch instructions from the ILAst,
            or when adding the block as an entry point to a BlockContainer.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Block.FinalInstruction">
            <summary>
            A 'final instruction' that gets executed after the <c>Instructions</c> collection.
            Provides the return value for the block.
            </summary>
            <remarks>
            Blocks in containers must have 'Nop' as a final instruction.
            
            Note that the FinalInstruction is included in Block.Children,
            but not in Block.Instructions!
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Block.Label">
            <summary>
            Gets the name of this block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Block.Remove">
            <summary>
            Deletes this block from its parent container.
            This may cause the indices of other blocks in that container to change.
            
            It is an error to call this method on blocks that are not directly within a container.
            It is also an error to call this method on the entry-point block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Block.RunTransforms(System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.IL.Transforms.IBlockTransform},ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext)">
            <summary>
            Apply a list of transforms to this function.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Block.GetPredecessor(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets the predecessor of the given instruction.
            Returns null if inst.Parent is not a block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Block.Unwrap(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            If inst is a block consisting of a single instruction, returns that instruction.
            Otherwise, returns the input instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Block.FindClosestBlock(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets the closest parent Block.
            Returns null, if the instruction is not a descendant of a Block.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.PinnedRegion">
            <summary>A region where a pinned variable is used (initial representation of future fixed statement).</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.BinaryNumericInstruction">
            <summary>Common instruction for add, sub, mul, div, rem, bit.and, bit.or, bit.xor, shl and shr.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BinaryNumericInstruction.CheckForOverflow">
            <summary>
            Gets whether the instruction checks for overflow.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BinaryNumericInstruction.Sign">
            <summary>
            For integer operations that depend on the sign, specifies whether the operation
            is signed or unsigned.
            For instructions that produce the same result for either sign, returns Sign.None.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BinaryNumericInstruction.Operator">
            <summary>
            The operator used by this binary operator instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.BinaryNumericInstruction.IsLifted">
            <summary>
            Gets whether this is a lifted nullable operation.
            </summary>
            <remarks>
            A lifted binary operation allows its arguments to be a value of type Nullable{T}, where
            T.GetStackType() == [Left|Right]InputType.
            If both input values are non-null:
             * they are sign/zero-extended to the corresponding InputType (based on T's sign)
             * the underlying numeric operator is applied
             * the result is wrapped in a Nullable{UnderlyingResultType}.
            If either input is null, the instruction evaluates to default(UnderlyingResultType?).
            (this result type is underspecified, since there may be multiple C# types for the stack type)
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NumericCompoundAssign">
            <summary>Common instruction for numeric compound assignments.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.NumericCompoundAssign.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NumericCompoundAssign.CheckForOverflow">
            <summary>
            Gets whether the instruction checks for overflow.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NumericCompoundAssign.Sign">
            <summary>
            For integer operations that depend on the sign, specifies whether the operation
            is signed or unsigned.
            For instructions that produce the same result for either sign, returns Sign.None.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.NumericCompoundAssign.Operator">
            <summary>
            The operator used by this assignment operator instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.NumericCompoundAssign.IsBinaryCompatibleWithType(ICSharpCode.Decompiler.IL.BinaryNumericInstruction,ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.DecompilerSettings)">
            <summary>
            Gets whether the specific binary instruction is compatible with a compound operation on the specified type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.UserDefinedCompoundAssign">
            <summary>Common instruction for user-defined compound assignments.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DynamicCompoundAssign">
            <summary>Common instruction for dynamic compound assignments.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.BitNot">
            <summary>Bitwise NOT</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Arglist">
            <summary>Retrieves the RuntimeArgumentHandle.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Branch">
            <summary>Unconditional branch. <c>goto target;</c></summary>
            <summary>
            Unconditional branch. <c>goto target;</c>
            </summary>
            <remarks>
            When jumping to the entrypoint of the current block container, the branch represents a <c>continue</c> statement.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Branch.TargetContainer">
            <summary>
            Gets the BlockContainer that contains the target block.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Branch.TriggersFinallyBlock">
            <summary>
            Gets whether this branch executes at least one finally block before jumping to the target block.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Leave">
            <summary>Unconditional branch to end of block container. Return is represented using IsLeavingFunction and an (optional) return value. The block container evaluates to the value produced by the argument of the leave instruction.</summary>
            <summary>
            Unconditional branch. <c>goto target;</c>
            </summary>
            <remarks>
            When jumping to the entrypoint of the current block container, the branch represents a <c>continue</c> statement.
            
            Phase-1 execution of a branch is a no-op.
            Phase-2 execution removes PopCount elements from the evaluation stack
            and jumps to the target block.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Leave.IsLeavingFunction">
            <summary>
            Gets whether the leave instruction is leaving the whole ILFunction.
            (TargetContainer == main container of the function).
            
            This is only valid for functions returning void (representing value-less "return;"),
            and for iterators (representing "yield break;").
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Leave.TriggersFinallyBlock">
            <summary>
            Gets whether this branch executes at least one finally block before jumping to the end of the target block container.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.IfInstruction">
            <summary>If statement / conditional expression. <c>if (condition) trueExpr else falseExpr</c></summary>
             <summary>If statement / conditional expression. <c>if (condition) trueExpr else falseExpr</c></summary>
             <remarks>
             The condition must return StackType.I4, use comparison instructions like Ceq to check if other types are non-zero.
            
             If the condition evaluates to non-zero, the TrueInst is executed.
             If the condition evaluates to zero, the FalseInst is executed.
             The return value of the IfInstruction is the return value of the TrueInst or FalseInst.
             
             IfInstruction is also used to represent logical operators:
               "a || b" ==> if (a) (ldc.i4 1) else (b)
               "a &amp;&amp; b" ==> if (a) (b) else (ldc.i4 0)
               "a ? b : c" ==> if (a) (b) else (c)
             </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.IfInstruction.IsInConditionSlot(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether the input instruction occurs in a context where it is being compared with 0.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.SwitchInstruction">
            <summary>Switch statement</summary>
            <summary>
            Generalization of IL switch-case: like a VB switch over integers, this instruction
            supports integer value ranges as labels.
            
            The section labels are using 'long' as integer type.
            If the Value instruction produces StackType.I4 or I, the value is implicitly sign-extended to I8.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.SwitchInstruction.IsLifted">
            <summary>
            If the switch instruction is lifted, the value instruction produces a value of type <c>Nullable{T}</c> for some
            integral type T. The section with <c>SwitchSection.HasNullLabel</c> is called if the value is null.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.SwitchSection">
            <summary>Switch section within a switch statement</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.SwitchSection.HasNullLabel">
            <summary>
            If true, serves as 'case null' in a lifted switch.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.SwitchSection.Labels">
            <summary>
            The set of labels that cause execution to jump to this switch section.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.TryCatch">
            <summary>Try-catch statement.</summary>
            <summary>
            Try-catch statement.
            </summary>
            <remarks>
            The return value of the try or catch blocks is ignored, the TryCatch always returns void.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.TryCatchHandler">
            <summary>Catch handler within a try-catch statement.</summary>
            <summary>
            Catch handler within a try-catch statement.
            
            When an exception occurs in the try block of the parent try.catch statement, the runtime searches
            the nearest enclosing TryCatchHandler with a matching variable type and
            assigns the exception object to the <see cref="P:ICSharpCode.Decompiler.IL.TryCatchHandler.Variable"/>, and executes the <see cref="P:ICSharpCode.Decompiler.IL.TryCatchHandler.Filter"/>.
            If the filter evaluates to 0, the exception is not caught and the runtime looks for the next catch handler.
            If the filter evaluates to 1, the stack is unwound, the exception caught and assigned to the <see cref="P:ICSharpCode.Decompiler.IL.TryCatchHandler.Variable"/>,
            and the <see cref="P:ICSharpCode.Decompiler.IL.TryCatchHandler.Body"/> is executed.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.TryCatchHandler.ExceptionSpecifierILRange">
            <summary>
            Gets the ILRange of the instructions at the start of the catch-block,
            that take the exception object and store it in the exception variable slot.
            Note: This range is empty, if Filter is not empty, i.e., ldloc 1.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.TryFinally">
            <summary>Try-finally statement</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.TryFault">
            <summary>Try-fault statement</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.DebugBreak">
            <summary>Breakpoint instruction</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Comp">
            <summary>Comparison. The inputs must be both integers; or both floats; or both object references. Object references can only be compared for equality or inequality. Floating-point comparisons evaluate to 0 (false) when an input is NaN, except for 'NaN != NaN' which evaluates to 1 (true).</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Comp.InputType">
            <summary>
            Gets the stack type of the comparison inputs.
            For lifted comparisons, this is the underlying input type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Comp.Sign">
            <summary>
            If this is an integer comparison, specifies the sign used to interpret the integers.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Call">
            <summary>Non-virtual method call.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Call.IsLifted">
            <summary>
            Calls can only be lifted when calling a lifted operator.
            Note that the semantics of such a lifted call depend on the type of operator:
            we follow C# semantics here.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.CallVirt">
            <summary>Virtual method call.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Ckfinite">
            <summary>Checks that the input float is not NaN or infinite.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Conv">
            <summary>Numeric cast.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Conv.Kind">
            <summary>
            Gets the conversion kind.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Conv.CheckForOverflow">
            <summary>
            Gets whether the conversion performs overflow-checking.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Conv.IsLifted">
            <summary>
            Gets whether this conversion is a lifted nullable conversion.
            </summary>
            <remarks>
            A lifted conversion expects its argument to be a value of type Nullable{T}, where
            T.GetStackType() == conv.InputType.
            If the value is non-null:
             * it is sign/zero-extended to InputType (based on T's sign)
             * the underlying conversion is performed
             * the result is wrapped in a Nullable{TargetType}.
            If the value is null, the conversion evaluates to default(TargetType?).
            (this result type is underspecified, since there may be multiple C# types for the TargetType)
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Conv.InputType">
            <summary>
            Gets the stack type of the input type.
            </summary>
            <remarks>
            For non-lifted conversions, this is equal to <c>Argument.ResultType</c>.
            For lifted conversions, corresponds to the underlying type of the argument.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Conv.InputSign">
            <summary>
            Gets the sign of the input type.
            
            For conversions to integer types, the input Sign is set iff overflow-checking is enabled.
            For conversions to floating-point types, the input sign is always set.
            </summary>
            <remarks>
            The input sign does not have any effect on whether the conversion zero-extends or sign-extends;
            that is purely determined by the <c>TargetType</c>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.Conv.TargetType">
            <summary>
            The target type of the conversion.
            </summary>
            <remarks>
            For lifted conversions, corresponds to the underlying target type.
            
            Target type == PrimitiveType.None can happen for implicit conversions to O in invalid IL.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.Conv.GetConversionKind(ICSharpCode.Decompiler.IL.PrimitiveType,ICSharpCode.Decompiler.IL.StackType,ICSharpCode.Decompiler.TypeSystem.Sign)">
            <summary>
            Implements Ecma-335 Table 8: Conversion Operators.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdLoc">
            <summary>Loads the value of a local variable. (ldarg/ldloc)</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdLoca">
            <summary>Loads the address of a local variable. (ldarga/ldloca)</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.AddressOf">
            <summary>Stores the value into an anonymous temporary variable, and returns the address of that variable.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.AddressOf.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdStr">
            <summary>Loads a constant string.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdcI4">
            <summary>Loads a constant 32-bit integer.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdcI8">
            <summary>Loads a constant 64-bit integer.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdcF4">
            <summary>Loads a constant 32-bit floating-point number.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdcF8">
            <summary>Loads a constant 64-bit floating-point number.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdcDecimal">
            <summary>Loads a constant decimal.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdNull">
            <summary>Loads the null reference.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdFtn">
            <summary>Load method pointer</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdFtn.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdVirtFtn">
            <summary>Load method pointer</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdVirtFtn.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdVirtDelegate">
            <summary>Virtual delegate construction</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdVirtDelegate.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdVirtDelegate.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdTypeToken">
            <summary>Loads runtime representation of metadata token</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdTypeToken.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdMemberToken">
            <summary>Loads runtime representation of metadata token</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdMemberToken.Member">
            <summary>Returns the token operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LocAlloc">
            <summary>Allocates space in the stack frame</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LocAllocSpan">
            <summary>Allocates space in the stack frame and wraps it in a Span</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LocAllocSpan.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Cpblk">
            <summary>memcpy(destAddress, sourceAddress, size);</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Cpblk.IsVolatile">
            <summary>Gets/Sets whether the memory access is volatile.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Cpblk.UnalignedPrefix">
            <summary>Returns the alignment specified by the 'unaligned' prefix; or 0 if there was no 'unaligned' prefix.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Initblk">
            <summary>memset(address, value, size)</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Initblk.IsVolatile">
            <summary>Gets/Sets whether the memory access is volatile.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Initblk.UnalignedPrefix">
            <summary>Returns the alignment specified by the 'unaligned' prefix; or 0 if there was no 'unaligned' prefix.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdsFlda">
            <summary>Load static field address</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdsFlda.Field">
            <summary>Returns the field operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.CastClass">
            <summary>Casts an object to a class.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.CastClass.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.IsInst">
            <summary>Test if object is instance of class or interface.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.IsInst.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdObj">
            <summary>Indirect load (ref/pointer dereference).</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdObj.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdObj.IsVolatile">
            <summary>Gets/Sets whether the memory access is volatile.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdObj.UnalignedPrefix">
            <summary>Returns the alignment specified by the 'unaligned' prefix; or 0 if there was no 'unaligned' prefix.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Box">
            <summary>Boxes a value.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Box.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Unbox">
            <summary>Compute address inside box.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.Unbox.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.UnboxAny">
            <summary>Unbox a value.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.UnboxAny.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NewObj">
            <summary>Creates an object instance and calls the constructor.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.NewArr">
            <summary>Creates an array instance.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.NewArr.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Throw">
            <summary>Throws an exception.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.Rethrow">
            <summary>Rethrows the current exception.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.SizeOf">
            <summary>Gets the size of a type in bytes.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.SizeOf.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdLen">
            <summary>Returns the length of an array as 'native unsigned int'.</summary>
            <summary>
            Description of LdLen.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.LdElema">
            <summary>Load address of array element.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdElema.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.LdElema.IsReadOnly">
            <summary>Gets whether the 'readonly' prefix was applied to this instruction.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.GetPinnableReference">
            <summary>Retrieves a pinnable reference for the input object.
            The input must be an object reference (O).
            If the input is an array/string, evaluates to a reference to the first element/character, or to a null reference if the array is null or empty.
            Otherwise, uses the GetPinnableReference method to get the reference, or evaluates to a null reference if the input is null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.GetPinnableReference.Method">
            <summary>Returns the method operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.MakeRefAny">
            <summary>Push a typed reference of type class onto the stack.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.MakeRefAny.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.RefAnyType">
            <summary>Push the type token stored in a typed reference.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.RefAnyValue">
            <summary>Push the address stored in a typed reference.</summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.RefAnyValue.Type">
            <summary>Returns the type operand.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.YieldReturn">
            <summary>Yield an element from an iterator.</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILVisitor">
            <summary>
            Base class for visitor pattern.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILVisitor.Default(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>Called by Visit*() methods that were not overridden</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILVisitor`1">
            <summary>
            Base class for visitor pattern.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILVisitor`1.Default(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>Called by Visit*() methods that were not overridden</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILVisitor`2">
            <summary>
            Base class for visitor pattern.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILVisitor`2.Default(ICSharpCode.Decompiler.IL.ILInstruction,`0)">
            <summary>Called by Visit*() methods that were not overridden</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILInstruction">
            <summary>
            Represents a decoded IL instruction
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.IsDescendantOf(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether this node is a descendant of <paramref name="possibleAncestor"/>.
            Also returns true if <c>this</c>==<paramref name="possibleAncestor"/>.
            </summary>
            <remarks>
            This method uses the <c>Parent</c> property, so it may produce surprising results
            when called on orphaned nodes or with a possibleAncestor that contains stale positions
            (see remarks on Parent property).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.IsBefore(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Returns whether this appears before other in a post-order walk of the whole tree.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.ResultType">
            <summary>
            Gets the stack type of the value produced by this instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.Flags">
            <summary>
            Gets the flags describing the behavior of this instruction.
            This property computes the flags on-demand and caches them
            until some change to the ILAst invalidates the cache.
            </summary>
            <remarks>
            Flag cache invalidation makes use of the <c>Parent</c> property,
            so it is possible for this property to return a stale value
            if the instruction contains "stale positions" (see remarks on Parent property).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.HasFlag(ICSharpCode.Decompiler.IL.InstructionFlags)">
            <summary>
            Returns whether the instruction (or one of its child instructions) has at least one of the specified flags.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.HasDirectFlag(ICSharpCode.Decompiler.IL.InstructionFlags)">
            <summary>
            Returns whether the instruction (without considering child instructions) has at least one of the specified flags.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.DirectFlags">
            <summary>
            Gets the flags for this instruction only, without considering the child instructions.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILInstruction.ILRange">
            <summary>
            Gets the ILRange for this instruction alone, ignoring the operands.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.WriteTo(ICSharpCode.Decompiler.ITextOutput,ICSharpCode.Decompiler.IL.ILAstWritingOptions)">
            <summary>
            Writes the ILAst to the text output.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.AcceptVisitor(ICSharpCode.Decompiler.IL.ILVisitor)">
            <summary>
            Calls the Visit*-method on the visitor corresponding to the concrete type of this instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.AcceptVisitor``1(ICSharpCode.Decompiler.IL.ILVisitor{``0})">
            <summary>
            Calls the Visit*-method on the visitor corresponding to the concrete type of this instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.AcceptVisitor``2(ICSharpCode.Decompiler.IL.ILVisitor{``0,``1},``0)">
            <summary>
            Calls the Visit*-method on the visitor corresponding to the concrete type of this instruction.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.Children">
            <summary>
            Gets the child nodes of this instruction.
            </summary>
            <remarks>
            The ChildrenCollection does not actually store the list of children,
            it merely allows accessing the children stored in the various slots.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILInstruction.ChildrenEnumerator">
            <summary>
            Enumerator over the children of an ILInstruction.
            Warning: even though this is a struct, it is invalid to copy:
            the number of constructor calls must match the number of dispose calls.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.ReplaceWith(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Replaces this ILInstruction with the given replacement instruction.
            </summary>
            <remarks>
            It is temporarily possible for a node to be used in multiple places in the ILAst,
            this method only replaces this node at its primary position (see remarks on <see cref="P:ICSharpCode.Decompiler.IL.ILInstruction.Parent"/>).
            
            This means you cannot use ReplaceWith() to wrap an instruction in another node.
            For example, <c>node.ReplaceWith(new BitNot(node))</c> will first call the BitNot constructor,
            which sets <c>node.Parent</c> to the BitNot instance.
            The ReplaceWith() call then attempts to set <c>BitNot.Argument</c> to the BitNot instance,
            which creates a cyclic ILAst. Meanwhile, node's original parent remains unmodified.
            
            The solution in this case is to avoid using <c>ReplaceWith</c>.
            If the parent node is unknown, the following trick can be used:
            <code>
            node.Parent.Children[node.ChildIndex] = new BitNot(node);
            </code>
            Unlike the <c>ReplaceWith()</c> call, this will evaluate <c>node.Parent</c> and <c>node.ChildIndex</c>
            before the <c>BitNot</c> constructor is called, thus modifying the expected position in the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.Descendants">
            <summary>
            Returns all descendants of the ILInstruction in post-order.
            (including the ILInstruction itself)
            </summary>
            <remarks>
            Within a loop 'foreach (var node in inst.Descendants)', it is illegal to
            add or remove from the child collections of node's ancestors, as those are
            currently being enumerated.
            Note that it is valid to modify node's children as those were already previously visited.
            As a special case, it is also allowed to replace node itself with another node.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.Ancestors">
            <summary>
            Gets the ancestors of this node (including the node itself as first element).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILInstruction.refCount">
            <summary>
            Number of parents that refer to this instruction and are connected to the root.
            Usually is 0 for unconnected nodes and 1 for connected nodes, but may temporarily increase to 2
            when the ILAst is re-arranged (e.g. within SetChildInstruction),
            or possibly even more (re-arrangement with stale positions).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.IsConnected">
            <summary>
            Gets whether this ILInstruction is connected to the root node of the ILAst.
            </summary>
            <remarks>
            This property returns true if the ILInstruction is reachable from the root node
            of the ILAst; it does not make use of the <c>Parent</c> field so the considerations
            about orphaned nodes and stale positions don't apply.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.Connected">
            <summary>
            Called after the ILInstruction was connected to the root node of the ILAst.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.Disconnected">
            <summary>
            Called after the ILInstruction was disconnected from the root node of the ILAst.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.Parent">
            <summary>
            Gets the parent of this ILInstruction.
            </summary>
            <remarks>
            It is temporarily possible for a node to be used in multiple places in the ILAst
            (making the ILAst a DAG instead of a tree).
            The <c>Parent</c> and <c>ChildIndex</c> properties are written whenever
            a node is stored in a slot.
            The node's occurrence in that slot is termed the "primary position" of the node,
            and all other (older) uses of the nodes are termed "stale positions".
            
            A consistent ILAst must not contain any stale positions.
            Debug builds of ILSpy check the ILAst for consistency after every IL transform.
            
            If a slot containing a node is overwritten with another node, the <c>Parent</c>
            and <c>ChildIndex</c> of the old node are not modified.
            This allows overwriting stale positions to restore consistency of the ILAst.
            
            If a "primary position" is overwritten, the <c>Parent</c> of the old node also remains unmodified.
            This makes the old node an "orphaned node".
            Orphaned nodes may later be added back to the ILAst (or can just be garbage-collected).
            
            Note that is it is possible (though unusual) for a stale position to reference an orphaned node.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.ChildIndex">
            <summary>
            Gets the index of this node in the <c>Parent.Children</c> collection.
            </summary>
            <remarks>
            It is temporarily possible for a node to be used in multiple places in the ILAst,
            this property returns the index of the primary position of this node (see remarks on <see cref="P:ICSharpCode.Decompiler.IL.ILInstruction.Parent"/>).
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILInstruction.SlotInfo">
            <summary>
            Gets information about the slot in which this instruction is stored.
            (i.e., the relation of this instruction to its parent instruction)
            </summary>
            <remarks>
            It is temporarily possible for a node to be used in multiple places in the ILAst,
            this property returns the slot of the primary position of this node (see remarks on <see cref="P:ICSharpCode.Decompiler.IL.ILInstruction.Parent"/>).
            
            Precondition: this node must not be orphaned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.SetChildInstruction``1(``0@,``0,System.Int32)">
            <summary>
            Replaces a child of this ILInstruction.
            </summary>
            <param name="childPointer">Reference to the field holding the child</param>
            <param name="newValue">New child</param>
            <param name="index">Index of the field in the Children collection</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.InstructionCollectionAdded(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Called when a new child is added to a InstructionCollection.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.InstructionCollectionRemoved(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Called when a child is removed from a InstructionCollection.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.InstructionCollectionUpdateComplete">
            <summary>
            Called when a series of add/remove operations on the InstructionCollection is complete.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.Clone">
            <summary>
            Creates a deep clone of the ILInstruction.
            </summary>
            <remarks>
            It is valid to clone nodes with stale positions (see remarks on <c>Parent</c>);
            the result of such a clone will not contain any stale positions (nodes at
            multiple positions will be cloned once per position).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.ShallowClone">
            <summary>
            Creates a shallow clone of the ILInstruction.
            </summary>
            <remarks>
            Like MemberwiseClone(), except that the new instruction starts as disconnected.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.Match(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Attempts to match the specified node against the pattern.
            </summary>
            <c>this</c>: The syntactic pattern.
            <param name="node">The syntax node to test against the pattern.</param>
            <returns>
            Returns a match object describing the result of the matching operation.
            Check the <see cref="P:ICSharpCode.Decompiler.IL.Patterns.Match.Success"/> property to see whether the match was successful.
            For successful matches, the match object allows retrieving the nodes that were matched with the captured groups.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.PerformMatch(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.Patterns.Match@)">
            <summary>
            Attempts matching this instruction against the other instruction.
            </summary>
            <param name="other">The instruction to compare with.</param>
            <param name="match">The match object, used to store global state during the match (such as the results of capture groups).</param>
            <returns>Returns whether the (partial) match was successful.
            If the method returns true, it adds the capture groups (if any) to the match.
            If the method returns false, the match object may remain in a partially-updated state and
            needs to be restored before it can be reused.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.PerformMatch(ICSharpCode.Decompiler.IL.Patterns.ListMatch@,ICSharpCode.Decompiler.IL.Patterns.Match@)">
            <summary>
            Attempts matching this instruction against a list of other instructions (or a part of said list).
            </summary>
            <param name="listMatch">Stores state about the current list match.</param>
            <param name="match">The match object, used to store global state during the match (such as the results of capture groups).</param>
            <returns>Returns whether the (partial) match was successful.
            If the method returns true, it updates listMatch.SyntaxIndex to point to the next node that was not part of the match,
            and adds the capture groups (if any) to the match.
            If the method returns false, the listMatch and match objects remain in a partially-updated state and need to be restored
            before they can be reused.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.Extract">
            <summary>
            Extracts the this instruction.
              The instruction is replaced with a load of a new temporary variable;
              and the instruction is moved to a store to said variable at block-level.
              Returns the new variable.
            
            If extraction is not possible, the ILAst is left unmodified and the function returns null.
            May return null if extraction is not possible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.PrepareExtract(System.Int32,ICSharpCode.Decompiler.IL.Transforms.ExtractionContext)">
            <summary>
            Prepares "extracting" a descendant instruction out of this instruction.
            This is the opposite of ILInlining. It may involve re-compiling high-level constructs into lower-level constructs.
            </summary>
            <returns>True if extraction is possible; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.CanInlineIntoSlot(System.Int32,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether the specified instruction may be inlined into the specified slot.
            Note: this does not check whether reordering with the previous slots is valid; only wheter the target slot supports inlining at all!
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLdcI(System.Int64@)">
            <summary>
            Matches ldc.i4, ldc.i8, and extending conversions.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLdLocRef(ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Matches either ldloc (if the variable is a reference type), or ldloca (otherwise).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLdLocRef(ICSharpCode.Decompiler.IL.ILVariable@)">
            <summary>
            Matches either ldloc (if the variable is a reference type), or ldloca (otherwise).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchIfInstruction(ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches an if instruction where the false instruction is a nop.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLogicAnd(ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches a 'logic and' instruction ("if (a) b else ldc.i4 0").
            Note: unlike C# '&amp;&amp;', this instruction is not limited to booleans,
            but allows passing through arbitrary I4 values on the rhs (but not on the lhs).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLogicOr(ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches a 'logic or' instruction ("if (a) ldc.i4 1 else b").
            Note: unlike C# '||', this instruction is not limited to booleans,
            but allows passing through arbitrary I4 values on the rhs (but not on the lhs).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchLogicNot(ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches an logical negation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchCompEquals(ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches comp(left == right) or logic.not(comp(left != right)).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchCompEqualsNull(ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches 'comp(arg == ldnull)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchCompNotEqualsNull(ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches 'comp(arg != ldnull)'
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.MatchCompNotEquals(ICSharpCode.Decompiler.IL.ILInstruction@,ICSharpCode.Decompiler.IL.ILInstruction@)">
            <summary>
            Matches comp(left != right) or logic.not(comp(left == right)).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILInstruction.UnwrapConv(ICSharpCode.Decompiler.IL.ConversionKind)">
            <summary>
            If this instruction is a conversion of the specified kind, return its argument.
            Otherwise, return the instruction itself.
            </summary>
            <remarks>
            Does not unwrap lifted conversions.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ComparisonLiftingKind.None">
            <summary>
            Not a lifted comparison.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ComparisonLiftingKind.CSharp">
            <summary>
            C#-style lifted comparison:
            * operands that have a ResultType != this.InputType are expected to return a value of
              type Nullable{T}, where T.GetStackType() == this.InputType.
            * if both operands are <c>null</c>, equality comparisons evaluate to 1, all other comparisons to 0.
            * if one operand is <c>null</c>, inequality comparisons evaluate to 1, all other comparisons to 0.
            * if neither operand is <c>null</c>, the underlying comparison is performed.
            
            Note that even though C#-style lifted comparisons set IsLifted=true,
            the ResultType remains I4 as with normal comparisons.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ComparisonLiftingKind.ThreeValuedLogic">
            <summary>
            SQL-style lifted comparison: works like a lifted binary numeric instruction,
            that is, if any input operand is <c>null</c>, the comparison evaluates to <c>null</c>.
            </summary>
            <remarks>
            This lifting kind is currently only used for operator! on bool?.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.ControlFlow">
            <summary>
            Block is used for control flow.
            All blocks in block containers must have this type.
            Control flow blocks cannot evaluate to a value (FinalInstruction must be Nop).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.ArrayInitializer">
            <summary>
            Block is used for array initializers, e.g. `new int[] { expr1, expr2 }`.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.CallInlineAssign">
            <summary>
            Block is used for using the result of a property setter inline.
            Example: <code>Use(this.Property = value);</code>
            This is only for inline assignments to property or indexers; other inline assignments work
            by using the result value of the stloc/stobj instructions.
            
            Constructed by TransformAssignment.
            Can be deconstructed using Block.MatchInlineAssignBlock().
            </summary>
            <example>
            Block {
              call setter(..., stloc s(...))
              final: ldloc s
            }
            </example>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.CallWithNamedArgs">
            <summary>
            Call using named arguments.
            </summary>
            <remarks>
            Each instruction is assigning to a new local.
            The final instruction is a call.
            The locals for this block have exactly one store and
            exactly one load, which must be an immediate argument to the call.
            </remarks>
            <example>
            Block {
              stloc arg0 = ...
              stloc arg1 = ...
              final: call M(..., arg1, arg0, ...)
            }
            </example>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.DeconstructionConversions">
            <summary>
            <see cref="T:ICSharpCode.Decompiler.IL.DeconstructInstruction"/>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockKind.DeconstructionAssignments">
            <summary>
            <see cref="T:ICSharpCode.Decompiler.IL.DeconstructInstruction"/>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.Normal">
            <summary>
            Normal container that contains control-flow blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.Loop">
            <summary>
            A while-true loop.
            Continue is represented as branch to entry-point.
            Return/break is represented as leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.Switch">
            <summary>
            Container that has a switch instruction as entry-point.
            Goto case is represented as branch.
            Break is represented as leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.While">
            <summary>
            while-loop.
            The entry-point is a block consisting of a single if instruction
            that if true: jumps to the head of the loop body,
            if false: leaves the block.
            Continue is a branch to the entry-point.
            Break is a leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.DoWhile">
            <summary>
            do-while-loop.
            The entry-point is a block that is the head of the loop body.
            The last block consists of a single if instruction
            that if true: jumps to the head of the loop body,
            if false: leaves the block.
            Only the last block is allowed to jump to the entry-point.
            Continue is a branch to the last block.
            Break is a leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ContainerKind.For">
            <summary>
            for-loop.
            The entry-point is a block consisting of a single if instruction
            that if true: jumps to the head of the loop body,
            if false: leaves the block.
            The last block is the increment block.
            Only the last block is allowed to jump to the entry-point.
            Continue is a branch to the last block.
            Break is a leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundEvalMode.EvaluatesToOldValue">
            <summary>
            The compound.assign instruction will evaluate to the old value.
            This mode is used only for post-increment/decrement.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundEvalMode.EvaluatesToNewValue">
            <summary>
            The compound.assign instruction will evaluate to the new value.
            This mode is used for compound assignments and pre-increment/decrement.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundTargetKind.Address">
            <summary>
            The target is an instruction computing an address,
            and the compound.assign will implicitly load/store from/to that address.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundTargetKind.Property">
            <summary>
            The Target must be a call to a property getter,
            and the compound.assign will implicitly call the corresponding property setter.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.CompoundTargetKind.Dynamic">
            <summary>
            The target is a dynamic call.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ConversionKind">
            <summary>
            Semantic meaning of a <c>Conv</c> instruction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.Invalid">
            <summary>
            Invalid conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.Nop">
            <summary>
            Conversion between two types of same size.
            Can be used to change the sign of integer types, which may involve overflow-checking.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.IntToFloat">
            <summary>
            Integer-to-float conversion.
            Uses <c>InputSign</c> to decide whether the integer should be treated as signed or unsigned.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.FloatToInt">
            <summary>
            Float-to-integer conversion.
            Truncates toward zero; may perform overflow-checking.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.FloatPrecisionChange">
            <summary>
            Converts from the current precision available on the evaluation stack to the precision specified by
            the <c>TargetType</c>.
            Uses "round-to-nearest" mode if the precision is reduced.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.SignExtend">
            <summary>
            Conversion of integer type to larger signed integer type.
            May involve overflow checking (when converting from U4 to I on 32-bit).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.ZeroExtend">
            <summary>
            Conversion of integer type to larger unsigned integer type.
            May involve overflow checking (when converting from a signed type).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.Truncate">
            <summary>
            Conversion to smaller integer type.
            
            May involve overflow checking.
            </summary>
            <remarks>
            If the target type is smaller than the minimum stack width of 4 bytes,
            then the result of the conversion is zero extended (if the target type is unsigned)
            or sign-extended (if the target type is signed).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.StopGCTracking">
            <summary>
            Used to convert managed references/objects to unmanaged pointers.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.StartGCTracking">
            <summary>
            Used to convert unmanaged pointers to managed references.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ConversionKind.ObjectInterior">
            <summary>
            Converts from an object reference (O) to an interior pointer (Ref) pointing to the start of the object.
            </summary>
            <remarks>
            C++/CLI emits "ldarg.1; stloc.0" where arg1 is a string and loc0 is "ref byte" (e.g. as part of the PtrToStringChars codegen);
            we represent this type conversion explicitly in the ILAst.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunctionKind.TopLevelFunction">
            <summary>
            ILFunction is a "top-level" function, i.e., method, accessor, constructor, destructor or operator.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunctionKind.Delegate">
            <summary>
            ILFunction is a delegate or lambda expression.
            </summary>
            <remarks>
            This kind is introduced by the DelegateConstruction and TransformExpressionTrees steps in the decompiler pipeline.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunctionKind.ExpressionTree">
            <summary>
            ILFunction is an expression tree lambda.
            </summary>
            <remarks>
            This kind is introduced by the TransformExpressionTrees step in the decompiler pipeline.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILFunctionKind.LocalFunction">
            <summary>
            ILFunction is a C# 7.0 local function.
            </summary>
            <remarks>
            This kind is introduced by the LocalFunctionDecompiler step in the decompiler pipeline.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILPhase.InILReader">
            <summary>
            Reading the individual instructions.
            * Variables don't have scopes yet as the ILFunction is not created yet.
            * Branches point to IL offsets, not blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILPhase.Normal">
            <summary>
            The usual invariants are established.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILPhase.InAsyncAwait">
            <summary>
            Special phase within the async-await decompiler, where a few selected invariants
            are temporarily suspended. (see Leave.CheckInvariant)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILiftableInstruction.IsLifted">
            <summary>
            Gets whether the instruction was lifted; that is, whether is accepts
            potentially nullable arguments.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILiftableInstruction.UnderlyingResultType">
            <summary>
            If the instruction is lifted and returns a nullable result,
            gets the underlying result type.
            
            Note that not all lifted instructions return a nullable result:
            C# comparisons always return a bool!
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.InstructionCollection`1.Enumerator">
            <summary>
            Custom enumerator for InstructionCollection.
            Unlike List{T}.Enumerator, this enumerator allows replacing an item during the enumeration.
            Adding/removing items from the collection still is invalid (however, such
            invalid actions are only detected in debug builds).
            
            Warning: even though this is a struct, it is invalid to copy:
            the number of constructor calls must match the number of dispose calls.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.InstructionCollection`1.IndexOf(`0)">
            <summary>
            Gets the index of the instruction in this collection.
            Returns -1 if the instruction does not exist in the collection.
            </summary>
            <remarks>
            Runs in O(1) if the item can be found using the Parent/ChildIndex properties.
            Otherwise, runs in O(N).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.InstructionCollection`1.Contains(`0)">
            <summary>
            Gets whether the item is in this collection.
            </summary>
            <remarks>
            This method searches the list.
            Usually it's more efficient to test item.Parent instead!
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.InstructionCollection`1.ReplaceList(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Replaces all entries in the InstructionCollection with the newList.
            </summary>
            <remarks>
            Equivalent to Clear() followed by AddRange(newList), but slightly more efficient.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.InstructionCollection`1.SwapRemoveAt(System.Int32)">
            <summary>
            Remove item at index <c>index</c> in O(1) by swapping it with the last element in the collection.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.InstructionCollection`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all elements for which the predicate returns true.
            </summary>
            <remarks>
            This method runs in O(N), which is more efficient than calling RemoveAt() in a loop.
            The collection may be in an invalid state during the invocation of the predicate.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ISupportsUnalignedPrefix.UnalignedPrefix">
            <summary>
            Returns the alignment specified by the 'unaligned' prefix; or 0 if there was no 'unaligned' prefix.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ISupportsVolatilePrefix.IsVolatile">
            <summary>
            Gets/Sets whether the memory access is volatile.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.SlotInfo">
            <summary>
            Holds information about the role of an instruction within its parent instruction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.SlotInfo.Name">
            <summary>
            Gets the name of the slot.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.SlotInfo.CanInlineInto">
            <summary>
            Gets whether it is possible to inline into this slot.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.SlotInfo.IsCollection">
            <summary>
            Gets whether this slot belongs to a collection.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.SemanticHelper.IsPure(ICSharpCode.Decompiler.IL.InstructionFlags)">
            <summary>
            Gets whether instruction is pure:
            * must not have side effects
            * must not throw exceptions
            * must not branch
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.SemanticHelper.MayReorder(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether the instruction sequence 'inst1; inst2;' may be ordered to 'inst2; inst1;'
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.BlockBuilder.CreateExtendedBlocks">
            <summary>
            Gets/Sets whether to create extended basic blocks instead of basic blocks.
            The default is <c>false</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.ILReader">
            <summary>
            Reads IL bytecodes and converts them into ILAst instructions.
            </summary>
            <remarks>
            Instances of this class are not thread-safe. Use separate instances to decompile multiple members in parallel.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.#ctor(ICSharpCode.Decompiler.TypeSystem.MetadataModule)">
            <summary>
            Creates a new ILReader instance.
            </summary>
            <param name="module">
            The module used to resolve metadata tokens in the type system.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.Warn(System.String)">
            <summary>
            Warn when invalid IL is detected.
            ILSpy should be able to handle invalid IL; but this method can be helpful for debugging the ILReader,
            as this method should not get called when processing valid IL.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.StoreStackForOffset(System.Int32,System.Collections.Immutable.ImmutableStack{ICSharpCode.Decompiler.IL.ILVariable}@)">
            <summary>
            Stores the given stack for a branch to `offset`.
            
            The stack may be modified if stack adjustments are necessary. (e.g. implicit I4->I conversion)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.WriteTypedIL(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodBodyBlock,ICSharpCode.Decompiler.ITextOutput,ICSharpCode.Decompiler.TypeSystem.GenericContext,System.Threading.CancellationToken)">
            <summary>
            Debugging helper: writes the decoded instruction stream interleaved with the inferred evaluation stack layout.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.ReadIL(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodBodyBlock,ICSharpCode.Decompiler.TypeSystem.GenericContext,ICSharpCode.Decompiler.IL.ILFunctionKind,System.Threading.CancellationToken)">
            <summary>
            Decodes the specified method body and returns an ILFunction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILReader.PopLdFldTarget(ICSharpCode.Decompiler.TypeSystem.IField)">
            <summary>
            Like PopFieldTarget, but supports ldfld's special behavior for fields of temporary value types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILTypeExtensions.GetSize(ICSharpCode.Decompiler.IL.PrimitiveType)">
            <summary>
            Gets the size in bytes of the primitive type.
            
            Returns 0 for non-primitive types.
            Returns <c>NativeIntSize</c> for native int/references.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILTypeExtensions.IsSmallIntegerType(ICSharpCode.Decompiler.IL.PrimitiveType)">
            <summary>
            Gets whether the type is a small integer type.
            Small integer types are:
            * bool, sbyte, byte, char, short, ushort
            * any enums that have a small integer type as underlying type
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILTypeExtensions.InferType(ICSharpCode.Decompiler.IL.ILInstruction,ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Infers the C# type for an IL instruction.
            
            Returns SpecialType.UnknownType for unsupported instructions.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.Local">
            <summary>
            A local variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.PinnedLocal">
            <summary>
            A pinned local variable (not associated with a pinned region)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.PinnedRegionLocal">
            <summary>
            A pinned local variable (associated with a pinned region)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.UsingLocal">
            <summary>
            A local variable used as using-resource variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.ForeachLocal">
            <summary>
            A local variable used as foreach variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.InitializerTarget">
            <summary>
            A local variable used inside an array, collection or
            object initializer block to denote the object being initialized.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.Parameter">
            <summary>
            A parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.ExceptionStackSlot">
            <summary>
            Variable created for exception handler.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.ExceptionLocal">
            <summary>
            Local variable used in a catch block.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.StackSlot">
            <summary>
            Variable created from stack slot.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.NamedArgument">
            <summary>
            Variable in BlockKind.CallWithNamedArgs
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.DisplayClassLocal">
            <summary>
            Local variable that holds the display class used for lambdas within this function.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.PatternLocal">
            <summary>
            Local variable declared within a pattern match.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.VariableKind.DeconstructionInitTemporary">
            <summary>
            Temporary variable declared in a deconstruction init section.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.IsRefReadOnly">
            <summary>
            This variable is either a C# 7 'in' parameter or must be declared as 'ref readonly'.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.Index">
            <summary>
            The index of the local variable or parameter (depending on Kind)
            
            For VariableKinds with "Local" in the name:
             * if non-null, the Index refers to the LocalVariableSignature.
             * index may be null for variables that used to be fields (captured by lambda/async)
            For Parameters, the Index refers to the method's list of parameters.
              The special "this" parameter has index -1.
            For ExceptionStackSlot, the index is the IL offset of the exception handler.
            For other kinds, the index has no meaning, and is usually null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.Function">
            <summary>
            Gets the function in which this variable is declared.
            </summary>
            <remarks>
            This property is set automatically when the variable is added to the <c>ILFunction.Variables</c> collection.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.CaptureScope">
            <summary>
            Gets the block container in which this variable is captured.
            For captured variables declared inside the loop, the capture scope is the BlockContainer of the loop.
            For captured variables declared outside of the loop, the capture scope is the BlockContainer of the parent. 
            </summary>
            <remarks>
            This property returns null for variables that are not captured.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.IndexInFunction">
            <summary>
            Gets the index of this variable within the <c>Function.Variables</c> collection.
            </summary>
            <remarks>
            This property is set automatically when the variable is added to the <c>VariableScope.Variables</c> collection.
            It may change if an item with a lower index is removed from the collection.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.LoadCount">
            <summary>
            Number of ldloc instructions referencing this variable.
            </summary>
            <remarks>
            This variable is automatically updated when adding/removing ldloc instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.LoadInstructions">
            <summary>
            List of ldloc instructions referencing this variable.
            </summary>
            <remarks>
            This list is automatically updated when adding/removing ldloc instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.StoreCount">
            <summary>
            Number of store instructions referencing this variable,
            plus 1 if HasInitialValue.
            
            Stores are:
            <list type="item">
            <item>stloc</item>
            <item>TryCatchHandler (assigning the exception variable)</item>
            <item>PinnedRegion (assigning the pointer variable)</item>
            <item>initial values (<see cref="P:ICSharpCode.Decompiler.IL.ILVariable.HasInitialValue"/>)</item>
            </list>
            </summary>
            <remarks>
            This variable is automatically updated when adding/removing stores instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.StoreInstructions">
            <summary>
            List of store instructions referencing this variable.
            
            Stores are:
            <list type="item">
            <item>stloc</item>
            <item>TryCatchHandler (assigning the exception variable)</item>
            <item>PinnedRegion (assigning the pointer variable)</item>
            <item>initial values (<see cref="P:ICSharpCode.Decompiler.IL.ILVariable.HasInitialValue"/>) -- however, there is no instruction for
                  the initial value, so it is not contained in the store list.</item>
            </list>
            </summary>
            <remarks>
            This list is automatically updated when adding/removing stores instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.AddressCount">
            <summary>
            Number of ldloca instructions referencing this variable.
            </summary>
            <remarks>
            This variable is automatically updated when adding/removing ldloca instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.AddressInstructions">
            <summary>
            List of ldloca instructions referencing this variable.
            </summary>
            <remarks>
            This list is automatically updated when adding/removing ldloca instructions from the ILAst.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.HasInitialValue">
            <summary>
            Gets/Sets whether the variable has an initial value.
            This is always <c>true</c> for parameters (incl. <c>this</c>).
            
            Normal variables have an initial value if the function uses ".locals init"
            and that initialization is not a dead store.
            </summary>
            <remarks>
            An initial value is counted as a store (adds 1 to StoreCount)
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.IsSingleDefinition">
            <summary>
            Gets whether the variable is in SSA form:
            There is exactly 1 store, and every load sees the value from that store.
            </summary>
            <remarks>
            Note: the single store is not necessary a store instruction, it might also
            be the use of the implicit initial value.
            For example: for parameters, IsSingleDefinition will only return true if
            the parameter is never assigned to within the function.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.IL.ILVariable.IsDead">
            <summary>
            Gets whether the variable is dead - unused.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.ILVariable.StateMachineField">
            <summary>
            The field which was converted to a local variable.
            Set when the variable is from a 'yield return' or 'async' state machine.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.IL.ILVariable.IsUsedWithin(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Gets whether this variable occurs within the specified instruction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.MayReadLocals">
            <summary>
            The instruction may read from local variables.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.MayWriteLocals">
            <summary>
            The instruction may write to local variables.
            </summary>
            <remarks>
            This flag is not set for indirect writes to local variables through pointers.
            Ensure you also check the SideEffect flag when checking for instructions that might write to locals.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.SideEffect">
            <summary>
            The instruction may have side effects, such as accessing heap memory,
            performing system calls, writing to local variables through pointers, etc.
            </summary>
            <remarks>
            Throwing an exception or directly writing to local variables
            is not considered a side effect, and is modeled by separate flags.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.MayThrow">
            <summary>
            The instruction may throw an exception.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.MayBranch">
            <summary>
            The instruction may exit with a branch or leave.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.MayUnwrapNull">
            <summary>
            The instruction may jump to the closest containing <c>nullable.rewrap</c> instruction.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.EndPointUnreachable">
            <summary>
            The instruction performs unconditional control flow, so that its endpoint is unreachable.
            </summary>
            <remarks>
            If EndPointUnreachable is set, either MayThrow or MayBranch should also be set
            (unless the instruction represents an infinite loop).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.InstructionFlags.ControlFlow">
            <summary>
            The instruction contains some kind of internal control flow.
            </summary>
            <remarks>
            If this flag is not set, all descendants of the instruction are fully evaluated (modulo MayThrow/MayBranch/MayUnwrapNull)
            in left-to-right pre-order.
            
            Note that branch instructions don't have this flag set, because their control flow is not internal
            (and they don't have any unusual argument evaluation rules).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.PrimitiveType.Ref">
            <summary>Managed reference</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.PrimitiveType.R">
            <summary>Floating point type of unspecified size:
            usually 80 bits on x86 (when the runtime uses x87 instructions);
            but only 64-bit on x64.
            This only occurs for "conv.r.un" instructions. The C# compiler usually follows those
            with a "conv.r4" or "conv.r8" instruction to indicate the desired float type, so
            we only use this as conversion target type and don't bother tracking it as its own stack type:
            basically everything treats R identical to R8, except for the (conv.r.un + conv.r[48] => conv.r[48].un)
            combining logic which should not combine (conv.r.un + conv.r8 + conv.r4) into a single conv.r4.un.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.IL.StackType">
            <summary>
            A type for the purpose of stack analysis.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.Unknown">
            <summary>
            The stack type is unknown; for example a call returning an unknown type
            because an assembly reference isn't loaded.
            Can also occur with invalid IL.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.I4">
            <summary>32-bit integer</summary>
            <remarks>
            Used for C# <c>int</c>, <c>uint</c>,
            C# small integer types <c>byte</c>, <c>sbyte</c>, <c>short</c>, <c>ushort</c>,
            <c>bool</c> and <c>char</c>,
            and any enums with one of the above as underlying type.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.I">
            <summary>native-size integer, or unmanaged pointer</summary>
            <remarks>
            Used for C# <c>IntPtr</c>, <c>UIntPtr</c> and any native pointer types (<c>void*</c> etc.)
            Also used for IL function pointer types.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.I8">
            <summary>64-bit integer</summary>
            <remarks>
            Used for C# <c>long</c>, <c>ulong</c>,
            and any enums with one of the above as underlying type.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.F4">
            <summary>32-bit floating point number</summary>
            <remarks>
            Used for C# <c>float</c>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.F8">
            <summary>64-bit floating point number</summary>
            <remarks>
            Used for C# <c>double</c>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.O">
            <summary>Another stack type. Includes objects, value types, ...</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.Ref">
            <summary>A managed pointer</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.IL.StackType.Void">
            <summary>Represents the lack of a stack slot</summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.DebugInfo.DebugInfoGenerator">
            <summary>
            Visitor that generates debug information.
            
            The intended usage is to create a new instance for each source file,
            and call syntaxTree.AcceptVisitor(debugInfoGenerator) to fill the internal debug info tables.
            This can happen concurrently for multiple source files.
            Then the main thread calls Generate() to write out the results into the PDB.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DebugInfo.DebugInfoGenerator.Functions">
            <summary>
            Gets all functions with bodies that were seen by the visitor so far.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.DebugInfo.SequencePoint">
            <summary>
            A sequence point read from a PDB file or produced by the decompiler.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DebugInfo.SequencePoint.Offset">
            <summary>
            IL start offset.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DebugInfo.SequencePoint.EndOffset">
            <summary>
            IL end offset.
            </summary>
            <remarks>
            This does not get stored in debug information;
            it is used internally to create hidden sequence points
            for the IL fragments not covered by any sequence point.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILNameSyntax.Signature">
            <summary>
            class/valuetype + TypeName (built-in types use keyword syntax)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILNameSyntax.SignatureNoNamedTypeParameters">
            <summary>
            Like signature, but always refers to type parameters using their position
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILNameSyntax.TypeName">
            <summary>
            [assembly]Full.Type.Name (even for built-in types)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILNameSyntax.ShortTypeName">
            <summary>
            Name (but built-in types use keyword syntax)
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Disassembler.ILStructureType">
            <summary>
            Specifies the type of an IL structure.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Root">
            <summary>
            The root block of the method
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Loop">
            <summary>
            A nested control structure representing a loop.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Try">
            <summary>
            A nested control structure representing a try block.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Handler">
            <summary>
            A nested control structure representing a catch, finally, or fault block.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Filter">
            <summary>
            A nested control structure representing an exception filter block.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Disassembler.ILStructure">
            <summary>
            An IL structure.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.StartOffset">
            <summary>
            Start position of the structure.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.EndOffset">
            <summary>
            End position of the structure. (exclusive)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.ExceptionHandler">
            <summary>
            The exception handler associated with the Try, Filter or Handler block.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.LoopEntryPointOffset">
            <summary>
            The loop's entry point.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.Children">
            <summary>
            The list of child structures.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Disassembler.ILStructure.FindAllBranches(System.Reflection.Metadata.BlobReader)">
            <summary>
            Finds all branches. Returns list of source offset->target offset mapping.
            Multiple entries for the same source offset are possible (switch statements).
            The result is sorted by source offset.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Disassembler.ILStructure.GetInnermost(System.Int32)">
            <summary>
            Gets the innermost structure containing the specified offset.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler">
            <summary>
            Disassembles a method body.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler.DetectControlStructure">
            <summary>
            Show .try/finally as blocks in IL code; indent loops.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler.ShowSequencePoints">
            <summary>
            Show sequence points if debug information is loaded in Cecil.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler.ShowMetadataTokens">
            <summary>
            Show metadata tokens for instructions with token operands.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler.ShowMetadataTokensInBase10">
            <summary>
            Show metadata tokens for instructions with token operands in base 10.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler.DebugInfo">
            <summary>
            Optional provider for sequence points.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Disassembler.ReflectionDisassembler">
            <summary>
            Disassembles type and member definitions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement">
            <summary>
            Represents an element in the XML documentation.
            Any occurrences of "&lt;inheritdoc/>" are replaced with the inherited documentation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.nestingLevel">
            <summary>
            Inheritance level; used to prevent cyclic doc inheritance.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.#ctor(System.Xml.Linq.XElement,ICSharpCode.Decompiler.TypeSystem.IEntity,System.Func{System.String,ICSharpCode.Decompiler.TypeSystem.IEntity})">
            <summary>
            Creates a new documentation element.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.#ctor(System.String,ICSharpCode.Decompiler.TypeSystem.IEntity)">
            <summary>
            Creates a new documentation element.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.DeclaringEntity">
            <summary>
            Gets the entity on which this documentation was originally declared.
            May return null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.ReferencedEntity">
            <summary>
            Gets the entity referenced by the 'cref' attribute.
            May return null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.Name">
            <summary>
            Gets the element name.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.GetAttribute(System.String)">
            <summary>
            Gets the attribute value.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.IsTextNode">
            <summary>
            Gets whether this is a pure text node.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.TextContent">
            <summary>
            Gets the text content.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.Children">
            <summary>
            Gets the child elements.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationElement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.GetPotentiallyNestedClassTypeReference">
            <summary>
            A type reference of the form 'Some.Namespace.TopLevelType.NestedType`n'.
            We do not know the boundary between namespace name and top level type, so we have to try
            all possibilities.
            The type parameter count only applies to the innermost type, all outer types must be non-generic.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.GetPotentiallyNestedClassTypeReference.ResolveInPEFile(ICSharpCode.Decompiler.Metadata.PEFile)">
            <summary>
            Resolves the type reference within the context of the given PE file.
            </summary>
            <returns>Either TypeDefinitionHandle, if the type is defined in the module or ExportedTypeHandle,
            if the module contains a type forwarder. Returns a nil handle, if the type was not found.</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.IdStringProvider">
            <summary>
            Provides ID strings for entities. (C# 4.0 spec, A.3.1)
            ID strings are used to identify members in XML documentation files.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.IdStringProvider.GetIdString(ICSharpCode.Decompiler.TypeSystem.IEntity)">
            <summary>
            Gets the ID string (C# 4.0 spec, A.3.1) for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.IdStringProvider.ParseMemberIdString(System.String)">
            <summary>
            Parse the ID string into a member reference.
            </summary>
            <param name="memberIdString">The ID string representing the member (with "M:", "F:", "P:" or "E:" prefix).</param>
            <returns>A member reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            The member reference will look in <see cref="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentModule"/> first,
            and if the member is not found there,
            it will look in all other assemblies of the compilation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.IdStringProvider.ParseTypeName(System.String)">
            <summary>
            Parse the ID string type name into a type reference.
            </summary>
            <param name="typeName">The ID string representing the type (the "T:" prefix is optional).</param>
            <returns>A type reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            <para>
            The type reference will look in <see cref="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentModule"/> first,
            and if the type is not found there,
            it will look in all other assemblies of the compilation.
            </para>
            <para>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the reference to the ITypeParameter.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.IdStringProvider.FindEntity(System.String,ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext)">
            <summary>
            Finds the entity in the given type resolve context.
            </summary>
            <param name="idString">ID string of the entity.</param>
            <param name="context">Type resolve context</param>
            <returns>Returns the entity, or null if it is not found.</returns>
            <exception cref="T:ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.XmlDocLoader">
            <summary>
            Helps finding and loading .xml documentation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.IDocumentationProvider">
            <summary>
            Provides XML documentation for type and member definitions in source code.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.IDocumentationProvider.GetDocumentation(ICSharpCode.Decompiler.TypeSystem.IEntity)">
            <summary>
            Returns the XML documentation for the given <paramref name="entity"/>.
            May return null, if no documentation is present for the entity.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="entity"/> is null.</exception>
        </member>
        <member name="T:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider">
            <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
            <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            The .xml file is only opened when necessary, the file handle is not kept open all the time.
            If the .xml file is changed, the index will automatically be recreated.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.IndexEntry.HashCode">
            <summary>
            Hash code of the documentation tag
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.IndexEntry.PositionInFile">
            <summary>
            Position in the .xml file where the documentation starts
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.#ctor(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
            <exception cref="T:System.IO.IOException">Error reading from XML file (or from redirected file)</exception>
            <exception cref="T:System.Xml.XmlException">Invalid XML file</exception>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.LookupLocalizedXmlDoc(System.String)">
            <summary>
            Given the assembly file name, looks up the XML documentation file name.
            Returns null if no XML documentation file is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.GetHashCode(System.String)">
            <summary>
            Hash algorithm used for the index.
            This is a custom implementation so that old index files work correctly
            even when the .NET string.GetHashCode implementation changes
            (e.g. due to .NET 4.5 hash randomization)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
            <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.Decompiler.TypeSystem.IEntity)">
            <summary>
            Get the documentation for the specified member.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.OutVarResolveResult">
            <summary>
            Represents the implicitly-typed "out var".
            Special-cased in overload resolution to be compatible with any out-parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.TupleResolveResult">
            <summary>
            Resolve result for a C# 7 tuple literal.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.AmbiguousTypeResolveResult">
            <summary>
            Represents an ambiguous type resolve result.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.AmbiguousMemberResolveResult">
            <summary>
            Represents an ambiguous field/property/event access.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ArrayAccessResolveResult">
            <summary>
            Resolve result representing an array access.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ArrayCreateResolveResult">
            <summary>
            Resolve result representing an array creation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ArrayCreateResolveResult.SizeArguments">
            <summary>
            Gets the size arguments.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ArrayCreateResolveResult.InitializerElements">
            <summary>
            Gets the initializer elements.
            This field may be null if no initializer was specified.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ByReferenceResolveResult">
            <summary>
            Represents the resolve result of an 'ref x', 'in x' or 'out x' expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ConstantResolveResult">
            <summary>
            ResolveResult representing a compile-time constant.
            Note: this class is mainly used for literals; there may be other ResolveResult classes
            which are compile-time constants as well.
            For example, a reference to a <c>const</c> field results in a <see cref="T:ICSharpCode.Decompiler.Semantics.MemberResolveResult"/>.
            
            Check <see cref="P:ICSharpCode.Decompiler.Semantics.ResolveResult.IsCompileTimeConstant"/> to determine is a resolve result is a constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.Conversion">
            <summary>
            Holds information about a conversion between two types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.None">
            <summary>
            Not a valid conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.IdentityConversion">
            <summary>
            Identity conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.ImplicitConstantExpressionConversion">
            <summary>
            The numeric conversion of a constant expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.TryCast">
            <summary>
            C# 'as' cast.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.ImplicitInterpolatedStringConversion">
            <summary>
            C# 6 string interpolation expression implicitly being converted to <see cref="T:System.IFormattable"/> or <see cref="T:System.FormattableString"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.Conversion.ThrowExpressionConversion">
            <summary>
            C# 7 throw expression being converted to an arbitrary type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsValid">
            <summary>
            Gets whether the conversion is valid.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsTryCast">
            <summary>
            Gets whether the conversion is an '<c>as</c>' cast.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsLifted">
            <summary>
            Gets whether this conversion is a lifted version of another conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsDynamicConversion">
            <summary>
            Gets whether the conversion is dynamic.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsReferenceConversion">
            <summary>
            Gets whether the conversion is a reference conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsEnumerationConversion">
            <summary>
            Gets whether the conversion is an enumeration conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsNullableConversion">
            <summary>
            Gets whether the conversion is a nullable conversion
            (conversion between a nullable type and the regular type).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsUserDefined">
            <summary>
            Gets whether this conversion is user-defined (op_Implicit or op_Explicit).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.ConversionBeforeUserDefinedOperator">
            <summary>
            The conversion that is applied to the input before the user-defined conversion operator is invoked.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.ConversionAfterUserDefinedOperator">
            <summary>
            The conversion that is applied to the result of the user-defined conversion operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsBoxingConversion">
            <summary>
            Gets whether this conversion is a boxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsUnboxingConversion">
            <summary>
            Gets whether this conversion is an unboxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsPointerConversion">
            <summary>
            Gets whether this conversion is a pointer conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsMethodGroupConversion">
            <summary>
            Gets whether this conversion is a method group conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsVirtualMethodLookup">
            <summary>
            For method-group conversions, gets whether to perform a virtual method lookup at runtime.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.DelegateCapturesFirstArgument">
            <summary>
            For method-group conversions, gets whether the conversion captures the first argument.
            
            For instance methods, this property always returns true for C# method-group conversions.
            For static methods, this property returns true for method-group conversions of an extension method performed on an instance (eg. <c>Func&lt;int&gt; f = myEnumerable.Single</c>).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsAnonymousFunctionConversion">
            <summary>
            Gets whether this conversion is an anonymous function conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.Method">
            <summary>
            Gets the method associated with this conversion.
            For user-defined conversions, this is the method being called.
            For method-group conversions, this is the method that was chosen from the group.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsTupleConversion">
            <summary>
            Gets whether this conversion is a tuple conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.IsInterpolatedStringConversion">
            <summary>
            Gets whether this is an interpolated string conversion to <see cref="T:System.IFormattable" /> or <see cref="T:System.FormattableString"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.Conversion.ElementConversions">
            <summary>
            For a tuple conversion, gets the individual tuple element conversions.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult">
            <summary>
            Represents an implicit or explicit type conversion.
            <c>conversionResolveResult.Input.Type</c> is the source type;
            <c>conversionResolveResult.Type</c> is the target type.
            The <see cref="F:ICSharpCode.Decompiler.Semantics.ConversionResolveResult.Conversion"/> property provides details about the kind of conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ConversionResolveResult.CheckForOverflow">
            <summary>
            For numeric conversions, specifies whether overflow checking is enabled.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ErrorResolveResult">
            <summary>
            Represents a resolve error.
            
            Note: some errors are represented by other classes; for example a <see cref="T:ICSharpCode.Decompiler.Semantics.ConversionResolveResult"/> may
            be erroneous if the conversion is invalid.
            </summary>
            <seealso cref="P:ICSharpCode.Decompiler.Semantics.ResolveResult.IsError"/>.
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ErrorResolveResult.UnknownError">
            <summary>
            Gets an ErrorResolveResult instance with <c>Type</c> = <c>SpecialType.UnknownType</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ForEachResolveResult">
            <summary>
            Resolve result representing a 'foreach' loop.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.GetEnumeratorCall">
            <summary>
            Gets the semantic tree for the call to GetEnumerator.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.CollectionType">
            <summary>
            Gets the collection type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.EnumeratorType">
            <summary>
            Gets the enumerator type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.ElementType">
            <summary>
            Gets the element type.
            This is the type that would be inferred for an implicitly-typed element variable.
            For explicitly-typed element variables, this type may differ from <c>ElementVariable.Type</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.CurrentProperty">
            <summary>
            Gets the Current property on the IEnumerator.
            Returns null if the property is not found.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.ForEachResolveResult.MoveNextMethod">
            <summary>
            Gets the MoveNext() method on the IEnumerator.
            Returns null if the method is not found.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult">
            <summary>
            Refers to the object that is currently being initialized.
            Used within <see cref="F:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.InitializerStatements"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.InvocationResolveResult">
            <summary>
            Represents the result of a method, constructor or indexer invocation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.Arguments">
            <summary>
            Gets the arguments that are being passed to the method, in the order the arguments are being evaluated.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.InitializerStatements">
            <summary>
            Gets the list of initializer statements that are appplied to the result of this invocation.
            This is used to represent object and collection initializers.
            With the initializer statements, the <see cref="T:ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult"/> is used
            to refer to the result of this invocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Semantics.InvocationResolveResult.GetArgumentsForCall">
            <summary>
            Gets the arguments in the order they are being passed to the method.
            For parameter arrays (params), this will return an ArrayCreateResolveResult.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.LocalResolveResult">
            <summary>
            Represents a local variable or parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.MemberResolveResult">
            <summary>
            Represents the result of a member invocation.
            Used for field/property/event access.
            Also, <see cref="T:ICSharpCode.Decompiler.Semantics.InvocationResolveResult"/> derives from MemberResolveResult.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.MemberResolveResult.Member">
            <summary>
            Gets the member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.MemberResolveResult.IsVirtualCall">
            <summary>
            Gets whether this MemberResolveResult is a virtual call.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult">
            <summary>
            Represents a named argument.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult.Member">
            <summary>
            Gets the member to which the parameter belongs.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult.Parameter">
            <summary>
            Gets the parameter.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult.ParameterName">
            <summary>
            Gets the parameter name.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult.Argument">
            <summary>
            Gets the argument passed to the parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.NamespaceResolveResult">
            <summary>
            Represents that an expression resolved to a namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.OperatorResolveResult">
            <summary>
            Represents a unary/binary/ternary operator invocation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.OperatorResolveResult.OperatorType">
            <summary>
            Gets the operator type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.OperatorResolveResult.Operands">
            <summary>
            Gets the operands.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.OperatorResolveResult.UserDefinedOperatorMethod">
            <summary>
            Gets the user defined operator method.
            Returns null if this is a predefined operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.OperatorResolveResult.IsLiftedOperator">
            <summary>
            Gets whether this is a lifted operator.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ResolveResult">
            <summary>
            Represents the result of resolving an expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.SizeOfResolveResult">
            <summary>
            Represents the 'sizeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.SizeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'sizeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.ThisResolveResult">
            <summary>
            Represents the 'this' reference.
            Also used for the 'base' reference.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.ThisResolveResult.CausesNonVirtualInvocation">
            <summary>
            Gets whether this resolve result causes member invocations to be non-virtual.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.TypeIsResolveResult">
            <summary>
            Resolve result for a C# 'is' expression.
            "Input is TargetType".
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Semantics.TypeIsResolveResult.TargetType">
            <summary>
            Type that is being compared with.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.TypeOfResolveResult">
            <summary>
            Represents the 'typeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.TypeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'typeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.TypeResolveResult">
            <summary>
            The resolved expression refers to a type name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.UnknownMemberResolveResult">
            <summary>
            Represents an unknown member.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Semantics.UnknownMemberResolveResult.TargetType">
            <summary>
            The type on which the method is being called.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.UnknownMethodResolveResult">
            <summary>
            Represents an unknown method.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Semantics.UnknownIdentifierResolveResult">
            <summary>
            Represents an unknown identifier.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Solution.ProjectId">
            <summary>
            A container class that holds platform and GUID information about a Visual Studio project.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Solution.ProjectId.#ctor(System.String,System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.Solution.ProjectId"/> class.
            </summary>
            <param name="projectPlatform">The project platform.</param>
            <param name="projectGuid">The project GUID.</param>
            
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="projectPlatform"/> is null or empty.</exception>
        </member>
        <member name="P:ICSharpCode.Decompiler.Solution.ProjectId.Guid">
            <summary>
            Gets the GUID of this project.
            This is usually a newly generated GUID for each decompiled project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Solution.ProjectId.TypeGuid">
            <summary>
            Gets the primary type GUID of this project.
            This is one of the GUIDs from <see cref="T:ICSharpCode.Decompiler.Solution.ProjectTypeGuids"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Solution.ProjectId.PlatformName">
            <summary>
            Gets the platform name of this project. Only single platform per project is supported.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Solution.ProjectItem">
            <summary>
            A container class that holds information about a Visual Studio project.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Solution.ProjectItem.#ctor(System.String,System.String,System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.Solution.ProjectItem"/> class.
            </summary>
            <param name="projectFile">The full path of the project file.</param>
            <param name="projectPlatform">The project platform.</param>
            <param name="projectGuid">The project GUID.</param>
            
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="projectFile"/> 
            or <paramref name="projectPlatform"/> is null or empty.</exception>
        </member>
        <member name="P:ICSharpCode.Decompiler.Solution.ProjectItem.ProjectName">
            <summary>
            Gets the name of the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Solution.ProjectItem.FilePath">
            <summary>
            Gets the full path to the project file.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Solution.SolutionCreator">
            <summary>
            A helper class that can write a Visual Studio Solution file for the provided projects.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Solution.SolutionCreator.WriteSolutionFile(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.Solution.ProjectItem})">
            <summary>
            Writes a solution file to the specified <paramref name="targetFile"/>.
            </summary>
            <param name="targetFile">The full path of the file to write.</param>
            <param name="projects">The projects contained in this solution.</param>
            
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="targetFile"/> is null or empty.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="projects"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when <paramref name="projects"/> contains no items.</exception>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.LocalFunctionMethod">
            <summary>
            A local function has zero or more compiler-generated parameters added at the end.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.Implementation.LocalFunctionMethod.IsStatic">
            <summary>
            We consider local functions as always static, because they do not have a "this parameter".
            Even local functions in instance methods capture this.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeListBuilder.Add(ICSharpCode.Decompiler.TypeSystem.KnownAttribute)">
            <summary>
            Add a builtin attribute without any arguments.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeListBuilder.Add(ICSharpCode.Decompiler.TypeSystem.KnownAttribute,ICSharpCode.Decompiler.TypeSystem.KnownTypeCode,System.Object)">
            <summary>
            Construct a builtin attribute with a single positional argument of known type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeListBuilder.Add(ICSharpCode.Decompiler.TypeSystem.KnownAttribute,ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName,System.Object)">
            <summary>
            Construct a builtin attribute with a single positional argument of known type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeListBuilder.Add(ICSharpCode.Decompiler.TypeSystem.KnownAttribute,System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{ICSharpCode.Decompiler.TypeSystem.IType}})">
            <summary>
            Construct a builtin attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.CustomAttribute">
            <summary>
            Custom attribute loaded from metadata.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.FakeMember">
            <summary>
            Base class for fake members.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataField">
            <summary>
            Field definition backed by System.Reflection.Metadata
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeDefinition">
            <summary>
            Type definition backed by System.Reflection.Metadata
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SyntheticRangeIndexAccessor">
            <summary>
            Synthetic method representing a compiler-generated indexer
            with the signature 'get_Item(System.Index)' or 'get_Item(System.Range)'.
            Can also be a setter.
            Used for the "Implicit Index support"/"Implicit Range support" for the C# 8 ranges feature.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Implementation.SyntheticRangeIndexAccessor.underlyingMethod">
            <summary>
            The underlying method: `get_Item(int)`, `set_Item(int, T)` or `Slice(int, int)`.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.ThreeState">
            <summary>
            Constants used instead of <c>bool?</c>
            in multithreaded code, as <c>bool?</c> might produce torn reads.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.ModifiedType">
            <summary>
            Represents a modopt or modreq type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.NullabilityAnnotatedType">
            <summary>
            A decorator that annotates the nullability status for a type.
            Note: ArrayType does not use a decorator, but has direct support for nullability.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.FreezableHelper.GetFrozenClone``1(``0)">
            <summary>
            If the item is not frozen, this method creates and returns a frozen clone.
            If the item is already frozen, it is returned without creating a clone.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractType">
            <summary>
            Default implementation for IType interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.BaseTypeCollector">
            <summary>
            Helper class for the GetAllBaseTypes() implementation.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Implementation.BaseTypeCollector.SkipImplementedInterfaces">
            <summary>
            If this option is enabled, the list will not contain interfaces when retrieving the base types
            of a class.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultAssemblyReference">
            <summary>
            References an existing assembly by name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultAttribute">
            <summary>
            IAttribute implementation for already-resolved attributes.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.Decompiler.TypeSystem.IParameter"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultVariable">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.Decompiler.TypeSystem.IVariable"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.DummyTypeParameter.GetClassTypeParameterList(System.Int32)">
            <summary>
            Gets a list filled with dummy type parameters.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference">
            <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.Decompiler.TypeSystem.FullTypeName,ICSharpCode.Decompiler.TypeSystem.IModuleReference,System.Nullable{System.Boolean})">
            <summary>
            Creates a new GetClassTypeReference that searches a type definition.
            </summary>
            <param name="fullTypeName">The full name of the type.</param>
            <param name="module">A reference to the module containing this type.
            If this parameter is null, the GetClassTypeReference will search in all
            assemblies belonging to the compilation.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference.#ctor(System.String,System.String,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in all assemblies.
            </summary>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.Decompiler.TypeSystem.IModuleReference,System.String,System.String,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in the specified assembly.
            </summary>
            <param name="module">A reference to the assembly containing this type.
            If this parameter is null, the GetClassTypeReference will search in all assemblies belonging to the ICompilation.</param>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference.Module">
            <summary>
            Gets the assembly reference.
            This property returns null if the GetClassTypeReference is searching in all assemblies
            of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference.FullTypeName">
            <summary>
            Gets the full name of the type this reference is searching for.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.GetMembersHelper">
            <summary>
            Provides helper methods for implementing GetMembers() on IType-implementations.
            Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
            both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
            and only the 'simple' overloads (not taking type arguments).
            
            Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
            otherwise you'll get a StackOverflowException!
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.KnownTypeCache">
            <summary>
            Cache for KnownTypeReferences.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.MergedNamespace">
            <summary>
            A merged namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.INamespace[],System.String)">
            <summary>
            Creates a new merged root namespace.
            </summary>
            <param name="compilation">The main compilation.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
            <param name="externAlias">The extern alias for this namespace.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.Decompiler.TypeSystem.INamespace,ICSharpCode.Decompiler.TypeSystem.INamespace[])">
            <summary>
            Creates a new merged child namespace.
            </summary>
            <param name="parentNamespace">The parent merged namespace.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.MinimalCorlib">
            <summary>
            An artificial "assembly" that contains all known types (<see cref="T:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode"/>) and no other types.
            It does not contain any members.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Implementation.MinimalCorlib.Instance">
            <summary>
            Minimal corlib instance containing all known types.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.NestedTypeReference">
            <summary>
            Type reference used to reference nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.Decompiler.TypeSystem.ITypeReference,System.String,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Creates a new NestedTypeReference.
            </summary>
            <param name="declaringTypeRef">Reference to the declaring type.</param>
            <param name="name">Name of the nested class</param>
            <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
            <remarks>
            <paramref name="declaringTypeRef"/> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SimpleCompilation">
            <summary>
            Simple compilation implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent">
            <summary>
            Represents a specialized IEvent (event after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField">
            <summary>
            Represents a specialized IField (field after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMember">
            <summary>
            Represents a SpecializedMember (a member on which type substitution has been performed).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMember.AddSubstitution(ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Performs a substitution. This method may only be called by constructors in derived classes.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMember.Substitution">
            <summary>
            Gets the substitution belonging to this specialized member.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod">
            <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty">
            <summary>
            Represents a specialized IProperty (property after type substitution).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.TypeParameterReference.Create(ICSharpCode.Decompiler.TypeSystem.SymbolKind,System.Int32)">
            <summary>
            Creates a type parameter reference.
            For common type parameter references, this method may return a shared instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType">
            <summary>
            An unknown type where (part) of the name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType.#ctor(System.String,System.String,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="namespaceName">Namespace name, if known. Can be null if unknown.</param>
            <param name="name">Name of the type, must not be null.</param>
            <param name="typeParameterCount">Type parameter count, zero if unknown.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType.#ctor(ICSharpCode.Decompiler.TypeSystem.FullTypeName,System.Nullable{System.Boolean})">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="fullTypeName">Full name of the unknown type.</param>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ApplyAttributeTypeVisitor">
            <summary>
            Introduces 'dynamic' and tuple types based on attribute values.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownAttribute.None">
            <summary>
            Not a known attribute
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownAttribute.Extension">
            <summary>
            Marks a method as extension method; or a class as containing extension methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.MetadataModule">
            <summary>
            Type system implementation for Metadata.PEFile.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.MetadataModule.TypeDefinitions">
            <summary>
            Gets all types in the assembly, including nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.ResolveMethodReference(System.Reflection.Metadata.MemberReferenceHandle,ICSharpCode.Decompiler.TypeSystem.GenericContext,System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Boolean)">
            <summary>
            Resolves a method reference.
            </summary>
            <remarks>
            Class type arguments are provided by the declaring type stored in the memberRef.
            Method type arguments are provided by the caller.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.CreateFakeMethod(ICSharpCode.Decompiler.TypeSystem.IType,System.String,System.Reflection.Metadata.MethodSignature{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Create a dummy IMethod from the specified MethodReference
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.ResolveEntity(System.Reflection.Metadata.EntityHandle,ICSharpCode.Decompiler.TypeSystem.GenericContext)">
            <summary>
            Resolves a symbol.
            </summary>
            <remarks>
            * Types are resolved to their definition, as IType does not implement ISymbol.
               * types without definition will resolve to <c>null</c>
               * use ResolveType() to properly resolve types
            * When resolving methods, varargs signatures are not expanded.
               * use ResolveMethod() instead to get an IMethod instance suitable for call-sites
            * May return specialized members, where generics are involved.
            * Other types of handles that don't correspond to TS entities, will return <c>null</c>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.GetAssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.GetModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.MetadataModule.knownAttributeTypes">
            <summary>
            Cache for parameterless known attribute types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.MetadataModule.knownAttributes">
            <summary>
            Cache for parameterless known attributes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.MetadataModule.MakeAttribute(ICSharpCode.Decompiler.TypeSystem.KnownAttribute)">
            <summary>
            Construct a builtin attribute.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.NormalizeTypeVisitor.TypeErasure">
            <summary>
            NormalizeTypeVisitor that does not normalize type parameters,
            but performs type erasure (object->dynamic; tuple->underlying type).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleType.UnderlyingType">
            <summary>
            Gets the underlying <c>System.ValueType</c> type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleType.ElementTypes">
            <summary>
            Gets the tuple elements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleType.Cardinality">
            <summary>
            Gets the cardinality of the tuple.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleType.ElementNames">
            <summary>
            Gets the names of the tuple elements.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TupleType.IsTupleCompatible(ICSharpCode.Decompiler.TypeSystem.IType,System.Int32@)">
            <summary>
            Gets whether the specified type is a valid underlying type for a tuple.
            Also returns true for tuple types themselves.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TupleType.FromUnderlyingType(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Construct a tuple type (without element names) from the given underlying type.
            Returns null if the input is not a valid underlying type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TupleType.GetTupleElementTypes(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the tuple element types from a tuple type or tuple underlying type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleTypeReference.ElementTypes">
            <summary>
            Gets the types of the tuple elements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TupleTypeReference.ElementNames">
            <summary>
            Gets the names of the tuple elements.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeProvider">
            <summary>
            Allows decoding signatures using decompiler types.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.Accessibility">
            <summary>
            Enum that describes the accessibility of an entity.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.None">
            <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.Private">
            <summary>
            The entity is only accessible within the same class.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.ProtectedAndInternal">
            <summary>
            The entity is accessible in derived classes within the same assembly.
            This corresponds to C# <c>private protected</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.Protected">
            <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.Internal">
            <summary>
            The entity is accessible within the same assembly.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.ProtectedOrInternal">
            <summary>
            The entity is accessible both everywhere in the assembly, and in all derived classes.
            This corresponds to C# <c>protected internal</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.Accessibility.Public">
            <summary>
            The entity is accessible everywhere.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.AccessibilityExtensions.LessThanOrEqual(ICSharpCode.Decompiler.TypeSystem.Accessibility,ICSharpCode.Decompiler.TypeSystem.Accessibility)">
            <summary>
            Gets whether a &lt;= b in the partial order of accessibilities:
            return true if b is accessible everywhere where a is accessible.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.AccessibilityExtensions.Intersect(ICSharpCode.Decompiler.TypeSystem.Accessibility,ICSharpCode.Decompiler.TypeSystem.Accessibility)">
            <summary>
            Computes the intersection of the two accessibilities:
            The result is accessible from any given point in the code
            iff both a and b are accessible from that point.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.AccessibilityExtensions.Union(ICSharpCode.Decompiler.TypeSystem.Accessibility,ICSharpCode.Decompiler.TypeSystem.Accessibility)">
            <summary>
            Computes the union of the two accessibilities:
            The result is accessible from any given point in the code
            iff at least one of a or b is accessible from that point.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.AccessibilityExtensions.EffectiveAccessibility(ICSharpCode.Decompiler.TypeSystem.IEntity)">
            <summary>
            Gets the effective accessibility of the entity.
            For example, a public method in an internal class returns "internal".
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ArrayType">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ComHelper">
            <summary>
            Helper methods for COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ComHelper.IsComImport(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether the specified type is imported from COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ComHelper.GetCoClass(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Gets the CoClass of the specified COM interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions">
            <summary>
            Options that control how metadata is represented in the type system.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.None">
            <summary>
            No options enabled; stay as close to the metadata as possible.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.Dynamic">
            <summary>
            [DynamicAttribute] is used to replace 'object' types with the 'dynamic' type.
            
            If this option is not active, the 'dynamic' type is not used, and the attribute is preserved.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.Tuple">
            <summary>
            Tuple types are represented using the TupleType class.
            [TupleElementNames] is used to name the tuple elements.
            
            If this option is not active, the tuples are represented using their underlying type, and the attribute is preserved.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.ExtensionMethods">
            <summary>
            If this option is active, [ExtensionAttribute] is removed and methods are marked as IsExtensionMethod.
            Otherwise, the attribute is preserved but the methods are not marked.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.OnlyPublicAPI">
            <summary>
            Only load the public API into the type system.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.Uncached">
            <summary>
            Do not cache accessed entities.
            In a normal type system (without this option), every type or member definition has exactly one ITypeDefinition/IMember
            instance. This instance is kept alive until the whole type system can be garbage-collected.
            When this option is specified, the type system avoids these caches.
            This reduces the memory usage in many cases, but increases the number of allocations.
            Also, some code in the decompiler expects to be able to compare type/member definitions by reference equality,
            and thus will fail with uncached type systems.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.DecimalConstants">
            <summary>
            If this option is active, [DecimalConstantAttribute] is removed and constant values are transformed into simple decimal literals.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.KeepModifiers">
            <summary>
            If this option is active, modopt and modreq types are preserved in the type system.
            
            Note: the decompiler currently does not support handling modified types;
            activating this option may lead to incorrect decompilation or internal errors.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.ReadOnlyStructsAndParameters">
            <summary>
            If this option is active, [IsReadOnlyAttribute] on parameters+structs is removed
            and parameters are marked as in, structs as readonly.
            Otherwise, the attribute is preserved but the parameters and structs are not marked.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.RefStructs">
            <summary>
            If this option is active, [IsByRefLikeAttribute] is removed and structs are marked as ref.
            Otherwise, the attribute is preserved but the structs are not marked.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.UnmanagedConstraints">
            <summary>
            If this option is active, [IsUnmanagedAttribute] is removed from type parameters,
            and HasUnmanagedConstraint is set instead.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.NullabilityAnnotations">
            <summary>
            If this option is active, [NullableAttribute] is removed and reference types with
            nullability annotations are used instead.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.ReadOnlyMethods">
            <summary>
            If this option is active, [IsReadOnlyAttribute] on methods is removed
            and the method marked as ThisIsRefReadOnly.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.NativeIntegers">
            <summary>
            [NativeIntegerAttribute] is used to replace 'IntPtr' types with the 'nint' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.FunctionPointers">
            <summary>
            Allow function pointer types. If this option is not enabled, function pointers are
            replaced with the 'IntPtr' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions.Default">
            <summary>
            Default settings: typical options for the decompiler, with all C# languages features enabled.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem">
            <summary>
            Manages the NRefactory type system for the decompiler.
            </summary>
            <remarks>
            This class is thread-safe.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.FullTypeName">
            <summary>
            Holds the full name of a type definition.
            A full type name uniquely identifies a type definition within a single assembly.
            </summary>
            <remarks>
            A full type name can only represent type definitions, not arbitrary types.
            It does not include any type arguments, and can not refer to array or pointer types.
            
            A full type name represented as reflection name has the syntax:
            <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.#ctor(ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName)">
            <summary>
            Constructs a FullTypeName representing the given top-level type.
            </summary>
            <remarks>
            FullTypeName has an implicit conversion operator from TopLevelTypeName,
            so you can simply write:
            <c>FullTypeName f = new TopLevelTypeName(...);</c>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.#ctor(System.String)">
            <summary>
            Constructs a FullTypeName by parsing the given reflection name.
            Note that FullTypeName can only represent type definition names. If the reflection name
            might refer to a parameterized type or array etc., use
            <see cref="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)"/> instead.
            </summary>
            <remarks>
            Expected syntax: <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
            where # are type parameter counts
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.FullTypeName.TopLevelTypeName">
            <summary>
            Gets the top-level type name.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.FullTypeName.IsNested">
            <summary>
            Gets whether this is a nested type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.FullTypeName.NestingLevel">
            <summary>
            Gets the nesting level.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.FullTypeName.Name">
            <summary>
            Gets the name of the type.
            For nested types, this is the name of the innermost type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.FullTypeName.TypeParameterCount">
            <summary>
            Gets the total type parameter count.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.GetNestedTypeName(System.Int32)">
            <summary>
            Gets the name of the nested type at the given level.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.GetNestedTypeAdditionalTypeParameterCount(System.Int32)">
            <summary>
            Gets the number of additional type parameters of the nested type at the given level.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.GetDeclaringType">
            <summary>
            Gets the declaring type name.
            </summary>
            <exception cref="T:System.InvalidOperationException">This is a top-level type name.</exception>
            <example><c>new FullTypeName("NS.A+B+C").GetDeclaringType()</c> will return <c>new FullTypeName("NS.A+B")</c></example>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.NestedType(System.String,System.Int32)">
            <summary>
            Creates a nested type name.
            </summary>
            <example><c>new FullTypeName("NS.A+B").NestedType("C", 1)</c> will return <c>new FullTypeName("NS.A+B+C`1")</c></example>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IModuleReference">
            <summary>
            Interface used to help with construction of the type system.
            </summary>
            <remarks>
            The type system is an immutable cyclic data structure:
            the compilation (ICompilation) has references to all modules,
            and each module has a reference back to the compilation.
            
            Module references are used to solve this cyclic dependency:
            The compilation constructor accepts module references,
            and only the IModuleReference.Resolve() function can observe a
            partially-constructed compilation; but not any user code.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IModuleReference.Resolve(ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this metadata module.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IModule">
            <summary>
            Represents a metadata module.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.PEFile">
            <summary>
            Gets the underlying metadata file. May return null, if the IAssembly was not created from a PE file.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.IsMainModule">
            <summary>
            Gets whether this assembly is the main assembly of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.AssemblyName">
            <summary>
            Gets the assembly name (short name).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.FullAssemblyName">
            <summary>
            Gets the full assembly name (including public key token etc.)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IModule.GetAssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IModule.GetModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IModule.InternalsVisibleTo(ICSharpCode.Decompiler.TypeSystem.IModule)">
            <summary>
            Gets whether the internals of this assembly are visible in the specified assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.RootNamespace">
            <summary>
            Gets the root namespace for this module.
            </summary>
            <remarks>
            This always is the namespace without a name - it's unrelated to the 'root namespace' project setting.
            It contains only subnamespaces and types defined in this module -- use ICompilation.RootNamespace
            to get the combined view of all referenced assemblies.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IModule.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName)">
            <summary>
            Gets the type definition for a top-level type.
            </summary>
            <remarks>This method uses ordinal name comparison, not the compilation's name comparer.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.TopLevelTypeDefinitions">
            <summary>
            Gets all non-nested types in the assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IModule.TypeDefinitions">
            <summary>
            Gets all types in the assembly, including nested types.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IAttribute">
            <summary>
            Represents an attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IAttribute.AttributeType">
            <summary>
            Gets the type of the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IAttribute.Constructor">
            <summary>
            Gets the constructor being used.
            This property may return null if no matching constructor was found.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IAttribute.HasDecodeErrors">
            <summary>
            Gets whether there were errors decoding the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IAttribute.FixedArguments">
            <summary>
            Gets the positional arguments.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IAttribute.NamedArguments">
            <summary>
            Gets the named arguments passed to the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICodeContext.LocalVariables">
            <summary>
            Gets all currently visible local variables and lambda parameters.
            Does not include method parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICodeContext.IsWithinLambdaExpression">
            <summary>
            Gets whether the context is within a lambda expression or anonymous method.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilation.MainModule">
            <summary>
            Gets the primary module.
            This is the module being (de)compiled; all other modules in the compilation are the other assemblies/modules
            referenced by the main module.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilation.Modules">
            <summary>
            Gets the list of all modules in the compilation.
            </summary>
            <remarks>
            This main module is the first entry in the list.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilation.ReferencedModules">
            <summary>
            Gets the referenced modules.
            This list does not include the main module.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilation.RootNamespace">
            <summary>
            Gets the root namespace of this compilation.
            This is a merged version of the root namespaces of all assemblies.
            </summary>
            <remarks>
            This always is the namespace without a name - it's unrelated to the 'root namespace' project setting.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ICompilation.GetNamespaceForExternAlias(System.String)">
            <summary>
            Gets the root namespace for a given extern alias.
            </summary>
            <remarks>
            If <paramref name="alias"/> is <c>null</c> or an empty string, this method
            returns the global root namespace.
            If no alias with the specified name exists, this method returns null.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilation.NameComparer">
            <summary>
            Gets the name comparer for the language being compiled.
            This is the string comparer used for the INamespace.GetTypeDefinition method.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.Compilation">
            <summary>
            Gets the parent compilation.
            This property never returns null.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IEntity">
            <summary>
            Represents a resolved entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.MetadataToken">
            <summary>
            Gets the metadata token for this entity.
            </summary>
            <remarks>
            The token is only valid within the context of the assembly defining this entity.
            Token may be 0 if this is a generated member.
            Note: specialized members will return the token of the member definition.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.Name">
            <summary>
            Gets the short name of the entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property will return null for top-level entities.
            If this is not a specialized member, the value returned is equal to <see cref="P:ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.ParentModule">
            <summary>
            The module in which this entity is defined.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes">
            <summary>
            Gets the attributes on this entity.
            Does not include inherited attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.Accessibility">
            <summary>
            Gets the accessibility of this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.InterningProvider">
            <summary>
            Provider used for interning.
            </summary>
            <remarks>
            A simple IInterningProvider implementation could use 3 dictionaries:
             1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)
             2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)
             3. list comparer (for InternList method)
            
            On the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)
            and stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.
            This allows reducing the memory usage by using a single object instance where possible.
            
            Interning provider implementations could also use the interning logic for different purposes:
            for example, it could be used to determine which objects are used jointly between multiple type definitions
            and which are used only within a single type definition. Then a persistent file format could be organized so
            that shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InterningProvider.Intern(ICSharpCode.Decompiler.TypeSystem.ISupportsInterning)">
            <summary>
            Interns the specified object.
            
            If the object is freezable, it will be frozen.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InterningProvider.Intern``1(``0)">
            <summary>
            Interns the specified object.
            
            If the object is freezable, it will be frozen.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InterningProvider.Intern(System.String)">
            <summary>
            Interns the specified string.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InterningProvider.InternValue(System.Object)">
            <summary>
            Inters a boxed value type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InterningProvider.InternList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Interns the given list. Uses reference equality to compare the list elements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMemberReference.DeclaringTypeReference">
            <summary>
            Gets the declaring type reference for the member.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IMemberReference.Resolve(ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context to use for resolving this member reference.
            Which kind of context is required depends on the which kind of member reference this is;
            please consult the documentation of the method that was used to create this member reference,
            or that of the class implementing this method.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IMember">
            <summary>
            Method/field/property/event.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition">
            <summary>
            Gets the original member definition for this member.
            Returns <c>this</c> if this is not a specialized member.
            Specialized members are the result of overload resolution with type substitution.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns <c>null</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.ExplicitlyImplementedInterfaceMembers">
            <summary>
            Gets the interface members explicitly implemented by this member.
            </summary>
            <remarks>
            For methods, equivalent to (
            	from impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()
            	where impl.Implementation == this
            	select impl.InterfaceMethod
            ),
            but may be more efficient than searching the whole list.
            
            Note that it is possible for a class to implement an interface using members in a
            base class unrelated to that interface:
              class BaseClass { public void Dispose() {} }
              class C : BaseClass, IDisposable { }
            In this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,
            so use (C).GetInterfaceImplementations() instead to handle this case.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.IsExplicitInterfaceImplementation">
            <summary>
            Gets whether this member is explicitly implementing an interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are abstract or overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.IsOverride">
            <summary>
            Gets whether this member is overriding another member.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMember.Substitution">
            <summary>
            Gets the substitution belonging to this specialized member.
            Returns TypeParameterSubstitution.Identity for not specialized members.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IMember.Specialize(ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Specializes this member with the given substitution.
            If this member is already specialized, the new substitution is composed with the existing substition.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IMember.Equals(ICSharpCode.Decompiler.TypeSystem.IMember,ICSharpCode.Decompiler.TypeSystem.TypeVisitor)">
            <summary>
            Gets whether the members are considered equal when applying the specified type normalization.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IMethod">
            <summary>
            Represents a method, constructor, destructor or operator.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IMethod.GetReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
            <remarks>
            Does not include inherited attributes.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly">
            <summary>
            Gets whether the return type is 'ref readonly'.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly">
            <summary>
            Gets whether this method may only be called on fresh instances.
            Used with C# 9 `init;` property setters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly">
            <summary>
            Gets whether the method accepts the 'this' reference as ref readonly.
            This can be either because the method is C# 8.0 'readonly', or because it is within a C# 7.2 'readonly struct'
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.TypeParameters">
            <summary>
            Gets the type parameters of this method; or an empty list if the method is not generic.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.TypeArguments">
            <summary>
            Gets the type arguments passed to this method.
            If the method is generic but not parameterized yet, this property returns the type parameters,
            as if the method was parameterized with its own type arguments (<c>void M&lt;T&gt;() { M&lt;T&gt;(); }</c>).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.HasBody">
            <summary>
            Gets whether the method has a body.
            This property returns <c>false</c> for <c>abstract</c> or <c>extern</c> methods,
            or for <c>partial</c> methods without implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.IsAccessor">
            <summary>
            Gets whether the method is a property/event accessor.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.AccessorOwner">
            <summary>
            If this method is an accessor, returns the corresponding property/event.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.AccessorKind">
            <summary>
            Gets the kind of accessor this is.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IMethod.ReducedFrom">
            <summary>
            If this method is reduced from an extension method or a local function returns the original method, <c>null</c> otherwise.
            A reduced method doesn't contain the extension method parameter. That means that it has one parameter less than its definition.
            A local function doesn't contain compiler-generated method parameters at the end.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IMethod.Specialize(ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Specializes this method with the given substitution.
            If this method is already specialized, the new substitution is composed with the existing substition.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamedElement.FullName">
            <summary>
            Gets the fully qualified name of the class the return type is pointing to.
            </summary>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Collections.Generic.List" for List&lt;string&gt;
            "System.Environment.SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamedElement.Name">
            <summary>
            Gets the short name of the class the return type is pointing to.
            </summary>
            <returns>
            "Int32[]" for int[]<br/>
            "List" for List&lt;string&gt;
            "SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamedElement.ReflectionName">
            <summary>
            Gets the full reflection name of the element.
            </summary>
            <remarks>
            For types, the reflection name can be parsed back into a ITypeReference by using
            <see cref="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)"/>.
            </remarks>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Int32[][,]" for C# int[,][]<br/>
            "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
            "System.Environment+SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamedElement.Namespace">
            <summary>
            Gets the full name of the namespace containing this entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.INamespace">
            <summary>
            Represents a resolved namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.ExternAlias">
            <summary>
            Gets the extern alias for this namespace.
            Returns an empty string for normal namespaces.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.FullName">
            <summary>
            Gets the full name of this namespace. (e.g. "System.Collections")
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.Name">
            <summary>
            Gets the short name of this namespace (e.g. "Collections").
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.ParentNamespace">
            <summary>
            Gets the parent namespace.
            Returns null if this is the root namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.ChildNamespaces">
            <summary>
            Gets the child namespaces in this namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.Types">
            <summary>
            Gets the types in this namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.INamespace.ContributingModules">
            <summary>
            Gets the modules that contribute types to this namespace (or to child namespaces).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.INamespace.GetChildNamespace(System.String)">
            <summary>
            Gets a direct child namespace by its short name.
            Returns null when the namespace cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.INamespace.GetTypeDefinition(System.String,System.Int32)">
            <summary>
            Gets the type with the specified short name and type parameter count.
            Returns null if the type cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.InheritanceHelper">
            <summary>
            Provides helper methods for inheritance.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InheritanceHelper.GetBaseMember(ICSharpCode.Decompiler.TypeSystem.IMember)">
            <summary>
            Gets the base member that has the same signature.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InheritanceHelper.GetBaseMembers(ICSharpCode.Decompiler.TypeSystem.IMember,System.Boolean)">
            <summary>
            Gets all base members that have the same signature.
            </summary>
            <returns>
            List of base members with the same signature. The member from the derived-most base class is returned first.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.InheritanceHelper.GetDerivedMember(ICSharpCode.Decompiler.TypeSystem.IMember,ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Finds the member declared in 'derivedType' that has the same signature (could override) 'baseMember'.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IntersectionType">
            <summary>
            Represents the intersection of several types.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReferenceKind">
            <remarks>
            Should match order in <see cref="T:ICSharpCode.Decompiler.CSharp.Syntax.FieldDirection"/>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IParameter.GetAttributes">
            <summary>
            Gets the attributes on this parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.ReferenceKind">
            <summary>
            Gets the reference kind of this parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.IsIn">
            <summary>
            Gets whether this parameter is a C# 'in' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            The default value is given by the <see cref="M:ICSharpCode.Decompiler.TypeSystem.IVariable.GetConstantValue(System.Boolean)"/> function.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.HasConstantValueInSignature">
            <summary>
            Gets whether this parameter has a constant value when presented in method signature.
            </summary>
            <remarks>
            This can only be <c>true</c> if the parameter is optional, and it's true for most 
            optional parameters. However it is possible to compile a parameter without a default value,
            and some parameters handle their default values in an special way.
            
            For example, <see cref="T:System.Runtime.CompilerServices.DecimalConstantAttribute"/> does not use normal constants,
            so when <see cref="P:ICSharpCode.Decompiler.DecompilerSettings.DecimalConstants" /> is <c>false</c>
            we expose <c>DecimalConstantAttribute</c> directly instead of a constant value.
            
            On the call sites, though, we can still use the value inferred from the attribute.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IParameter.Owner">
            <summary>
            Gets the owner of this parameter.
            May return null; for example when parameters belong to lambdas or anonymous methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IProperty.ReturnTypeIsRefReadOnly">
            <summary>
            Gets whether the return type is 'ref readonly'.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ISupportsInterning">
            <summary>
            Interface for TypeSystem objects that support interning.
            See <see cref="T:ICSharpCode.Decompiler.TypeSystem.InterningProvider"/> for more information.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning">
            <summary>
            Gets a hash code for interning.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ICSharpCode.Decompiler.TypeSystem.ISupportsInterning)">
            <summary>
            Equality test for interning.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Module">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IModule"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.TypeDefinition">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Field">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IField"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Property">
            <summary>
            The symbol is a property, but not an indexer.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Indexer">
            <summary>
            The symbol is an indexer, not a regular property.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Event">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IEvent"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Method">
            <summary>
            The symbol is a method which is not an operator/constructor/destructor or accessor.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Operator">
            <summary>
            The symbol is a user-defined operator.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Constructor">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Destructor">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Accessor">
            <summary>
            The accessor method for a property getter/setter or event add/remove.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Namespace">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.INamespace"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Variable">
            <summary>
            The symbol is a variable, but not a parameter.
            </summary>
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IVariable"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Parameter">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.IParameter"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.TypeParameter">
            <seealso cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeParameter"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.Constraint">
            <summary>
            Constraint on a type parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SymbolKind.ReturnType">
            <summary>
            Return type. Not actually an ISymbol implementation; but can appear as attribut target.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ISymbol">
            <summary>
            Interface for type system symbols.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind">
            <summary>
            This property returns an enum specifying which kind of symbol this is
            (which derived interfaces of ISymbol are implemented)
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ISymbol.Name">
            <summary>
            Gets the short name of the symbol.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IType">
            <summary>
            This interface represents a resolved type in the type system.
            </summary>
            <remarks>
            <para>
            A type is potentially
            - a type definition (<see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/>, i.e. a class, struct, interface, delegate, or built-in primitive type)
            - a parameterized type (<see cref="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType"/>, e.g. List&lt;int>)
            - a type parameter (<see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeParameter"/>, e.g. T)
            - an array (<see cref="T:ICSharpCode.Decompiler.TypeSystem.ArrayType"/>)
            - a pointer (<see cref="T:ICSharpCode.Decompiler.TypeSystem.PointerType"/>)
            - a managed reference (<see cref="T:ICSharpCode.Decompiler.TypeSystem.ByReferenceType"/>)
            - one of the special types (<see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/>, <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NullType"/>,
                 <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.Dynamic"/>, <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument"/>)
            
            The <see cref="P:ICSharpCode.Decompiler.TypeSystem.IType.Kind"/> property can be used to switch on the kind of a type.
            </para>
            <para>
            IType uses the null object pattern: <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/> serves as the null object.
            Methods or properties returning IType never return null unless documented otherwise.
            </para>
            <para>
            Types should be compared for equality using the <see cref="M:System.IEquatable`1.Equals(`0)"/> method.
            Identical types do not necessarily use the same object reference.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.Kind">
            <summary>
            Gets the type kind.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.IsReferenceType">
            <summary>
            Gets whether the type is a reference type or value type.
            </summary>
            <returns>
            true, if the type is a reference type.
            false, if the type is a value type.
            null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.IsByRefLike">
            <summary>
            Gets whether this type is "ref-like": a ByReferenceType or "ref struct".
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.Nullability">
            <summary>
            Gets the nullability annotation on this type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.ChangeNullability(ICSharpCode.Decompiler.TypeSystem.Nullability)">
            <summary>
            Creates a new type that is a copy of this type, with the changed nullability annotation.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetDefinition">
            <summary>
            Gets the underlying type definition.
            Can return null for types which do not have a type definition (for example arrays, pointers, type parameters).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.DeclaringType">
            <summary>
            Gets the parent type, if this is a nested type.
            Returns null for top-level types.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.TypeParameterCount">
            <summary>
            Gets the number of type parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.TypeParameters">
            <summary>
            Gets the type parameters.
            Returns an empty list if this type is not generic.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.TypeArguments">
            <summary>
            Gets the type arguments passed to this type.
            If this type is a generic type definition that is not parameterized, this property returns the type parameters,
            as if the type was parameterized with its own type arguments (<c>class C&lt;T&gt; { C&lt;T&gt; field; }</c>).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.AcceptVisitor(ICSharpCode.Decompiler.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for this type.
            </summary>
            <returns>The return value of the ITypeVisitor.Visit call</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.VisitChildren(ICSharpCode.Decompiler.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based
            on the return values of the visit calls.
            </summary>
            <returns>A copy of this type, with all children replaced by the return value of the corresponding visitor call.
            If the visitor returned the original types for all children (or if there are no children), returns <c>this</c>.
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IType.DirectBaseTypes">
            <summary>
            Gets the direct base types.
            </summary>
            <returns>Returns the direct base types including interfaces</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetSubstitution">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type.
            Returns TypeParameterSubstitution.Identity if the type is not parametrized.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.Decompiler.TypeSystem.ITypeDefinition},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes).
            </summary>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            If the nested type is generic, this method will return a parameterized type,
            where the additional type parameters are set to <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument"/>.
            </para>
            <para>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </para>
            </remarks>
            <example>
            <code>
            class Base&lt;T> {
            	class Nested&lt;X> {}
            }
            class Derived&lt;A, B> : Base&lt;B> {}
            
            Derived[string,int].GetNestedTypes() = { Base`1+Nested`1[int, unbound] }
            Derived.GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base[`1].GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base.GetNestedTypes() = { Base`1+Nested`1[`0, unbound] }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Predicate{ICSharpCode.Decompiler.TypeSystem.ITypeDefinition},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes)
            that have <c>typeArguments.Count</c> additional type parameters.
            </summary>
            <param name="typeArguments">The type arguments passed to the inner class</param>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetConstructors(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all instance constructors for this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include static constructors.
            Constructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.</para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all methods that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The result does not include constructors or accessors.
            </para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            <para>
            If the method being returned is generic, and this type is a parameterized type where the type
            arguments involve another method's type parameters, the resulting specialized signature
            will be ambiguous as to which method a type parameter belongs to.
            For example, "List[[``0]].GetMethods()" will return "ConvertAll(Converter`2[[``0, ``0]])".
            
            If possible, use the other GetMethods() overload to supply type arguments to the method,
            so that both class and method type parameter can be substituted at the same time, so that
            the ambiguity can be avoided.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all generic methods that can be called on this type with the specified type arguments.
            </summary>
            <param name="typeArguments">The type arguments used for the method call.</param>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include constructors or accessors.</para>
            <para>
            Type substitution will be performed on the method signature, creating a <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod"/>
            with the specified type arguments.
            </para>
            <para>
            When the list of type arguments is empty, this method acts like the GetMethods() overload without
            the type arguments parameter - that is, it also returns generic methods,
            and the other overload's remarks about ambiguous signatures apply here as well.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetProperties(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IProperty},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all properties that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which properties to return.
            The filter is tested on the original property definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For properties on parameterized types, type substitution will be performed on the property signature,
            and the appropriate <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetFields(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IField},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all fields that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original field definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the field's return type,
            and the appropriate <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetEvents(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IEvent},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all events that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which events to return.
            The filter is tested on the original event definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the event's return type,
            and the appropriate <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetMembers(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMember},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all members that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which members to return.
            The filter is tested on the original member definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().
            It does not include constructors.
            For parameterized types, type substitution will be performed.
            </para>
            <para>
            For generic methods, the remarks about ambiguous signatures from the
            <see cref="M:ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)"/> method apply here as well.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IType.GetAccessors(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all accessors belonging to properties or events on this type.
            </summary>
            <param name="filter">The filter used to select which members to return.
            The filter is tested on the original member definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            Accessors are not returned by GetMembers() or GetMethods().
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.GetMemberOptions.None">
            <summary>
            No options specified - this is the default.
            Members will be specialized, and inherited members will be included.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.GetMemberOptions.ReturnMemberDefinitions">
            <summary>
            Do not specialize the returned members - directly return the definitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.GetMemberOptions.IgnoreInheritedMembers">
            <summary>
            Do not list inherited members - only list members defined directly on this type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition">
            <summary>
            Represents a class, enum, interface, struct, delegate or VB module.
            For partial classes, this represents the whole class.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.KnownTypeCode">
            <summary>
            Gets the known type code for this type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.EnumUnderlyingType">
            <summary>
            For enums: returns the underlying primitive type.
            For all other types: returns <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.IsReadOnly">
            <summary>
            For structs: returns whether this is a readonly struct.
            For all other types: returns false.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.FullTypeName">
            <summary>
            Gets the full name of this type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property will return null for top-level types.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether this type contains extension methods.
            </summary>
            <remarks>This property is used to speed up the search for extension methods.</remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition.NullableContext">
            <summary>
            The nullability specified in the [NullableContext] attribute on the type.
            This serves as default nullability for members of the type that do not have a [Nullable] attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ITypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>SymbolKind.TypeDefinition or SymbolKind.Method</returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Owner">
            <summary>
            Gets the owning method/class.
            This property may return null (for example for the dummy type parameters used by <see cref="F:ICSharpCode.Decompiler.TypeSystem.NormalizeTypeVisitor.ReplaceMethodTypeParametersWithDummy"/>).
            </summary>
            <remarks>
            For "class Outer&lt;T&gt; { class Inner {} }",
            inner.TypeParameters[0].Owner will be the outer class, because the same
            ITypeParameter instance is used both on Outer`1 and Outer`1+Inner.
            </remarks>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Name">
            <summary>
            Gets the name of the type parameter.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.GetAttributes">
            <summary>
            Gets the attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveBaseClass">
            <summary>
            Gets the effective base class of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveInterfaceSet">
            <summary>
            Gets the effective interface set of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint">
            <summary>
            Gets if the type parameter has the 'new()' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasReferenceTypeConstraint">
            <summary>
            Gets if the type parameter has the 'class' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasValueTypeConstraint">
            <summary>
            Gets if the type parameter has the 'struct' or 'unmanaged' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasUnmanagedConstraint">
            <summary>
            Gets if the type parameter has the 'unmanaged' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeParameter.NullabilityConstraint">
            <summary>
            Nullability of the reference type constraint. (e.g. "where T : class?").
            
            Note that the nullability of a use of the type parameter may differ from this.
            E.g. "T? GetNull&lt;T&gt;() where T : class => null;"
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.VarianceModifier">
            <summary>
            Represents the variance of a type parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.VarianceModifier.Invariant">
            <summary>
            The type parameter is not variant.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.VarianceModifier.Covariant">
            <summary>
            The type parameter is covariant (used in output position).
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.VarianceModifier.Contravariant">
            <summary>
            The type parameter is contravariant (used in input position).
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ITypeReference">
            <summary>
            Represents a reference to a type.
            Must be resolved before it can be used as type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ITypeReference.Resolve(ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this type reference.
            </summary>
            <param name="context">
            Context to use for resolving this type reference.
            Which kind of context is required depends on the which kind of type reference this is;
            please consult the documentation of the method that was used to create this type reference,
            or that of the class implementing this method.
            </param>
            <returns>
            Returns the resolved type.
            In case of an error, returns an unknown type (<see cref="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Unknown"/>).
            Never returns null.
            </returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentModule">
            <summary>
            Gets the current module.
            This property may return null if this context does not specify any module.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentTypeDefinition">
            <summary>
            Gets the current type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentMember">
            <summary>
            Gets the current member.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IVariable">
            <summary>
            Represents a variable (name/type pair).
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IVariable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IVariable.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.IVariable.IsConst">
            <summary>
            Gets whether this variable is a constant (C#-like const).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.IVariable.GetConstantValue(System.Boolean)">
            <summary>
            If this field is a constant, retrieves the value.
            For parameters, this is the default value.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode">
            <summary>
            Represents some well-known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.None">
            <summary>
            Not one of the known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Object">
            <summary><c>object</c> (System.Object)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.DBNull">
            <summary><c>System.DBNull</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Boolean">
            <summary><c>bool</c> (System.Boolean)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Char">
            <summary><c>char</c> (System.Char)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.SByte">
            <summary><c>sbyte</c> (System.SByte)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Byte">
            <summary><c>byte</c> (System.Byte)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Int16">
            <summary><c>short</c> (System.Int16)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.UInt16">
            <summary><c>ushort</c> (System.UInt16)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Int32">
            <summary><c>int</c> (System.Int32)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.UInt32">
            <summary><c>uint</c> (System.UInt32)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Int64">
            <summary><c>long</c> (System.Int64)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.UInt64">
            <summary><c>ulong</c> (System.UInt64)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Single">
            <summary><c>float</c> (System.Single)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Double">
            <summary><c>double</c> (System.Double)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Decimal">
            <summary><c>decimal</c> (System.Decimal)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.DateTime">
            <summary><c>System.DateTime</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.String">
            <summary><c>string</c> (System.String)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Void">
            <summary><c>void</c> (System.Void)</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Type">
            <summary><c>System.Type</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Array">
            <summary><c>System.Array</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Attribute">
            <summary><c>System.Attribute</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ValueType">
            <summary><c>System.ValueType</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Enum">
            <summary><c>System.Enum</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Delegate">
            <summary><c>System.Delegate</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.MulticastDelegate">
            <summary><c>System.MulticastDelegate</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Exception">
            <summary><c>System.Exception</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IntPtr">
            <summary><c>System.IntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.UIntPtr">
            <summary><c>System.UIntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IEnumerable">
            <summary><c>System.Collections.IEnumerable</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IEnumerator">
            <summary><c>System.Collections.IEnumerator</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IEnumerableOfT">
            <summary><c>System.Collections.Generic.IEnumerable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IEnumeratorOfT">
            <summary><c>System.Collections.Generic.IEnumerator{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ICollection">
            <summary><c>System.Collections.Generic.ICollection</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ICollectionOfT">
            <summary><c>System.Collections.Generic.ICollection{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IList">
            <summary><c>System.Collections.Generic.IList</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IListOfT">
            <summary><c>System.Collections.Generic.IList{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IReadOnlyCollectionOfT">
            <summary><c>System.Collections.Generic.IReadOnlyCollection{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IReadOnlyListOfT">
            <summary><c>System.Collections.Generic.IReadOnlyList{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Task">
            <summary><c>System.Threading.Tasks.Task</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.TaskOfT">
            <summary><c>System.Threading.Tasks.Task{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ValueTask">
            <summary><c>System.Threading.Tasks.ValueTask</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ValueTaskOfT">
            <summary><c>System.Threading.Tasks.ValueTask{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.NullableOfT">
            <summary><c>System.Nullable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IDisposable">
            <summary><c>System.IDisposable</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IAsyncDisposable">
            <summary><c>System.IAsyncDisposable</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.INotifyCompletion">
            <summary><c>System.Runtime.CompilerServices.INotifyCompletion</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ICriticalNotifyCompletion">
            <summary><c>System.Runtime.CompilerServices.ICriticalNotifyCompletion</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.TypedReference">
            <summary><c>System.TypedReference</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IFormattable">
            <summary><c>System.IFormattable</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.FormattableString">
            <summary><c>System.FormattableString</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.SpanOfT">
            <summary><c>System.Span{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.ReadOnlySpanOfT">
            <summary><c>System.ReadOnlySpan{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.MemoryOfT">
            <summary><c>System.Memory{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Unsafe">
            <summary><c>System.Runtime.CompilerServices.Unsafe</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IAsyncEnumerableOfT">
            <summary><c>System.Collections.Generic.IAsyncEnumerable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.IAsyncEnumeratorOfT">
            <summary><c>System.Collections.Generic.IAsyncEnumerator{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Index">
            <summary><c>System.Index</c></summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Range">
            <summary><c>System.Range</c></summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.KnownTypeReference">
            <summary>
            Contains well-known type references.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.KnownTypeReference.Get(ICSharpCode.Decompiler.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the known type reference for the specified type code.
            Returns null for KnownTypeCode.None.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.KnownTypeReference.GetCSharpNameByTypeCode(ICSharpCode.Decompiler.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the C# primitive type name from the known type code.
            Returns null if there is no primitive name for the specified type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.NullableType">
            <summary>
            Static helper methods for working with nullable types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.NullableType.IsNullable(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.NullableType.GetUnderlyingType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Returns the element type, if <paramref name="type"/> is a nullable type.
            Otherwise, returns the type itself.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.NullableType.Create(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Creates a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.NullableType.Create(ICSharpCode.Decompiler.TypeSystem.ITypeReference)">
            <summary>
            Creates a nullable type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType">
            <summary>
            ParameterizedType represents an instance of a generic type.
            Example: List&lt;string&gt;
            </summary>
            <remarks>
            When getting the members, this type modifies the lists so that
            type parameters in the signatures of the members are replaced with
            the type arguments.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ParameterizedType.#ctor(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType[])">
            <summary>
            Fast internal version of the constructor. (no safety checks)
            Keeps the array that was passed and assumes it won't be modified.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ParameterizedType.GetTypeArgument(System.Int32)">
            <summary>
            Same as 'parameterizedType.TypeArguments[index]'.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ParameterizedType.GetDefinition">
            <summary>
            Gets the definition of the generic type.
            For <c>ParameterizedType</c>, this method never returns null.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ParameterizedType.GetSubstitution">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ParameterizedType.GetSubstitution(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type,
            and also substitutes method type parameters with the specified method type arguments.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedTypeReference">
            <summary>
            ParameterizedTypeReference is a reference to generic class that specifies the type parameters.
            Example: List&lt;string&gt;
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ParameterListComparer">
            <summary>
            Compares parameter lists by comparing the types of all parameters.
            </summary>
            <remarks>
            'ref int' and 'out int' are considered to be equal - unless <see cref="F:ICSharpCode.Decompiler.TypeSystem.ParameterListComparer.includeModifiers" /> is set to true.
            'object' and 'dynamic' are also equal.
            For generic methods, "Method{T}(T a)" and "Method{S}(S b)" are considered equal.
            However, "Method(T a)" and "Method(S b)" are not considered equal when the type parameters T and S belong to classes.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.SignatureComparer">
            <summary>
            Compares member signatures.
            </summary>
            <remarks>
            This comparer checks for equal short name, equal type parameter count, and equal parameter types (using ParameterListComparer).
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SignatureComparer.Ordinal">
            <summary>
            Gets a signature comparer that uses an ordinal comparison for the member name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper">
            <summary>
            Static helper methods for reflection names.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.Null">
            <summary>
            A reflection class used to represent <c>null</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.Dynamic">
            <summary>
            A reflection class used to represent <c>dynamic</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.NInt">
            <summary>
            A reflection class used to represent <c>nint</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.NUInt">
            <summary>
            A reflection class used to represent <c>nuint</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.UnboundTypeArgument">
            <summary>
            A reflection class used to represent an unbound type argument.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.FindType(ICSharpCode.Decompiler.TypeSystem.ICompilation,System.Type)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
            <remarks>
            This method cannot be used with open types; all type parameters will be substituted
            with <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ToTypeReference(System.Type)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="type">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
            <remarks>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the type reference.
            For closed types, the root type resolve context for the compilation is sufficient.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String,System.Int32@)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.FindType(ICSharpCode.Decompiler.TypeSystem.ICompilation,System.TypeCode)">
            <summary>
            Retrieves a built-in type using the specified type code.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ToTypeReference(System.TypeCode)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="typeCode">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.GetTypeCode(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes match.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)">
            <summary>
            Parses a reflection name into a type reference.
            </summary>
            <param name="reflectionTypeName">The reflection name of the type.</param>
            <returns>A type reference that represents the reflection name.</returns>
            <exception cref="T:ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException">The syntax of the reflection type name is invalid</exception>
            <remarks>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the reference to the ITypeParameter.
            For looking up closed, assembly qualified type names, the root type resolve context for the compilation
            is sufficient.
            When looking up a type name that isn't assembly qualified, the type reference will look in
            <see cref="P:ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentModule"/> first, and if the type is not found there,
            it will look in all other assemblies of the compilation.
            </remarks>
            <seealso cref="M:ICSharpCode.Decompiler.TypeSystem.FullTypeName.#ctor(System.String)"/>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String,System.Int32@,System.Boolean)">
            <summary>
            Parses the reflection name starting at pos.
            If local is true, only parses local type names, not assembly qualified type names.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException">
            <summary>
            Represents an error while parsing a reflection name.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.SimpleTypeResolveContext">
            <summary>
            Default ITypeResolveContext implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.SpecialType">
            <summary>
            Contains static implementations of special types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType">
            <summary>
            Gets the type representing resolve errors.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NullType">
            <summary>
            The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NoType">
            <summary>
            Used for expressions without type, e.g. method groups or lambdas.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.Dynamic">
            <summary>
            Type representing the C# 'dynamic' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NInt">
            <summary>
            Type representing the C# 9 'nint' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NUInt">
            <summary>
            Type representing the C# 9 'nuint' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.ArgList">
            <summary>
            Type representing the result of the C# '__arglist()' expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument">
            <summary>
            A type used for unbound type arguments in partially parameterized types.
            </summary>
            <see cref="M:ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.Decompiler.TypeSystem.ITypeDefinition},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)"/>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TaskType">
            <summary>
            Helper class for dealing with System.Threading.Tasks.Task.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.UnpackTask(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the T in Task&lt;T&gt;.
            Returns void for non-generic Task.
            Any other type is returned unmodified.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.IsTask(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is Task or Task&lt;T&gt;.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.IsCustomTask(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType@)">
            <summary>
            Gets whether the specified type is a Task-like type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.IsNonGenericTaskType(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.FullTypeName@)">
            <summary>
            Gets whether the specified type is a non-generic Task-like type.
            </summary>
            <param name="builderTypeName">Returns the full type-name of the builder type, if successful.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.IsGenericTaskType(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.FullTypeName@)">
            <summary>
            Gets whether the specified type is a generic Task-like type.
            </summary>
            <param name="builderTypeName">Returns the full type-name of the builder type, if successful.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TaskType.Create(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Creates a task type.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName">
            <summary>
            Holds the name of a top-level type.
            This struct cannot refer to nested classes.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeKind">
            <summary>
            .
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Other">
            <summary>Language-specific type that is not part of NRefactory.TypeSystem itself.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Class">
            <summary>A <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType"/> that is a class.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Interface">
            <summary>A <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType"/> that is an interface.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Struct">
            <summary>A <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType"/> that is a struct.</summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Delegate">
            <summary>A <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.Decompiler.TypeSystem.ParameterizedType"/> that is a delegate.</summary>
            <remarks><c>System.Delegate</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Enum">
            <summary>A <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition"/> that is an enum.</summary>
            <remarks><c>System.Enum</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Void">
            <summary>The <c>System.Void</c> type.</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Void"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Unknown">
            <summary>Type used for invalid expressions and for types whose definition could not be found.</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Null">
            <summary>The type of the null literal.</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NullType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.None">
            <summary>The type of expressions without type (except for null literals, which have <c>TypeKind.Null</c>).</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.NoType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Dynamic">
            <summary>Type representing the C# 'dynamic' type.</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.Dynamic"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.UnboundTypeArgument">
            <summary>Represents missing type arguments in partially parameterized types.</summary>
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument"/>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.IType">IType.GetNestedTypes(Predicate{ITypeDefinition}, GetMemberOptions)</see>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.TypeParameter">
            <summary>The type is a type parameter.</summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.ITypeParameter"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Array">
            <summary>An array type</summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.ArrayType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Pointer">
            <summary>A pointer type</summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.PointerType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.ByReference">
            <summary>A managed reference type</summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.ByReferenceType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Intersection">
            <summary>Intersection of several types</summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.IntersectionType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.ArgList">
            <see cref="F:ICSharpCode.Decompiler.TypeSystem.SpecialType.ArgList"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.Tuple">
            <summary>A C# 7 tuple type.
            E.g. <code>(string, int)</code>
            Note: <code>System.ValueTuple&lt;string, int&gt;</code> is not considered a tuple type.
            </summary>
            <see cref="T:ICSharpCode.Decompiler.TypeSystem.TupleType"/>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.ModOpt">
            <summary>
            Modified type, with optional modifier.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.ModReq">
            <summary>
            Modified type, with required modifier.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.NInt">
            <summary>
            C# 9 <c>nint</c>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.NUInt">
            <summary>
            C# 9 <c>nuint</c>
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeKind.FunctionPointer">
            <summary>
            C# 9 <c>delegate*</c>
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution">
            <summary>
            Substitutes class and method type parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution.Identity">
            <summary>
            The identity function.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution.#ctor(System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType},System.Collections.Generic.IReadOnlyList{ICSharpCode.Decompiler.TypeSystem.IType})">
            <summary>
            Creates a new type parameter substitution.
            </summary>
            <param name="classTypeArguments">
            The type arguments to substitute for class type parameters.
            Pass <c>null</c> to keep class type parameters unmodified.
            </param>
            <param name="methodTypeArguments">
            The type arguments to substitute for method type parameters.
            Pass <c>null</c> to keep method type parameters unmodified.
            </param>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution.ClassTypeArguments">
            <summary>
            Gets the list of class type arguments.
            Returns <c>null</c> if this substitution keeps class type parameters unmodified.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution.MethodTypeArguments">
            <summary>
            Gets the list of method type arguments.
            Returns <c>null</c> if this substitution keeps method type parameters unmodified.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution.Compose(ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution,ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Computes a single TypeParameterSubstitution so that for all types <c>t</c>:
            <c>t.AcceptVisitor(Compose(g, f)) equals t.AcceptVisitor(f).AcceptVisitor(g)</c>
            </summary>
            <remarks>If you consider type parameter substitution to be a function, this is function composition.</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions">
            <summary>
            Contains extension methods for the type system.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAllBaseTypes(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets all base types.
            </summary>
            <remarks>This is the reflexive and transitive closure of <see cref="P:ICSharpCode.Decompiler.TypeSystem.IType.DirectBaseTypes"/>.
            Note that this method does not return all supertypes - doing so is impossible due to contravariance
            (and undesirable for covariance as the list could become very large).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetNonInterfaceBaseTypes(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets all non-interface base types.
            </summary>
            <remarks>
            When <paramref name="type"/> is an interface, this method will also return base interfaces (return same output as GetAllBaseTypes()).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAllBaseTypeDefinitions(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets all base type definitions.
            The output is ordered so that base types occur before derived types.
            </summary>
            <remarks>
            This is equivalent to type.GetAllBaseTypes().Select(t => t.GetDefinition()).Where(d => d != null).Distinct().
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsDerivedFrom(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition,ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether this type definition is derived from the base type definition.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsDerivedFrom(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition,ICSharpCode.Decompiler.TypeSystem.KnownTypeCode)">
            <summary>
            Gets whether this type definition is derived from a given known type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetDeclaringTypeDefinitions(ICSharpCode.Decompiler.TypeSystem.ITypeDefinition)">
            <summary>
            Returns all declaring type definitions of this type definition.
            The output is ordered so that inner types occur before outer types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsOpen(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is an open type (contains type parameters).
            </summary>
            <example>
            <code>
            class X&lt;T&gt; {
              List&lt;T&gt; open;
              X&lt;X&lt;T[]&gt;&gt; open;
              X&lt;string&gt; closed;
              int closed;
            }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetTypeParameterOwner(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the entity that owns the type parameters occurring in the specified type.
            If both class and method type parameters are present, the method is returned.
            Returns null if the specified type is closed.
            </summary>
            <seealso cref="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsOpen(ICSharpCode.Decompiler.TypeSystem.IType)"/>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsUnbound(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is unbound (is a generic type, but no type arguments were provided).
            </summary>
            <remarks>
            In "<c>typeof(List&lt;Dictionary&lt;,&gt;&gt;)</c>", only the Dictionary is unbound, the List is considered
            bound despite containing an unbound type.
            This method returns false for partially parameterized types (<c>Dictionary&lt;string, &gt;</c>).
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsKnownType(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.KnownTypeCode)">
            <summary>
            Gets whether the type is the specified known type.
            For generic known types, this returns true for any parameterization of the type (and also for the definition itself).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsKnownType(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.KnownAttribute)">
            <summary>
            Gets whether the type is the specified known type.
            For generic known types, this returns true for any parameterization of the type (and also for the definition itself).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetDelegateInvokeMethod(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the invoke method for a delegate type.
            </summary>
            <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAllTypeDefinitions(ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Gets all type definitions in the compilation.
            This may include types from referenced assemblies that are not accessible in the main assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetTopLevelTypeDefinitions(ICSharpCode.Decompiler.TypeSystem.ICompilation)">
            <summary>
            Gets all top level type definitions in the compilation.
            This may include types from referenced assemblies that are not accessible in the main assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.FindType(ICSharpCode.Decompiler.TypeSystem.ICompilation,ICSharpCode.Decompiler.TypeSystem.FullTypeName)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns an <see cref="T:ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
            <remarks>
            There can be multiple types with the same full name in a compilation, as a
            full type name is only unique per assembly.
            If there are multiple possible matches, this method will return just one of them.
            When possible, use <see cref="M:ICSharpCode.Decompiler.TypeSystem.IModule.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName)"/> instead to
            retrieve a type from a specific assembly.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.IModule,ICSharpCode.Decompiler.TypeSystem.FullTypeName)">
            <summary>
            Gets the type definition for the specified unresolved type.
            Returns null if the unresolved type does not belong to this assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.HasAttribute(ICSharpCode.Decompiler.TypeSystem.IEntity,ICSharpCode.Decompiler.TypeSystem.KnownAttribute,System.Boolean)">
            <summary>
            Gets whether the entity has an attribute of the specified attribute type (or derived attribute types).
            </summary>
            <param name="entity">The entity on which the attributes are declared.</param>
            <param name="attributeType">The attribute type to look for.</param>
            <param name="inherit">
            Specifies whether attributes inherited from base classes and base members
            (if the given <paramref name="entity"/> in an <c>override</c>)
            should be returned.
            </param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAttribute(ICSharpCode.Decompiler.TypeSystem.IEntity,ICSharpCode.Decompiler.TypeSystem.KnownAttribute,System.Boolean)">
            <summary>
            Gets the attribute of the specified attribute type (or derived attribute types).
            </summary>
            <param name="entity">The entity on which the attributes are declared.</param>
            <param name="attributeType">The attribute type to look for.</param>
            <param name="inherit">
            Specifies whether attributes inherited from base classes and base members
            (if the given <paramref name="entity"/> in an <c>override</c>)
            should be returned.
            </param>
            <returns>
            Returns the attribute that was found; or <c>null</c> if none was found.
            If inherit is true, an from the entity itself will be returned if possible;
            and the base entity will only be searched if none exists.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAttributes(ICSharpCode.Decompiler.TypeSystem.IEntity,System.Boolean)">
            <summary>
            Gets the attributes on the entity.
            </summary>
            <param name="entity">The entity on which the attributes are declared.</param>
            <param name="inherit">
            Specifies whether attributes inherited from base classes and base members
            (if the given <paramref name="entity"/> in an <c>override</c>)
            should be returned.
            </param>
            <returns>
            Returns the list of attributes that were found.
            If inherit is true, attributes from the entity itself are returned first;
            followed by attributes inherited from the base entity.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.HasAttribute(ICSharpCode.Decompiler.TypeSystem.IParameter,ICSharpCode.Decompiler.TypeSystem.KnownAttribute)">
            <summary>
            Gets whether the parameter has an attribute of the specified attribute type (or derived attribute types).
            </summary>
            <param name="parameter">The parameter on which the attributes are declared.</param>
            <param name="attributeType">The attribute type to look for.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetAttribute(ICSharpCode.Decompiler.TypeSystem.IParameter,ICSharpCode.Decompiler.TypeSystem.KnownAttribute)">
            <summary>
            Gets the attribute of the specified attribute type (or derived attribute types).
            </summary>
            <param name="parameter">The parameter on which the attributes are declared.</param>
            <param name="attributeType">The attribute type to look for.</param>
            <returns>
            Returns the attribute that was found; or <c>null</c> if none was found.
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.IModule,System.String,System.String,System.Int32)">
            <summary>
            Gets the type definition for a top-level type.
            </summary>
            <remarks>This method uses ordinal name comparison, not the compilation's name comparer.</remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.GetSize(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the size (in bytes) of the input type.
            Returns <c>NativeIntSize</c> for pointer-sized types.
            Returns 0 for structs and other types of unknown size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.GetSize(ICSharpCode.Decompiler.IL.StackType)">
            <summary>
            Gets the size of the input stack type.
            </summary>
            <returns>
            * 4 for <c>I4</c>,
            * 8 for <c>I8</c>,
            * <c>NativeIntSize</c> for <c>I</c> and <c>Ref</c>,
            * 0 otherwise (O, F, Void, Unknown).
            </returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsSmallIntegerType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is a small integer type.
            Small integer types are:
            * bool, sbyte, byte, char, short, ushort
            * any enums that have a small integer type as underlying type
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsCSharpSmallIntegerType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is a C# small integer type: byte, sbyte, short or ushort.
            
            Unlike the ILAst, C# does not consider bool, char or enums to be small integers.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsCSharpNativeIntegerType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is a C# 9 native integer type: nint or nuint.
            
            Returns false for (U)IntPtr.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsCSharpPrimitiveIntegerType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether the type is a C# primitive integer type: byte, sbyte, short, ushort, int, uint, long and ulong.
            
            Unlike the ILAst, C# does not consider bool, enums, pointers or IntPtr to be integers.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsIntegerType(ICSharpCode.Decompiler.IL.StackType)">
            <summary>
            Gets whether the type is an IL integer type.
            Returns true for I4, I, or I8.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsFloatType(ICSharpCode.Decompiler.IL.StackType)">
            <summary>
            Gets whether the type is an IL floating point type.
            Returns true for F4 or F8.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsCompatiblePointerTypeForMemoryAccess(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether reading/writing an element of accessType from the pointer
            is equivalent to reading/writing an element of the pointer's element type.
            </summary>
            <remarks>
            The access semantics may sligthly differ on read accesses of small integer types,
            due to zero extension vs. sign extension when the signs differ.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.IsCompatibleTypeForMemoryAccess(ICSharpCode.Decompiler.TypeSystem.IType,ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets whether reading/writing an element of accessType from the pointer
            is equivalent to reading/writing an element of the memoryType.
            </summary>
            <remarks>
            The access semantics may sligthly differ on read accesses of small integer types,
            due to zero extension vs. sign extension when the signs differ.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.GetStackType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the stack type corresponding to this type.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.GetEnumUnderlyingType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            If type is an enumeration type, returns the underlying type.
            Otherwise, returns type unmodified.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.GetSign(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Gets the sign of the input type.
            </summary>
            <remarks>
            Integer types (including IntPtr/UIntPtr) return the sign as expected.
            Floating point types and <c>decimal</c> are considered to be signed.
            <c>char</c>, <c>bool</c> and pointer types (e.g. <c>void*</c>) are unsigned.
            Enums have a sign based on their underlying type.
            All other types return <c>Sign.None</c>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.ToPrimitiveType(ICSharpCode.Decompiler.TypeSystem.KnownTypeCode)">
            <summary>
            Maps the KnownTypeCode values to the corresponding PrimitiveTypes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.ToPrimitiveType(ICSharpCode.Decompiler.TypeSystem.IType)">
            <summary>
            Maps the KnownTypeCode values to the corresponding PrimitiveTypes.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.TypeUtils.ToKnownTypeCode(ICSharpCode.Decompiler.IL.PrimitiveType)">
            <summary>
            Maps the PrimitiveType values to the corresponding KnownTypeCodes.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.IDecompilerTypeSystem">
            <summary>
            Main interface for the decompiler type system.
            
            The MetadataModule class allows decoding/resolving metadata tokens into type system entities.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException">
            <summary>
            Represents an error while resolving a reference to a type or a member.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException"/> class
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error. The content of message is intended to be understood by humans. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error. The content of message is intended to be understood by humans. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
            <param name="inner">The exception that is the cause of the current exception. If the innerException parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException"/> class
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.TypeVisitor">
            <summary>
            Base class for the visitor pattern on <see cref="T:ICSharpCode.Decompiler.TypeSystem.IType"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.TypeSystem.VarArgInstanceMethod">
            <summary>
            Used when calling a vararg method. Stores the actual parameter types being passed.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.DecompilerException">
            <summary>
            Description of DecompilerException.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.DecompilerSettings">
            <summary>
            Settings for the decompiler.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.DecompilerSettings.#ctor">
            <summary>
            Equivalent to <c>new DecompilerSettings(LanguageVersion.Latest)</c>
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.DecompilerSettings.#ctor(ICSharpCode.Decompiler.CSharp.LanguageVersion)">
            <summary>
            Creates a new DecompilerSettings instance with initial settings
            appropriate for the specified language version.
            </summary>
            <remarks>
            This does not imply that the resulting code strictly uses only language features from
            that version. Language constructs like generics or ref locals cannot be removed from
            the compiled code.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.DecompilerSettings.SetLanguageVersion(ICSharpCode.Decompiler.CSharp.LanguageVersion)">
            <summary>
            Deactivates all language features from versions newer than <paramref name="languageVersion"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.NativeIntegers">
            <summary>
            Use C# 9 <c>nint</c>/<c>nuint</c> types.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.InitAccessors">
            <summary>
            Use C# 9 <c>init;</c> property accessors.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.FunctionPointers">
            <summary>
            Use C# 9 <c>delegate* unmanaged</c> types.
            If this option is disabled, function pointers will instead be decompiled with type `IntPtr`.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.SwitchExpressions">
            <summary>
            Use C# 8 switch expressions.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AnonymousMethods">
            <summary>
            Decompile anonymous methods/lambdas.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AnonymousTypes">
            <summary>
            Decompile anonymous types.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseLambdaSyntax">
            <summary>
            Use C# 3 lambda syntax if possible.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ExpressionTrees">
            <summary>
            Decompile expression trees.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.YieldReturn">
            <summary>
            Decompile enumerators.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.Dynamic">
            <summary>
            Decompile use of the 'dynamic' type.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AsyncAwait">
            <summary>
            Decompile async methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AwaitInCatchFinally">
            <summary>
            Decompile await in catch/finally blocks.
            Only has an effect if <see cref="P:ICSharpCode.Decompiler.DecompilerSettings.AsyncAwait"/> is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AsyncEnumerator">
            <summary>
            Decompile IAsyncEnumerator/IAsyncEnumerable.
            Only has an effect if <see cref="P:ICSharpCode.Decompiler.DecompilerSettings.AsyncAwait"/> is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.DecimalConstants">
            <summary>
            Decompile [DecimalConstant(...)] as simple literal values.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.FixedBuffers">
            <summary>
            Decompile C# 1.0 'public unsafe fixed int arr[10];' members.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.StringConcat">
            <summary>
            Decompile 'string.Concat(a, b)' calls into 'a + b'.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.LiftNullables">
            <summary>
            Use lifted operators for nullables.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.NullPropagation">
            <summary>
            Decompile C# 6 ?. and ?[] operators.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AutomaticProperties">
            <summary>
            Decompile automatic properties
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AutomaticEvents">
            <summary>
            Decompile automatic events
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UsingStatement">
            <summary>
            Decompile using statements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseEnhancedUsing">
            <summary>
            Use enhanced using statements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AlwaysUseBraces">
            <summary>
            Gets/Sets whether to use braces for single-statement-blocks. 
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ForEachStatement">
            <summary>
            Decompile foreach statements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ForEachWithGetEnumeratorExtension">
            <summary>
            Support GetEnumerator extension methods in foreach.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.LockStatement">
            <summary>
            Decompile lock statements.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseImplicitMethodGroupConversion">
            <summary>
            Gets/Sets whether to use C# 2.0 method group conversions.
            true: <c>EventHandler h = this.OnClick;</c>
            false: <c>EventHandler h = new EventHandler(this.OnClick);</c>
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AlwaysCastTargetsOfExplicitInterfaceImplementationCalls">
            <summary>
            Gets/Sets whether to always cast targets to explicitly implemented methods.
            true: <c>((ISupportInitialize)pictureBox1).BeginInit();</c>
            false: <c>pictureBox1.BeginInit();</c>
            default: false
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AlwaysQualifyMemberReferences">
            <summary>
            Gets/Sets whether to always qualify member references.
            true: <c>this.DoSomething();</c>
            false: <c>DoSomething();</c>
            default: false
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AlwaysShowEnumMemberValues">
            <summary>
            Gets/Sets whether to always show enum member values.
            true: <c>enum Kind { A = 0, B = 1, C = 5 }</c>
            false: <c>enum Kind { A, B, C = 5 }</c>
            default: false
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseDebugSymbols">
            <summary>
            Gets/Sets whether to use variable names from debug symbols, if available.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ArrayInitializers">
            <summary>
            Gets/Sets whether to use array initializers.
            If set to false, might produce non-compilable code.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ObjectOrCollectionInitializers">
            <summary>
            Gets/Sets whether to use C# 3.0 object/collection initializers.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.DictionaryInitializers">
            <summary>
            Gets/Sets whether to use C# 6.0 dictionary initializers.
            Only has an effect if ObjectOrCollectionInitializers is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ExtensionMethodsInCollectionInitializers">
            <summary>
            Gets/Sets whether to use C# 6.0 Extension Add methods in collection initializers.
            Only has an effect if ObjectOrCollectionInitializers is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseRefLocalsForAccurateOrderOfEvaluation">
            <summary>
            Gets/Sets whether to use C# 6.0 Extension Add methods in collection initializers.
            Only has an effect if ObjectOrCollectionInitializers is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.RefExtensionMethods">
            <summary>
            Gets/Sets whether to use C# 7.2 'ref' extension methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.StringInterpolation">
            <summary>
            Gets/Sets whether to use C# 6.0 string interpolation
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ShowXmlDocumentation">
            <summary>
            Gets/Sets whether to include XML documentation comments in the decompiled code.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.DecompileMemberBodies">
            <summary>
            Gets/Sets whether member bodies should be decompiled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseExpressionBodyForCalculatedGetterOnlyProperties">
            <summary>
            Gets/Sets whether simple calculated getter-only property declarations
            should use expression body syntax.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.OutVariables">
            <summary>
            Gets/Sets whether out variable declarations should be used when possible.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.Discards">
            <summary>
            Gets/Sets whether discards should be used when possible.
            Only has an effect if <see cref="P:ICSharpCode.Decompiler.DecompilerSettings.OutVariables"/> is enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.IntroduceRefModifiersOnStructs">
            <summary>
            Gets/Sets whether IsByRefLikeAttribute should be replaced with 'ref' modifiers on structs.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.IntroduceReadonlyAndInModifiers">
            <summary>
            Gets/Sets whether IsReadOnlyAttribute should be replaced with 'readonly' modifiers on structs
            and with the 'in' modifier on parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.IntroduceUnmanagedConstraint">
            <summary>
            If this option is active, [IsUnmanagedAttribute] on type parameters
            is replaced with "T : unmanaged" constraints.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.StackAllocInitializers">
            <summary>
            Gets/Sets whether C# 7.3 stackalloc initializers should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.PatternBasedFixedStatement">
            <summary>
            Gets/Sets whether C# 7.3 pattern based fixed statement should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.TupleTypes">
            <summary>
            Gets/Sets whether tuple type syntax <c>(int, string)</c>
            should be used for <c>System.ValueTuple</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ThrowExpressions">
            <summary>
            Gets/Sets whether throw expressions should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.TupleConversions">
            <summary>
            Gets/Sets whether implicit conversions between tuples
            should be used in the decompiled output.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.TupleComparisons">
            <summary>
            Gets/Sets whether tuple comparisons should be detected.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.NamedArguments">
            <summary>
            Gets/Sets whether named arguments should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.NonTrailingNamedArguments">
            <summary>
            Gets/Sets whether C# 7.2 non-trailing named arguments should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.OptionalArguments">
            <summary>
            Gets/Sets whether optional arguments should be removed, if possible.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.LocalFunctions">
            <summary>
            Gets/Sets whether C# 7.0 local functions should be transformed.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.Deconstruction">
            <summary>
            Gets/Sets whether C# 7.0 deconstruction should be detected.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.StaticLocalFunctions">
            <summary>
            Gets/Sets whether C# 8.0 static local functions should be transformed.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.Ranges">
            <summary>
            Gets/Sets whether C# 8.0 index and range syntax should be used.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.NullableReferenceTypes">
            <summary>
            Gets/Sets whether C# 8.0 nullable reference types are enabled.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AssumeArrayLengthFitsIntoInt32">
            <summary>
            Gets/Sets whether the decompiler can assume that 'ldlen; conv.i4.ovf'
            does not throw an overflow exception.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.IntroduceIncrementAndDecrement">
            <summary>
            Gets/Sets whether to use increment and decrement operators
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.MakeAssignmentExpressions">
            <summary>
            Gets/Sets whether to use assignment expressions such as in while ((count = Do()) != 0) ;
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ForStatement">
            <summary>
            Gets/sets whether the decompiler should produce for loops.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.DoWhileStatement">
            <summary>
            Gets/sets whether the decompiler should produce do-while loops.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.SeparateLocalVariableDeclarations">
            <summary>
            Gets/sets whether the decompiler should separate local variable declarations
            from their initialization.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseSdkStyleProjectFormat">
            <summary>
            Gets or sets a value indicating whether the new SDK style format
            shall be used for the generated project files.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AggressiveInlining">
            <summary>
            If set to false (the default), the decompiler will inline local variables only when they occur
            in a context where the C# compiler is known to emit compiler-generated locals.
            If set to true, the decompiler will inline local variables whenever possible.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Metadata.CodeMappingInfo">
            <summary>
            Describes which parts of the (compiler-generated) code belong to which user code.
            A part could be:
            - the body (method) of a lambda.
            - the MoveNext method of async/yield state machines.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.Module">
            <summary>
            The module containing the code.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.TypeDefinition">
            <summary>
            The (parent) TypeDef containing the code.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.#ctor(ICSharpCode.Decompiler.Metadata.PEFile,System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Creates a <see cref="T:ICSharpCode.Decompiler.Metadata.CodeMappingInfo"/> instance using the given <paramref name="module"/> and <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.GetMethodParts(System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            Returns all parts of a method.
            A method has at least one part, that is, the method itself.
            If no parts are found, only the method itself is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.GetParentMethod(System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            Returns the parent of a part.
            The parent is usually the "calling method" of lambdas, async and yield state machines.
            The "calling method" has itself as parent.
            If no parent is found, the method itself is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.CodeMappingInfo.AddMapping(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            Adds a bidirectional mapping between <paramref name="parent"/> and <paramref name="part"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Metadata.CustomAttributeDecoder`1">
            <summary>
            Decodes custom attribute blobs.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Metadata.MethodSemanticsLookup">
            <summary>
            Lookup structure that, for an accessor, can find the associated property/event.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Metadata.PEFile">
            <summary>
            PEFile is the main class the decompiler uses to represent a metadata assembly/module.
            Every file on disk can be loaded into a standalone PEFile instance.
            
            A PEFile can be combined with its referenced assemblies/modules to form a type system,
            in that case the <see cref="T:ICSharpCode.Decompiler.TypeSystem.MetadataModule"/> class is used instead.
            </summary>
            <remarks>
            In addition to wrapping a <c>System.Reflection.Metadata.PEReader</c>, this class
            contains a few decompiler-specific caches to allow efficiently constructing a type
            system from multiple PEFiles. This allows the caches to be shared across multiple
            decompiled type systems.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.PEFile.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName)">
            <summary>
            Finds the top-level-type with the specified name.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.PEFile.GetTypeForwarder(ICSharpCode.Decompiler.TypeSystem.FullTypeName)">
            <summary>
            Finds the type forwarder with the specified name.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.UniversalAssemblyResolver.ResolveSilverlight(ICSharpCode.Decompiler.Metadata.IAssemblyReference,System.Version)">
            <summary>
            This only works on Windows
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Metadata.UniversalAssemblyResolver.EnumerateGac">
            <summary>
            Gets the names of all assemblies in the GAC.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Metadata.MetadataExtensions.MinimalAttributeTypeProvider">
            <summary>
            An attribute type provider that can be used to decode attribute signatures
            that only mention built-in types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.SRMExtensions.GetAttributeType(System.Reflection.Metadata.CustomAttribute,System.Reflection.Metadata.MetadataReader)">
            <summary>
            Gets the type of the attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.LongDict`1">
            <summary>
            An immutable mapping from keys of type long to values of type T.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongDict`1.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{ICSharpCode.Decompiler.Util.LongSet,`0}})">
            <summary>
            Creates a new LongDict from the given entries.
            If there are multiple entries for the same long key,
            the resulting LongDict will store the value from the first entry.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.ResourcesFile">
            <summary>
            .resources file.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.ResourcesFile.MagicNumber">
            <summary>Holds the number used to identify resource files.</summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.ResourcesFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new ResourcesFile.
            </summary>
            <param name="stream">Input stream.</param>
            <param name="leaveOpen">Whether the stream should be help open when the ResourcesFile is disposed.</param>
            <remarks>
            The stream is must be held open while the ResourcesFile is in use.
            The stream must be seekable; any operation using the ResourcesFile will end up seeking the stream.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.ResourceSerializedObject.GetStream">
            <summary>
            Gets a stream that starts with the serialized object data.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.ResourceSerializedObject.GetBytes">
            <summary>
            Gets the serialized object data.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.LF">
            <summary>
            Line Feed, U+000A
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.CR">
            <summary>
            Carriage Return, U+000D
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.NEL">
            <summary>
            Next Line, U+0085
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.VT">
            <summary>
            Vertical Tab, U+000B
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.FF">
            <summary>
            Form Feed, U+000C
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.LS">
            <summary>
            Line Separator, U+2028
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.UnicodeNewline.PS">
            <summary>
            Paragraph Separator, U+2029
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.NewLine">
            <summary>
            Defines unicode new lines according to  Unicode Technical Report #13
            http://www.unicode.org/standard/reports/tr13/tr13-5.html
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.CR">
            <summary>
            Carriage Return, U+000D
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.LF">
            <summary>
            Line Feed, U+000A
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.NEL">
            <summary>
            Next Line, U+0085
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.VT">
            <summary>
            Vertical Tab, U+000B
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.FF">
            <summary>
            Form Feed, U+000C
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.LS">
            <summary>
            Line Separator, U+2028
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.NewLine.PS">
            <summary>
            Paragraph Separator, U+2029
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.GetDelimiterLength(System.Char,System.Func{System.Char})">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.GetDelimiterLength(System.Char,System.Char)">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.TryGetDelimiterLengthAndType(System.Char,System.Int32@,ICSharpCode.Decompiler.Util.UnicodeNewline@,System.Func{System.Char})">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name = "length">The length of the delimiter</param>
            <param name = "type">The type of the delimiter</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.TryGetDelimiterLengthAndType(System.Char,System.Int32@,ICSharpCode.Decompiler.Util.UnicodeNewline@,System.Char)">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name = "length">The length of the delimiter</param>
            <param name = "type">The type of the delimiter</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.GetDelimiterType(System.Char,System.Func{System.Char})">
            <summary>
            Gets the new line type of a given char/next char.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.GetDelimiterType(System.Char,System.Char)">
            <summary>
            Gets the new line type of a given char/next char.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.IsNewLine(System.Char)">
            <summary>
            Determines if a char is a new line delimiter. 
            
            Note that the only 2 char wide new line is CR LF and both chars are new line
            chars on their own. For most cases GetDelimiterLength is the better choice.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.NewLine.GetString(ICSharpCode.Decompiler.Util.UnicodeNewline)">
            <summary>
            Gets the new line as a string.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.BusyManager">
            <summary>
            This class is used to prevent stack overflows by representing a 'busy' flag
            that prevents reentrance when another call is running.
            However, using a simple 'bool busy' is not thread-safe, so we use a
            thread-static BusyManager.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.CacheManager">
            <summary>
            Allows caching values for a specific compilation.
            A CacheManager consists of a for shared instances (shared among all threads working with that resolve context).
            </summary>
            <remarks>This class is thread-safe</remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.CallbackOnDispose">
            <summary>
            Invokes an action when it is disposed.
            </summary>
            <remarks>
            This class ensures the callback is invoked at most once,
            even when Dispose is called on multiple threads.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectArray``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToArray()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectImmutableArray``2(System.Collections.Generic.IReadOnlyCollection{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToImmutableArray()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectReadOnlyArray``2(System.Collections.Generic.IReadOnlyCollection{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToArray()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectArray``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToArray()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectArray``2(``0[],System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToArray()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.SelectList``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <code>collection.Select(func).ToList()</code>, but more efficient as it makes
            use of the input collection's known size.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.Merge``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            The merge step of merge sort.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the minimum element.
            </summary>
            <exception cref="T:System.InvalidOperationException">The input sequence is empty</exception>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the minimum element.
            </summary>
            <exception cref="T:System.InvalidOperationException">The input sequence is empty</exception>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the maximum element.
            </summary>
            <exception cref="T:System.InvalidOperationException">The input sequence is empty</exception>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CollectionExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the maximum element.
            </summary>
            <exception cref="T:System.InvalidOperationException">The input sequence is empty</exception>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.BitSet">
            <summary>
            Improved version of BitArray
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.#ctor(System.Int32)">
            <summary>
            Creates a new bitset, where initially all bits are zero.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.Any">
            <summary>
            Gets whether at least one bit is set.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.All(System.Int32,System.Int32)">
            <summary>
            Gets whether all bits in the specified range are set.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.SetEquals(ICSharpCode.Decompiler.Util.BitSet)">
            <summary>
            Gets whether both bitsets have the same content.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.IsSubsetOf(ICSharpCode.Decompiler.Util.BitSet)">
            <summary>
            Gets whether this set is a subset of other, or equal.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.IsSupersetOf(ICSharpCode.Decompiler.Util.BitSet)">
            <summary>
            Gets whether this set is a superset of other, or equal.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.Overlaps(ICSharpCode.Decompiler.Util.BitSet)">
            <summary>
            Gets whether at least one bit is set in both bitsets.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.Set(System.Int32,System.Int32)">
            <summary>
            Sets all bits i; where startIndex &lt;= i &lt; endIndex.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.BitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clear all bits i; where startIndex &lt;= i &lt; endIndex.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.CSharpPrimitiveCast">
            <summary>
            Static helper method for converting between primitive types.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.CSharpPrimitiveCast.Cast(System.TypeCode,System.Object,System.Boolean)">
            <summary>
            Performs a conversion between primitive types.
            Unfortunately we cannot use Convert.ChangeType because it has different semantics
            (e.g. rounding behavior for floats, overflow, etc.), so we write down every possible primitive C# cast
            and let the compiler figure out the exact semantics.
            And we have to do everything twice, once in a checked-block, once in an unchecked-block.
            </summary>
            <exception cref="T:System.OverflowException">Overflow checking is enabled and an overflow occurred.</exception>
            <exception cref="T:System.InvalidCastException">The cast is invalid, e.g. casting a boolean to an integer.</exception>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.ExtensionMethods">
            <summary>
            Contains extension methods for internal use within the decompiler.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.Interval">
            <summary>
            Represents a half-closed interval.
            The start position is inclusive; but the end position is exclusive.
            </summary>
            <remarks>
            Start &lt;= unchecked(End - 1): normal interval
            Start == End: empty interval
            Special case: Start == End == int.MinValue: interval containing all integers, not an empty interval!
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.Interval.Start">
            <summary>
            Gets the inclusive start of the interval.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.Interval.End">
            <summary>
            Gets the exclusive end of the interval.
            </summary>
            <remarks>
            Note that an End of int.MinValue is a special case, and stands
            for an actual End of int.MaxValue+1.
            If possible, prefer using InclusiveEnd for comparisons, as that does not have an overflow problem.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.Interval.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new interval.
            </summary>
            <param name="start">Start position (inclusive)</param>
            <param name="end">End position (exclusive).
            Note that it is possible to create an interval that includes int.MaxValue
            by using end==int.MaxValue+1==int.MinValue.</param>
        </member>
        <member name="P:ICSharpCode.Decompiler.Util.Interval.InclusiveEnd">
            <summary>
            Gets the inclusive end of the interval. (End - 1)
            For empty intervals, this returns Start - 1.
            </summary>
            <remarks>
            Because there is no empty interval at int.MinValue,
            (Start==End==int.MinValue is a special case referring to [int.MinValue..int.MaxValue]),
            integer overflow is not a problem here.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.Interval.Intersect(ICSharpCode.Decompiler.Util.Interval)">
            <summary>
            Calculates the intersection between this interval and the other interval.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.LongInterval">
            <summary>
            Represents a half-closed interval.
            The start position is inclusive; but the end position is exclusive.
            </summary>
            <remarks>
            Start &lt;= unchecked(End - 1): normal interval
            Start == End: empty interval
            Special case: Start == End == long.MinValue: interval containing all integers, not an empty interval!
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.LongInterval.Start">
            <summary>
            Gets the inclusive start of the interval.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.LongInterval.End">
            <summary>
            Gets the exclusive end of the interval.
            </summary>
            <remarks>
            Note that an End of long.MinValue is a special case, and stands
            for an actual End of long.MaxValue+1.
            If possible, prefer using InclusiveEnd for comparisons, as that does not have an overflow problem.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongInterval.#ctor(System.Int64,System.Int64)">
            <summary>
            Creates a new interval.
            </summary>
            <param name="start">Start position (inclusive)</param>
            <param name="end">End position (exclusive).
            Note that it is possible to create an interval that includes long.MaxValue
            by using end==long.MaxValue+1==long.MinValue.</param>
            <remarks>
            This method can be used to create an empty interval by specifying start==end,
            however this is error-prone due to the special case of
            start==end==long.MinValue being interpreted as the full interval [long.MinValue,long.MaxValue].
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongInterval.Inclusive(System.Int64,System.Int64)">
            <summary>
            Creates a new interval from start to end.
            Unlike the constructor where the end position is exclusive,
            this method interprets the end position as inclusive.
            
            This method cannot be used to construct an empty interval.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.Util.LongInterval.InclusiveEnd">
            <summary>
            Gets the inclusive end of the interval. (End - 1)
            For empty intervals, this returns Start - 1.
            </summary>
            <remarks>
            Because there is no empty interval at int.MinValue,
            (Start==End==int.MinValue is a special case referring to [int.MinValue..int.MaxValue]),
            integer overflow is not a problem here.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongInterval.Intersect(ICSharpCode.Decompiler.Util.LongInterval)">
            <summary>
            Calculates the intersection between this interval and the other interval.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongInterval.Range">
            <summary>
            Returns an enumerator over all values in this interval.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LazyInit.GetOrSet``1(``0@,``0)">
            <summary>
            Atomically performs the following operation:
            - If target is null: stores newValue in target and returns newValue.
            - If target is not null: returns target.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.LongSet">
            <summary>
            An immutable set of longs, that is implemented as a list of intervals.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.LongSet.Intervals">
            <summary>
            The intervals in this set of longs.
            </summary>
            <remarks>
            Invariant: the intervals in this array are non-empty, non-overlapping, non-touching, and sorted.
            
            This invariant ensures every LongSet is always in a normalized representation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.#ctor(System.Int64)">
            <summary>
            Create a new LongSet that contains a single value.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.#ctor(ICSharpCode.Decompiler.Util.LongInterval)">
            <summary>
            Create a new LongSet that contains the values from the interval.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.Util.LongInterval})">
            <summary>
            Creates a new LongSet the contains the values from the specified intervals.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.LongSet.Empty">
            <summary>
            The empty LongSet.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Util.LongSet.Universe">
            <summary>
            The LongSet that contains all possible long values.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.Count">
            <summary>
            Gets the number of values in this LongSet.
            Note: for <c>LongSet.Universe</c>, the number of values does not fit into <c>ulong</c>.
            Instead, this property returns the off-by-one value <c>ulong.MaxValue</c> to avoid overflow.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.MergeOverlapping(System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.Util.LongInterval})">
            <summary>
            Given an enumerable of non-empty intervals sorted by the starting position,
            merges overlapping or touching intervals to create a valid interval array for LongSet.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.AddOffset(System.Int64)">
            <summary>
            Creates a new LongSet where val is added to each element of this LongSet.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.ExceptWith(ICSharpCode.Decompiler.Util.LongSet)">
            <summary>
            Creates a new set that contains all values that are in <c>this</c>, but not in <c>other</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.Invert">
            <summary>
            Creates a new LongSet that contains all elements not contained in this LongSet.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.IsSubsetOf(ICSharpCode.Decompiler.Util.LongSet)">
            <summary>
            Gets whether this set is a subset of other, or equal.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.LongSet.IsSupersetOf(ICSharpCode.Decompiler.Util.LongSet)">
            <summary>
            Gets whether this set is a superset of other, or equal.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.MultiDictionary`2">
            <summary>
            A dictionary that allows multiple pairs with the same key.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.MultiDictionary`2.RemoveAll(`0)">
            <summary>
            Removes all entries with the specified key.
            </summary>
            <returns>Returns true if at least one entry was removed.</returns>
        </member>
        <member name="P:ICSharpCode.Decompiler.Util.MultiDictionary`2.Count">
            <summary>
            Returns the number of different keys.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.Platform">
            <summary>
            Platform-specific code.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.TreeTraversal">
            <summary>
            Static helper methods for traversing trees.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.TreeTraversal.PreOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.TreeTraversal.PreOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.TreeTraversal.PostOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="M:ICSharpCode.Decompiler.Util.TreeTraversal.PostOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="T:ICSharpCode.Decompiler.Util.UnionFind`1">
            <summary>
            Union-Find data structure.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode">
            <summary>
            Represents a block in the control flow graph.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.UserIndex">
            <summary>
            User index, can be used to look up additional information in an array.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.UserData">
            <summary>
            User data.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Visited">
            <summary>
            Visited flag, used in various algorithms.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.PostOrderNumber">
            <summary>
            Gets the node index in a post-order traversal of the control flow graph, starting at the
            entry point. This field gets computed by dominance analysis.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.IsReachable">
            <summary>
            Gets whether this node is reachable. Requires that dominance is computed!
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.ImmediateDominator">
            <summary>
            Gets the immediate dominator (the parent in the dominator tree).
            Null if dominance has not been calculated; or if the node is unreachable.
            </summary>
        </member>
        <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.DominatorTreeChildren">
            <summary>
            List of children in the dominator tree.
            Null if dominance has not been calculated; or if the node is unreachable.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Predecessors">
            <summary>
            List of incoming control flow edges.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Successors">
            <summary>
            List of outgoing control flow edges.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Dominates(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Gets whether <c>this</c> dominates <paramref name="node"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1">
            <summary>
            Interface for use with DataFlowVisitor.
            
            A mutable container for the state tracked by the data flow analysis.
            </summary>
            <remarks>
            States must form a join-semilattice: https://en.wikipedia.org/wiki/Semilattice
            
            To handle <c>try{} finally{}</c> properly, states should implement <c>MeetWith()</c> as well,
            and thus should form a lattice.
            
            <c>DataFlowVisitor</c> expects the state to behave like a mutable reference type.
            It might still be a good idea to use a struct to implement it so that .NET uses static dispatch for
            method calls on the type parameter, but that struct must consist only of a <c>readonly</c> field
            referencing some mutable object, to ensure the type parameter behaves as it if was a mutable reference type.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.LessThanOrEqual(`0)">
            <summary>
            Gets whether this state is "less than" (or equal to) another state.
            This is the partial order of the semi-lattice.
            </summary>
            <remarks>
            The exact meaning of this relation is up to the concrete implementation,
            but usually "less than" means "has less information than".
            A given position in the code starts at the "bottom state" (=no information)
            and then adds more information as the analysis progresses.
            After each change to the state, the old state must be less than the new state,
            so that the analysis does not run into an infinite loop.
            The partially ordered set must also have finite height (no infinite ascending chains s1 &lt; s2 &lt; ...),
            to ensure the analysis terminates.
            </remarks>
            <example>
            The simplest possible non-trivial state, <c>bool isReachable</c>, would implement <c>LessThanOrEqual</c> as:
            <code>return (this.isReachable ? 1 : 0) &lt;= (otherState.isReachable ? 1 : 0);</code>
            <para>Which can be simpified to:</para>
            <code>return !this.isReachable || otherState.isReachable;</code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.Clone">
            <summary>
            Creates a new object with a copy of the state.
            </summary>
            <remarks>
            Mutating methods such as <c>ReplaceWith</c> or <c>JoinWith</c> modify the contents of a state object.
            Cloning the object allows the analysis to track multiple independent states,
            such as the
            </remarks>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>Clone</c> as:
            <code>return new MyState(this.isReachable);</code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.ReplaceWith(`0)">
            <summary>
            Replace the contents of this state object with a copy of those in <paramref name="newContent"/>.
            </summary>
            <remarks>
            <c>x = x.Clone(); x.ReplaceWith(newContent);</c>
            is equivalent to
            <c>x = newContent.Clone();</c>
            
            ReplaceWith() is used to avoid allocating new state objects where possible.
            </remarks>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>ReplaceWith</c> as:
            <code>this.isReachable = newContent.isReachable;</code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.JoinWith(`0)">
            <summary>
            Join the incomingState into this state.
            </summary>
            <remarks>
            Postcondition: <c>old(this).LessThanOrEqual(this) &amp;&amp; incomingState.LessThanOrEqual(this)</c>
            This method should set <c>this</c> to the smallest state that is greater than (or equal to)
            both input states.
            
            <c>JoinWith()</c> is used when multiple control flow paths are joined together.
            For example, it is used to combine the <c>thenState</c> with the <c>elseState</c>
            at the end of a if-else construct.
            </remarks>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>JoinWith</c> as:
            <code>this.isReachable |= incomingState.isReachable;</code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.TriggerFinally(`0)">
            <summary>
            A special operation to merge the end-state of the finally-block with the end state of
            a branch leaving the try-block.
            
            If either input state is unreachable, this call must result in an unreachable state.
            </summary>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>TriggerFinally</c> as:
            <code>this.isReachable &amp;= finallyState.isReachable;</code>
            </example>
        </member>
        <member name="P:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.IsBottom">
            <summary>
            Gets whether this is the bottom state.
            
            The bottom state represents that the data flow analysis has not yet
            found a code path from the entry point to this state's position.
            It thus contains no information, and is "less than" all other states.
            </summary>
            <remarks>
            The bottom state is the bottom element in the semi-lattice.
            
            Initially, all code blocks not yet visited by the analysis will be in the bottom state.
            Unreachable code will always remain in the bottom state.
            Some analyses may also use the bottom state for reachable code after it was processed by the analysis.
            For example, in <c>DefiniteAssignmentVisitor</c> the bottom states means
            "either this code is unreachable, or all variables are definitely initialized".
            </remarks>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>IsBottom</c> as:
            <code>return !this.isReachable;</code>
            </example>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1.ReplaceWithBottom">
            <summary>
            Equivalent to <c>this.ReplaceWith(bottomState)</c>, but may be implemented more efficiently.
            </summary>
            <remarks>
            Since the <c>DataFlowVisitor</c> can only create states by cloning from the initial state,
            this method is necessary for the <c>DataFlowVisitor</c> to gain access to the bottom element in
            the first place.
            </remarks>
            <example>
            The simple state "<c>bool isReachable</c>", would implement <c>ReplaceWithBottom</c> as:
            <code>this.isReachable = false;</code>
            </example>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1">
            <summary>
            Generic base class for forward data flow analyses.
            </summary>
            <typeparam name="State">
            The state type used for the data flow analysis. See <see cref="T:ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1"/> for details.
            </typeparam>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.bottomState">
            <summary>
            The bottom state.
            Must not be mutated.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.state">
            <summary>
            Current state.
            
            Caution: any state object assigned to this member gets mutated as the visitor traverses the ILAst!
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.currentStateOnException">
            <summary>
            Combined state of all possible exceptional control flow paths in the current try block.
            Serves as input state for catch blocks.
            
            Caution: any state object assigned to this member gets mutated as the visitor encounters instructions that may throw exceptions!
            
            Within a try block, <c>currentStateOnException == stateOnException[tryBlock.Parent]</c>.
            </summary>
            <seealso cref="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.PropagateStateOnException"/>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.Initialize(`0)">
            <summary>
            Initializes the DataFlowVisitor.
            This method must be called once before any Visit()-methods can be called.
            It must not be called more than once.
            </summary>
            <param name="initialState">The initial state at the entry point of the analysis.</param>
            <remarks>
            This is a method instead of a constructor because derived classes might need complex initialization
            before they can construct the initial state.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.flagsRequiringManualImpl">
            <summary>
            Derived classes may add to this set of flags to ensure they don't forget to override an interesting method.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.PropagateStateOnException">
            <summary>
            Handle control flow when the current instruction throws an exception:
            joins the current state into the "exception state" of the current try block.
            </summary>
            <remarks>
            This should not only be called for instructions that may throw an exception,
            but for all instructions (due to async exceptions like ThreadAbortException)!
            
            To avoid redundant calls, every Visit() call may assume that the current state
            is already propagated, and has to guarantee the same at the end.
            This means this method should be called after every state change.
            Alternatively, derived classes may directly modify both <c>state</c>
            and <c>currentStateOnException</c>, so that a full <c>JoinWith()</c> call
            is not necessary.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.MarkUnreachable">
            <summary>
            Replace the current state with the bottom state.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.stateOnBranch">
            <summary>
            Holds the state for incoming branches.
            </summary>
            <remarks>
            Only used for blocks in block containers; not for inline blocks.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.stateOnLeave">
            <summary>
            Holds the state at the block container end-point. (=state for incoming 'leave' instructions)
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.GetBlockInputState(ICSharpCode.Decompiler.IL.Block)">
            <summary>
            Gets the state object that holds the state for incoming branches to the block.
            </summary>
            <remarks>
            Returns the a clone of the bottom state on the first call for a given block,
            then returns the same object instance on further calls.
            The caller is expected to mutate the returned state by calling <c>JoinWith()</c>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.workLists">
            <summary>
            For each block container, stores the set of blocks (via Block.ChildIndex)
            that had their incoming state changed and were not processed yet.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.stateOnException">
            <summary>
            Stores the stateOnException per try instruction.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.HandleTryBlock(ICSharpCode.Decompiler.IL.TryInstruction)">
            <summary>
            Visits the TryBlock.
            
            Returns a new State object representing the exceptional control flow transfer out of the try block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.VisitTryCatchHandler(ICSharpCode.Decompiler.IL.TryCatchHandler)">
            <summary>
            TryCatchHandler is handled directly in VisitTryCatch
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.ProcessBranchesLeavingTryFinally(ICSharpCode.Decompiler.IL.TryFinally,System.Int32)">
            <summary>
            Process branches leaving the try-finally,
             * Calls TriggerFinally() on each branchesTriggeringFinally
             * Removes entries from branchesTriggeringFinally if they won't trigger additional finally blocks.
             * After all finallies are applied, the branch state is merged into the target block.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.EvaluateCondition(ICSharpCode.Decompiler.IL.ILInstruction)">
            <summary>
            Evaluates the condition of an if.
            </summary>
            <returns>
            A pair of:
             * The state after the condition evaluates to true
             * The state after the condition evaluates to false
            </returns>
            <remarks>
            <c>this.state</c> is invalid after this function was called, and must be overwritten
            with one of the return values.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1.EvaluateMatch(ICSharpCode.Decompiler.IL.MatchInstruction)">
            <summary>
            Evaluates a match instruction.
            </summary>
            <returns>
            A pair of:
             * The state after the pattern matches
             * The state after the pattern fails to match
            </returns>
            <remarks>
            <c>this.state</c> is invalid after this function was called, and must be overwritten
            with one of the return values.
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor">
            <summary>
            DataFlowVisitor that performs definite assignment analysis.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor.State">
            <summary>
            State for definite assignment analysis.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor.State.bits">
            <summary>
            bits[i]: There is a code path from the entry point to this state's position
                     that does not write to function.Variables[i].
                     (i.e. the variable is not definitely assigned at the state's position)
            
            Initial state: all bits set = nothing is definitely assigned
            Bottom state: all bits clear
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor.State.#ctor(System.Int32)">
            <summary>
            Creates the initial state.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor.HandleLocalFunctionUse(ICSharpCode.Decompiler.TypeSystem.IMethod)">
            <summary>
            For a use of a local function, remember the current state to use as stateOnEntry when
            later processing the local function body.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.Dominance">
            <summary>
            Description of Dominance.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.Dominance.ComputeDominance(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,System.Threading.CancellationToken)">
            <summary>
            Computes the dominator tree.
            </summary>
            <remarks>
            Precondition: the dominance tree is not already computed for some nodes reachable from entryPoint
            (i.e. ImmediateDominator and DominatorTreeChildren are both null),
            and the visited flag is false for any nodes reachable from entryPoint.
            
            Postcondition: a dominator tree is constructed for all nodes reachable from entryPoint,
            and the visited flag remains false.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.Dominance.FindCommonDominator(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
            <summary>
            Returns the common ancestor of a and b in the dominator tree.
            
            Precondition: a and b are part of the same dominator tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.Dominance.MarkNodesWithReachableExits(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode[])">
            <summary>
            Computes a BitSet where
            <c>result[i] == true</c> iff cfg[i] is reachable and there is some node that is
            reachable from cfg[i] but not dominated by cfg[i].
            
            This is similar to "does cfg[i] have a non-empty dominance frontier?",
            except that it uses non-strict dominance where the definition of dominance frontiers
            uses "strictly dominates".
            
            Precondition:
             Dominance was computed for cfg and <c>cfg[i].UserIndex == i</c> for all i.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor">
            <summary>
            Implements the "reaching definitions" analysis.
            
            https://en.wikipedia.org/wiki/Reaching_definition
            
            By "definitions", we mean stores to local variables.
            </summary>
            <remarks>
            Possible "definitions" that store to a variable are:
            * <c>StLoc</c>
            * <c>TryCatchHandler</c> (for the exception variable)
            * <c>ReachingDefinitionsVisitor.UninitializedVariable</c> for uninitialized variables.
            Note that we do not keep track of <c>LdLoca</c>/references/pointers.
            The analysis will likely be wrong/incomplete for variables with <c>AddressCount != 0</c>.
            
            Note: this class does not store the computed information, because doing so
            would significantly increase the number of states we need to store.
            The only way to get the computed information out of this class is to
            derive from the class and override the Visit methods at the points of interest
            (usually the load instructions).
            </remarks>
        </member>
        <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.State">
            <summary>
            The state during the reaching definitions analysis.
            </summary>
            <remarks>
            A state can either be reachable, or unreachable:
             1) unreachable
                Note that during the analysis, "unreachable" just means we have not yet found a path
                from the entry point to the node. States transition from unreachable to reachable as
                the analysis processes more control flow paths.
             2) reachable
                In this case, the state contains, for each variable, the set of stores that might have
                written to the variable before the control flow reached the state's source code position.
                This set does not include stores that were definitely overwritten by other stores to the
                same variable.
                During the analysis, the set of stores gets extended as the analysis processes more code paths.
            
            The reachable state could be represented as a `Dictionary{ILVariable, ISet{ILInstruction}}`.
            To consume less memory, we instead assign an integer index to all stores in the analyzed function ("store index"),
            and store the state as a `BitSet` instead.
            Each bit in the set corresponds to one store instruction, and is `true` iff the store is a reaching definition
            for the variable it is storing to.
            The `allStores` array has the same length as the bit sets and holds the corresponding `ILInstruction` objects (store instructions).
            All stores for a single variable occupy a contiguous segment of the `allStores` array (and thus also of the `state`),
            which allows us to efficient clear out all stores that get overwritten by a new store.
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.State.bits">
            <summary>
            This bitset contains three different kinds of bits:
            Reachable bit: (bit 0)
                This state's position is reachable from the entry point.
            
            Reaching uninitialized variable bit: (bit si, where si > 0 and <c>allStores[si] == null</c>)
                There is a code path from the scope's entry point to this state's position
                that does not pass through any store to the variable.
            
            <c>firstStoreIndexForVariable[v.IndexInScope]</c> gives the index of that variable's uninitialized bit.
            
            Reaching store bit (bit si, where <c>allStores[si] != null</c>):
                There is a code path from the entry point to this state's position
                that passes through through <c>allStores[si]</c> and does not pass through another
                store to <c>allStores[si].Variable</c>.
            
            The indices for a variable's reaching store bits are between <c>firstStoreIndexForVariable[v.IndexInScope]</c>
            to <c>firstStoreIndexForVariable[v.IndexInScope + 1]</c> (both endpoints exclusive!).
            </summary>
            <remarks>
            The initial state has the "reachable bit" and the "reaching uninitialized variable bits" set,
            and the "reaching store bits" unset.
            
            The bottom state has all bits unset.
            </remarks>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.State.KillStores(System.Int32,System.Int32)">
            <summary>
            Clears all store bits between startStoreIndex (incl.) and endStoreIndex (excl.)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.ReachableBit">
            <summary>
            To distinguish unreachable from reachable states, we use the first bit in the bitset to store the 'reachable bit'.
            If this bit is set, the state is reachable, and the remaining bits
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.FirstStoreIndex">
            <summary>
            Because bit number 0 is the ReachableBit, we start counting store indices at 1.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.scope">
            <summary>
            The function being analyzed.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.allStores">
            <summary>
            All stores for all variables in the scope.
            
            <c>state[storeIndex]</c> is true iff <c>allStores[storeIndex]</c> is a reaching definition.
            Invariant: <c>state.bits.Length == allStores.Length</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.storeIndexMap">
            <summary>
            Maps instructions appearing in <c>allStores</c> to their index.
            
            Invariant: <c>allStores[storeIndexMap[inst]] == inst</c>
            
            Does not contain <c>UninitializedVariable</c> (as that special instruction has multiple store indices, one per variable)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.firstStoreIndexForVariable">
            <summary>
            For all variables <c>v</c>: <c>allStores[firstStoreIndexForVariable[v.IndexInScope]]</c> is the <c>UninitializedVariable</c> entry for <c>v</c>.
            The next few stores (up to <c>firstStoreIndexForVariable[v.IndexInScope + 1]</c>, exclusive) are the full list of stores for <c>v</c>.
            </summary>
            <remarks>
            Invariant: <c>firstStoreIndexForVariable[scope.Variables.Count] == allStores.Length</c>
            </remarks>
        </member>
        <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.analyzedVariables">
            <summary>
            <c>analyzedVariables[v.IndexInScope]</c> is true iff RD analysis is enabled for the variable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.#ctor(ICSharpCode.Decompiler.IL.ILFunction,System.Predicate{ICSharpCode.Decompiler.IL.ILVariable},System.Threading.CancellationToken)">
            <summary>
            Prepare reaching definitions analysis for the specified variable scope.
            
            The analysis will track all variables in the scope for which the predicate returns true
            ("analyzed variables").
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.#ctor(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.Util.BitSet,System.Threading.CancellationToken)">
            <summary>
            Prepare reaching definitions analysis for the specified variable scope.
            
            The analysis will track all variables in the scope for which <c>analyzedVariables[v.IndexInScope]</c> is true.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.FindAllStoresByVariable(ICSharpCode.Decompiler.IL.ILFunction,ICSharpCode.Decompiler.Util.BitSet,System.Threading.CancellationToken)">
            <summary>
            Fill <c>allStores</c> and <c>storeIndexMap</c>.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.CreateInitialState">
            <summary>
            Create the initial state (reachable bit + uninit variable bits set, store bits unset).
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.GetStores(ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.State,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Gets all stores to <c>v</c> that reach the specified state.
            
            Precondition: v is an analyzed variable.
            </summary>
        </member>
        <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.IsPotentiallyUninitialized(ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor.State,ICSharpCode.Decompiler.IL.ILVariable)">
            <summary>
            Gets whether <c>v</c> is potentially uninitialized in the specified state.
            
            Precondition: v is an analyzed variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.None">
            <summary>
            Convert only the name.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowParameterList">
            <summary>
            Show the parameter list
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowParameterNames">
            <summary>
            Show names for parameters
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowAccessibility">
            <summary>
            Show the accessibility (private, public, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowDefinitionKeyword">
            <summary>
            Show the definition key word (class, struct, Sub, Function, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowDeclaringType">
            <summary>
            Show the declaring type for the type or member
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowModifiers">
            <summary>
            Show modifiers (virtual, override, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowReturnType">
            <summary>
            Show the return type
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.UseFullyQualifiedTypeNames">
            <summary>
            Use fully qualified names for types.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowTypeParameterList">
            <summary>
            Show the list of type parameters on method and class declarations.
            Type arguments for parameter/return types are always shown.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowBody">
            <summary>
            For fields, events and methods: adds a semicolon at the end.
            For properties: shows "{ get; }" or similar.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.UseFullyQualifiedEntityNames">
            <summary>
            Use fully qualified names for members.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.PlaceReturnTypeAfterParameterList">
            <summary>
            Instead of placing the return type before the entity name,
            append it after the parameter list, preceeded by a colon.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowTypeParameterVarianceModifier">
            <summary>
            Show the variance modifier of the type parameter.
            If active, shows 'Func&lt;in T, out TResult&gt;' instead of 'Func&lt;T, TResult&gt;'.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowParameterModifiers">
            <summary>
            Show modifiers of parameters, e.g. 'this', 'params', 'ref', 'out' and 'in'.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.ShowParameterDefaultValues">
            <summary>
            Show default values of parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.Decompiler.Output.ConversionFlags.UseNullableSpecifierForValueTypes">
            <summary>
            Use <c>T?</c> instead of <c>Nullable&lt;T&gt;</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.Decompiler.Output.IAmbience">
            <summary>
            Ambiences are used to convert type system symbols to text (usually for displaying the symbol to the user; e.g. in editor tooltips).
            </summary>
        </member>
        <member name="T:LightJson.JsonArray">
            <summary>
            Represents an ordered collection of JsonValues.
            </summary>
        </member>
        <member name="M:LightJson.JsonArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonArray"/> class.
            </summary>
        </member>
        <member name="M:LightJson.JsonArray.#ctor(LightJson.JsonValue[])">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonArray"/> class, adding the given values to the collection.
            </summary>
            <param name="values">The values to be added to this collection.</param>
        </member>
        <member name="P:LightJson.JsonArray.Count">
            <summary>
            Gets the number of values in this collection.
            </summary>
            <value>The number of values in this collection.</value>
        </member>
        <member name="P:LightJson.JsonArray.Item(System.Int32)">
            <summary>
            Gets or sets the value at the given index.
            </summary>
            <param name="index">The zero-based index of the value to get or set.</param>
            <remarks>
            The getter will return JsonValue.Null if the given index is out of range.
            </remarks>
        </member>
        <member name="M:LightJson.JsonArray.Add(LightJson.JsonValue)">
            <summary>
            Adds the given value to this collection.
            </summary>
            <param name="value">The value to be added.</param>
            <returns>Returns this collection.</returns>
        </member>
        <member name="M:LightJson.JsonArray.Insert(System.Int32,LightJson.JsonValue)">
            <summary>
            Inserts the given value at the given index in this collection.
            </summary>
            <param name="index">The index where the given value will be inserted.</param>
            <param name="value">The value to be inserted into this collection.</param>
            <returns>Returns this collection.</returns>
        </member>
        <member name="M:LightJson.JsonArray.Remove(System.Int32)">
            <summary>
            Removes the value at the given index.
            </summary>
            <param name="index">The index of the value to be removed.</param>
            <returns>Return this collection.</returns>
        </member>
        <member name="M:LightJson.JsonArray.Clear">
            <summary>
            Clears the contents of this collection.
            </summary>
            <returns>Returns this collection.</returns>
        </member>
        <member name="M:LightJson.JsonArray.Contains(LightJson.JsonValue)">
            <summary>
            Determines whether the given item is in the JsonArray.
            </summary>
            <param name="item">The item to locate in the JsonArray.</param>
            <returns>Returns true if the item is found; otherwise, false.</returns>
        </member>
        <member name="M:LightJson.JsonArray.IndexOf(LightJson.JsonValue)">
            <summary>
            Determines the index of the given item in this JsonArray.
            </summary>
            <param name="item">The item to locate in this JsonArray.</param>
            <returns>The index of the item, if found. Otherwise, returns -1.</returns>
        </member>
        <member name="M:LightJson.JsonArray.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>The enumerator that iterates through the collection.</returns>
        </member>
        <member name="M:LightJson.JsonArray.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>The enumerator that iterates through the collection.</returns>
        </member>
        <member name="T:LightJson.JsonObject">
            <summary>
            Represents a key-value pair collection of JsonValue objects.
            </summary>
        </member>
        <member name="M:LightJson.JsonObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonObject"/> class.
            </summary>
        </member>
        <member name="P:LightJson.JsonObject.Count">
            <summary>
            Gets the number of properties in this JsonObject.
            </summary>
            <value>The number of properties in this JsonObject.</value>
        </member>
        <member name="P:LightJson.JsonObject.Item(System.String)">
            <summary>
            Gets or sets the property with the given key.
            </summary>
            <param name="key">The key of the property to get or set.</param>
            <remarks>
            The getter will return JsonValue.Null if the given key is not associated with any value.
            </remarks>
        </member>
        <member name="M:LightJson.JsonObject.Add(System.String)">
            <summary>
            Adds a key with a null value to this collection.
            </summary>
            <param name="key">The key of the property to be added.</param>
            <remarks>Returns this JsonObject.</remarks>
            <returns>The <see cref="T:LightJson.JsonObject"/> that was added.</returns>
        </member>
        <member name="M:LightJson.JsonObject.Add(System.String,LightJson.JsonValue)">
            <summary>
            Adds a value associated with a key to this collection.
            </summary>
            <param name="key">The key of the property to be added.</param>
            <param name="value">The value of the property to be added.</param>
            <returns>Returns this JsonObject.</returns>
        </member>
        <member name="M:LightJson.JsonObject.Remove(System.String)">
            <summary>
            Removes a property with the given key.
            </summary>
            <param name="key">The key of the property to be removed.</param>
            <returns>
            Returns true if the given key is found and removed; otherwise, false.
            </returns>
        </member>
        <member name="M:LightJson.JsonObject.Clear">
            <summary>
            Clears the contents of this collection.
            </summary>
            <returns>Returns this JsonObject.</returns>
        </member>
        <member name="M:LightJson.JsonObject.Rename(System.String,System.String)">
            <summary>
            Changes the key of one of the items in the collection.
            </summary>
            <remarks>
            This method has no effects if the <i>oldKey</i> does not exists.
            If the <i>newKey</i> already exists, the value will be overwritten.
            </remarks>
            <param name="oldKey">The name of the key to be changed.</param>
            <param name="newKey">The new name of the key.</param>
            <returns>Returns this JsonObject.</returns>
        </member>
        <member name="M:LightJson.JsonObject.ContainsKey(System.String)">
            <summary>
            Determines whether this collection contains an item assosiated with the given key.
            </summary>
            <param name="key">The key to locate in this collection.</param>
            <returns>Returns true if the key is found; otherwise, false.</returns>
        </member>
        <member name="M:LightJson.JsonObject.Contains(LightJson.JsonValue)">
            <summary>
            Determines whether this collection contains the given JsonValue.
            </summary>
            <param name="value">The value to locate in this collection.</param>
            <returns>Returns true if the value is found; otherwise, false.</returns>
        </member>
        <member name="M:LightJson.JsonObject.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this collection.
            </summary>
            <returns>The enumerator that iterates through this collection.</returns>
        </member>
        <member name="M:LightJson.JsonObject.System#Collections#Generic#IEnumerable{LightJson#JsonValue}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this collection.
            </summary>
            <returns>The enumerator that iterates through this collection.</returns>
        </member>
        <member name="M:LightJson.JsonObject.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this collection.
            </summary>
            <returns>The enumerator that iterates through this collection.</returns>
        </member>
        <member name="T:LightJson.JsonValue">
            <summary>
            A wrapper object that contains a valid JSON value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValue.Null">
            <summary>
            Represents a null JsonValue.
            </summary>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct, representing a Boolean value.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(System.Nullable{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct, representing a Number value.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct, representing a String value.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(LightJson.JsonObject)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct, representing a JsonObject.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(LightJson.JsonArray)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct, representing a Array reference value.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="M:LightJson.JsonValue.#ctor(LightJson.JsonValueType,System.Double,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.JsonValue"/> struct.
            </summary>
            <param name="type">The Json type of the JsonValue.</param>
            <param name="value">
            The internal value of the JsonValue.
            This is used when the Json type is Number or Boolean.
            </param>
            <param name="reference">
            The internal value reference of the JsonValue.
            This value is used when the Json type is String, JsonObject, or JsonArray.
            </param>
        </member>
        <member name="P:LightJson.JsonValue.Type">
            <summary>
            Gets the type of this JsonValue.
            </summary>
            <value>The type of this JsonValue.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsNull">
            <summary>
            Gets a value indicating whether this JsonValue is Null.
            </summary>
            <value>A value indicating whether this JsonValue is Null.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsBoolean">
            <summary>
            Gets a value indicating whether this JsonValue is a Boolean.
            </summary>
            <value>A value indicating whether this JsonValue is a Boolean.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsInteger">
            <summary>
            Gets a value indicating whether this JsonValue is an Integer.
            </summary>
            <value>A value indicating whether this JsonValue is an Integer.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsNumber">
            <summary>
            Gets a value indicating whether this JsonValue is a Number.
            </summary>
            <value>A value indicating whether this JsonValue is a Number.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsString">
            <summary>
            Gets a value indicating whether this JsonValue is a String.
            </summary>
            <value>A value indicating whether this JsonValue is a String.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsJsonObject">
            <summary>
            Gets a value indicating whether this JsonValue is a JsonObject.
            </summary>
            <value>A value indicating whether this JsonValue is a JsonObject.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsJsonArray">
            <summary>
            Gets a value indicating whether this JsonValue is a JsonArray.
            </summary>
            <value>A value indicating whether this JsonValue is a JsonArray.</value>
        </member>
        <member name="P:LightJson.JsonValue.IsDateTime">
            <summary>
            Gets a value indicating whether this JsonValue represents a DateTime.
            </summary>
            <value>A value indicating whether this JsonValue represents a DateTime.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsBoolean">
            <summary>
            Gets a value indicating whether this value is true or false.
            </summary>
            <value>This value as a Boolean type.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsInteger">
            <summary>
            Gets this value as an Integer type.
            </summary>
            <value>This value as an Integer type.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsNumber">
            <summary>
            Gets this value as a Number type.
            </summary>
            <value>This value as a Number type.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsString">
            <summary>
            Gets this value as a String type.
            </summary>
            <value>This value as a String type.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsJsonObject">
            <summary>
            Gets this value as an JsonObject.
            </summary>
            <value>This value as an JsonObject.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsJsonArray">
            <summary>
            Gets this value as an JsonArray.
            </summary>
            <value>This value as an JsonArray.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsDateTime">
            <summary>
            Gets this value as a system.DateTime.
            </summary>
            <value>This value as a system.DateTime.</value>
        </member>
        <member name="P:LightJson.JsonValue.AsObject">
            <summary>
            Gets this (inner) value as a System.object.
            </summary>
            <value>This (inner) value as a System.object.</value>
        </member>
        <member name="P:LightJson.JsonValue.Item(System.String)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this JsonValue is not a JsonObject.
            </exception>
        </member>
        <member name="P:LightJson.JsonValue.Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index.
            </summary>
            <param name="index">The zero-based index of the value to get or set.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this JsonValue is not a JsonArray
            </exception>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(System.Nullable{System.Boolean})~LightJson.JsonValue">
            <summary>
            Converts the given nullable boolean into a JsonValue.
            </summary>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(System.Nullable{System.Double})~LightJson.JsonValue">
            <summary>
            Converts the given nullable double into a JsonValue.
            </summary>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(System.String)~LightJson.JsonValue">
            <summary>
            Converts the given string into a JsonValue.
            </summary>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(LightJson.JsonObject)~LightJson.JsonValue">
            <summary>
            Converts the given JsonObject into a JsonValue.
            </summary>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(LightJson.JsonArray)~LightJson.JsonValue">
            <summary>
            Converts the given JsonArray into a JsonValue.
            </summary>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Implicit(System.Nullable{System.DateTime})~LightJson.JsonValue">
            <summary>
            Converts the given DateTime? into a JsonValue.
            </summary>
            <remarks>
            The DateTime value will be stored as a string using ISO 8601 format,
            since JSON does not define a DateTime type.
            </remarks>
            <param name="value">The value to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Int32">
            <summary>
            Converts the given JsonValue into an Int.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Nullable{System.Int32}">
            <summary>
            Converts the given JsonValue into a nullable Int.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
            <exception cref="T:System.InvalidCastException">
            Throws System.InvalidCastException when the inner value type of the
            JsonValue is not the desired type of the conversion.
            </exception>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Boolean">
            <summary>
            Converts the given JsonValue into a Bool.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Nullable{System.Boolean}">
            <summary>
            Converts the given JsonValue into a nullable Bool.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
            <exception cref="T:System.InvalidCastException">
            Throws System.InvalidCastException when the inner value type of the
            JsonValue is not the desired type of the conversion.
            </exception>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Double">
            <summary>
            Converts the given JsonValue into a Double.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Nullable{System.Double}">
            <summary>
            Converts the given JsonValue into a nullable Double.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
            <exception cref="T:System.InvalidCastException">
            Throws System.InvalidCastException when the inner value type of the
            JsonValue is not the desired type of the conversion.
            </exception>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.String">
            <summary>
            Converts the given JsonValue into a String.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~LightJson.JsonObject">
            <summary>
            Converts the given JsonValue into a JsonObject.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~LightJson.JsonArray">
            <summary>
            Converts the given JsonValue into a JsonArray.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.DateTime">
            <summary>
            Converts the given JsonValue into a DateTime.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Explicit(LightJson.JsonValue)~System.Nullable{System.DateTime}">
            <summary>
            Converts the given JsonValue into a nullable DateTime.
            </summary>
            <param name="jsonValue">The JsonValue to be converted.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Equality(LightJson.JsonValue,LightJson.JsonValue)">
            <summary>
            Returns a value indicating whether the two given JsonValues are equal.
            </summary>
            <param name="a">First JsonValue to compare.</param>
            <param name="b">Second JsonValue to compare.</param>
        </member>
        <member name="M:LightJson.JsonValue.op_Inequality(LightJson.JsonValue,LightJson.JsonValue)">
            <summary>
            Returns a value indicating whether the two given JsonValues are unequal.
            </summary>
            <param name="a">First JsonValue to compare.</param>
            <param name="b">Second JsonValue to compare.</param>
        </member>
        <member name="M:LightJson.JsonValue.Parse(System.String)">
            <summary>
            Returns a JsonValue by parsing the given string.
            </summary>
            <param name="text">The JSON-formatted string to be parsed.</param>
            <returns>The <see cref="T:LightJson.JsonValue"/> representing the parsed text.</returns>
        </member>
        <member name="M:LightJson.JsonValue.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LightJson.JsonValue.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:LightJson.JsonValueType">
            <summary>
            Enumerates the types of Json values.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.Null">
            <summary>
            A null value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.Boolean">
            <summary>
            A boolean value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.Number">
            <summary>
            A number value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.String">
            <summary>
            A string value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.Object">
            <summary>
            An object value.
            </summary>
        </member>
        <member name="F:LightJson.JsonValueType.Array">
            <summary>
            An array value.
            </summary>
        </member>
        <member name="T:LightJson.Serialization.JsonParseException">
            <summary>
            The exception that is thrown when a JSON message cannot be parsed.
            </summary>
            <remarks>
            This exception is only intended to be thrown by LightJson.
            </remarks>
        </member>
        <member name="M:LightJson.Serialization.JsonParseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.Serialization.JsonParseException"/> class.
            </summary>
        </member>
        <member name="M:LightJson.Serialization.JsonParseException.#ctor(LightJson.Serialization.JsonParseException.ErrorType,LightJson.Serialization.TextPosition)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.Serialization.JsonParseException"/> class with the given error type and position.
            </summary>
            <param name="type">The error type that describes the cause of the error.</param>
            <param name="position">The position in the text where the error occurred.</param>
        </member>
        <member name="M:LightJson.Serialization.JsonParseException.#ctor(System.String,LightJson.Serialization.JsonParseException.ErrorType,LightJson.Serialization.TextPosition)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.Serialization.JsonParseException"/> class with the given message, error type, and position.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="type">The error type that describes the cause of the error.</param>
            <param name="position">The position in the text where the error occurred.</param>
        </member>
        <member name="T:LightJson.Serialization.JsonParseException.ErrorType">
            <summary>
            Enumerates the types of errors that can occur when parsing a JSON message.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.JsonParseException.ErrorType.Unknown">
            <summary>
            Indicates that the cause of the error is unknown.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.JsonParseException.ErrorType.IncompleteMessage">
            <summary>
            Indicates that the text ended before the message could be parsed.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.JsonParseException.ErrorType.DuplicateObjectKeys">
            <summary>
            Indicates that a JsonObject contains more than one key with the same name.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.JsonParseException.ErrorType.InvalidOrUnexpectedCharacter">
            <summary>
            Indicates that the parser encountered and invalid or unexpected character.
            </summary>
        </member>
        <member name="P:LightJson.Serialization.JsonParseException.Position">
            <summary>
            Gets the text position where the error occurred.
            </summary>
            <value>The text position where the error occurred.</value>
        </member>
        <member name="P:LightJson.Serialization.JsonParseException.Type">
            <summary>
            Gets the type of error that caused the exception to be thrown.
            </summary>
            <value>The type of error that caused the exception to be thrown.</value>
        </member>
        <member name="T:LightJson.Serialization.JsonReader">
            <summary>
            Represents a reader that can read JsonValues.
            </summary>
        </member>
        <member name="M:LightJson.Serialization.JsonReader.Parse(System.IO.TextReader)">
            <summary>
            Creates a JsonValue by using the given TextReader.
            </summary>
            <param name="reader">The TextReader used to read a JSON message.</param>
            <returns>The parsed <see cref="T:LightJson.JsonValue"/>.</returns>
        </member>
        <member name="M:LightJson.Serialization.JsonReader.Parse(System.String)">
            <summary>
            Creates a JsonValue by reader the JSON message in the given string.
            </summary>
            <param name="source">The string containing the JSON message.</param>
            <returns>The parsed <see cref="T:LightJson.JsonValue"/>.</returns>
        </member>
        <member name="T:LightJson.Serialization.TextPosition">
            <summary>
            Represents a position within a plain text resource.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.TextPosition.Column">
            <summary>
            The column position, 0-based.
            </summary>
        </member>
        <member name="F:LightJson.Serialization.TextPosition.Line">
            <summary>
            The line position, 0-based.
            </summary>
        </member>
        <member name="T:LightJson.Serialization.TextScanner">
            <summary>
            Represents a text scanner that reads one character at a time.
            </summary>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the <see cref="T:LightJson.Serialization.TextScanner"/> class.
            </summary>
            <param name="reader">The TextReader to read the text.</param>
        </member>
        <member name="P:LightJson.Serialization.TextScanner.Position">
            <summary>
            Gets the position of the scanner within the text.
            </summary>
            <value>The position of the scanner within the text.</value>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.Peek">
            <summary>
            Reads the next character in the stream without changing the current position.
            </summary>
            <returns>The next character in the stream.</returns>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.Peek(System.Boolean)">
            <summary>
            Reads the next character in the stream without changing the current position.
            </summary>
            <param name="throwAtEndOfFile"><see langword="true"/> to throw an exception if the end of the file is
            reached; otherwise, <see langword="false"/>.</param>
            <returns>The next character in the stream, or -1 if the end of the file is reached with
            <paramref name="throwAtEndOfFile"/> set to <see langword="false"/>.</returns>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.Read">
            <summary>
            Reads the next character in the stream, advancing the text position.
            </summary>
            <returns>The next character in the stream.</returns>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.SkipWhitespace">
            <summary>
            Advances the scanner to next non-whitespace character.
            </summary>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.Assert(System.Char)">
            <summary>
            Verifies that the given character matches the next character in the stream.
            If the characters do not match, an exception will be thrown.
            </summary>
            <param name="next">The expected character.</param>
        </member>
        <member name="M:LightJson.Serialization.TextScanner.Assert(System.String)">
            <summary>
            Verifies that the given string matches the next characters in the stream.
            If the strings do not match, an exception will be thrown.
            </summary>
            <param name="next">The expected string.</param>
        </member>
    </members>
</doc>
